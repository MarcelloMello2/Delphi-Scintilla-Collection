unit ScintillaFacerGenerator.FileGenerator;

{$IFDEF FPC}
  {$MODE DELPHI}
{$ENDIF}

interface

uses
  System.SysUtils,
  System.Classes,
  System.StrUtils;

const
  {$IFDEF MSWINDOWS}
  LineEnd = #13#10;
  {$ELSE}
  LineEnd = #10;
  {$ENDIF}

procedure UpdateFile(const FileName: string; const Updated: string);
function CopyWithInsertion(const Input: TStringList; const CommentPrefix: string;
  RetainDefs: Boolean; const Lists: array of TStringList): string;
procedure GenerateFile(const InPath, OutPath, CommentPrefix: string;
  RetainDefs: Boolean; const Lists: array of TStringList);
procedure Generate(const InPath, OutPath, CommentPrefix: string;
  const Lists: array of TStringList);
procedure Regenerate(const FileName, CommentPrefix: string;
  const Lists: array of TStringList);

implementation

procedure UpdateFile(const FileName: string; const Updated: string);
var
  Original: string;
  FileStream: TFileStream;
  Changed: string;
begin
  Changed := 'Changed';
  
  // Tenta ler o arquivo existente
  if FileExists(FileName) then
  begin
    FileStream := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
    try
      SetLength(Original, FileStream.Size);
      if FileStream.Size > 0 then
        FileStream.ReadBuffer(Original[1], FileStream.Size);
    finally
      FileStream.Free;
    end;
    
    // Se o conteúdo é igual, não precisa atualizar
    if Original = Updated then
      Exit;
      
    DeleteFile(FileName);
  end
  else
    Changed := 'New';
  
  // Escreve o novo conteúdo
  FileStream := TFileStream.Create(FileName, fmCreate);
  try
    if Length(Updated) > 0 then
      FileStream.WriteBuffer(Updated[1], Length(Updated));
  finally
    FileStream.Free;
  end;
  
  WriteLn(FileName + ':0: ' + Changed);
end;

function CopyWithInsertion(const Input: TStringList; const CommentPrefix: string;
  RetainDefs: Boolean; const Lists: array of TStringList): string;
var
  Copying: Boolean;
  Generated: Boolean;
  ListId: Integer;
  Output: TStringList;
  I, J: Integer;
  Line: string;
  IsStartGenerated: Boolean;
  Definition: string;
  StartRepeat, EndRepeat: Integer;
  Intro, Middle, Outro: string;
  ItemStr: string;
  Pos: Integer;
begin
  Copying := True;
  Generated := False;
  ListId := 0;
  Output := TStringList.Create;
  try
    for I := 0 to Input.Count - 1 do
    begin
      Line := Input[I];
      IsStartGenerated := TrimLeft(Line).StartsWith(CommentPrefix + '++Autogenerated');
      
      if Copying and not IsStartGenerated then
        Output.Add(Line);
        
      if IsStartGenerated then
      begin
        if RetainDefs then
          Output.Add(Line);
        Copying := False;
        Generated := False;
      end
      else if not Copying and not Generated then
      begin
        // Gerando
        if Line.StartsWith(CommentPrefix + '**') then
        begin
          // Padrão para transformar dados de entrada
          if RetainDefs then
            Output.Add(Line);
            
          Definition := Copy(Line, Length(CommentPrefix + '**') + 1, MaxInt);
          
          // Para comentários HTML
          if (CommentPrefix = '<!--') and ContainsStr(Definition, ' -->') then
            Definition := StringReplace(Definition, ' -->', '', []);
            
          ListId := 0;
          if (Length(Definition) > 0) and (Definition[1] in ['0'..'9']) then
          begin
            ListId := StrToInt(Definition[1]);
            Definition := Copy(Definition, 3, MaxInt);
          end;
          
          // Esconde barras duplas como caractere de controle
          Definition := StringReplace(Definition, '\\', #1, [rfReplaceAll]);
          // Faz algumas transformações estilo C
          Definition := StringReplace(Definition, '\n', #10, [rfReplaceAll]);
          Definition := StringReplace(Definition, '\t', #9, [rfReplaceAll]);
          // Recupera as barras duplas como barras simples
          Definition := StringReplace(Definition, #1, '\', [rfReplaceAll]);
          
          StartRepeat := System.Pos('\(', Definition);
          EndRepeat := System.Pos('\)', Definition);
          
          if (StartRepeat > 0) and (EndRepeat > 0) then
          begin
            Intro := Copy(Definition, 1, StartRepeat - 1);
            ItemStr := '';
            
            if EndsStr(#10, Intro) then
              Pos := 0
            else
              Pos := Length(Intro);
              
            ItemStr := ItemStr + Intro;
            
            Middle := Copy(Definition, StartRepeat + 2, EndRepeat - StartRepeat - 2);
            
            if (ListId >= 0) and (ListId <= High(Lists)) and Assigned(Lists[ListId]) then
            begin
              for J := 0 to Lists[ListId].Count - 1 do
              begin
                ItemStr := ItemStr + StringReplace(Middle, '\*', Lists[ListId][J], [rfReplaceAll]);
                Inc(Pos, Length(StringReplace(Middle, '\*', Lists[ListId][J], [rfReplaceAll])));
                
                if (Pos > 0) and (Pos + Length(Lists[ListId][J]) >= 80) then
                begin
                  ItemStr := ItemStr + '\' + LineEnd;
                  Pos := 0;
                end;
                
                if EndsStr(#10, ItemStr) then
                  Pos := 0;
              end;
            end;
            
            Outro := Copy(Definition, EndRepeat + 2, MaxInt);
            ItemStr := ItemStr + Outro;
            
            // Corrige EOLs no conteúdo gerado
            ItemStr := StringReplace(ItemStr, #10, LineEnd, [rfReplaceAll]);
            Output.Add(ItemStr);
          end
          else
          begin
            // Forma simples sem regra para transformar entrada
            if (Length(Lists) > 0) and Assigned(Lists[0]) then
              Output.AddStrings(Lists[0]);
          end;
          
          Generated := True;
        end;
      end;
      
      if TrimLeft(Line).StartsWith(CommentPrefix + '--Autogenerated') or
         TrimLeft(Line).StartsWith(CommentPrefix + '~~Autogenerated') then
      begin
        Copying := True;
        if RetainDefs then
          Output.Add(Line);
      end;
    end;
    
    // Remove espaços em branco à direita
    for I := 0 to Output.Count - 1 do
      Output[I] := TrimRight(Output[I]);
      
    Result := Output.Text;
  finally
    Output.Free;
  end;
end;

procedure GenerateFile(const InPath, OutPath, CommentPrefix: string;
  RetainDefs: Boolean; const Lists: array of TStringList);
var
  InFile: TStringList;
  Updated: string;
begin
  if not FileExists(InPath) then
  begin
    WriteLn('Can not open ' + InPath);
    Exit;
  end;
  
  InFile := TStringList.Create;
  try
    InFile.LoadFromFile(InPath);
    Updated := CopyWithInsertion(InFile, CommentPrefix, RetainDefs, Lists);
    UpdateFile(OutPath, Updated);
  finally
    InFile.Free;
  end;
end;

procedure Generate(const InPath, OutPath, CommentPrefix: string;
  const Lists: array of TStringList);
begin
  GenerateFile(InPath, OutPath, CommentPrefix, InPath = OutPath, Lists);
end;

procedure Regenerate(const FileName, CommentPrefix: string;
  const Lists: array of TStringList);
begin
  Generate(FileName, FileName, CommentPrefix, Lists);
end;

end.