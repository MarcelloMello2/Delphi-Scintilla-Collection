unit DScintilla;

{
  Delphi wrapper for Scintilla editor
  Auto-generated from Scintilla.iface
  Generation date: 04/06/2025 22:33:27
}

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls;

const
  INVALID_POSITION = -1;
  /// <summary>
  /// Define start of Scintilla messages to be greater than all Windows edit (EM_*) messages
  /// as many EM_ messages can be used although that use is deprecated.
  /// </summary>
  SCI_START = 2000;
  /// <summary>
  /// Define start of Scintilla messages to be greater than all Windows edit (EM_*) messages
  /// as many EM_ messages can be used although that use is deprecated.
  /// </summary>
  SCI_OPTIONAL_START = 3000;
  /// <summary>
  /// Define start of Scintilla messages to be greater than all Windows edit (EM_*) messages
  /// as many EM_ messages can be used although that use is deprecated.
  /// </summary>
  SCI_LEXER_START = 4000;

  // SCWS_ enumeration
  SCWS_INVISIBLE = 0;
  SCWS_VISIBLEALWAYS = 1;
  SCWS_VISIBLEAFTERINDENT = 2;
  SCWS_VISIBLEONLYININDENT = 3;

  // SCTD_ enumeration
  SCTD_LONGARROW = 0;
  SCTD_STRIKEOUT = 1;

  // SC_EOL_ enumeration
  SC_EOL_CRLF = 0;
  SC_EOL_CR = 1;
  SC_EOL_LF = 2;
  /// <summary>
  /// The SC_CP_UTF8 value can be used to enter Unicode mode.
  /// This is the same value as CP_UTF8 in Windows
  /// </summary>
  SC_CP_UTF8 = 65001;

  // SC_IME_ enumeration
  SC_IME_WINDOWED = 0;
  SC_IME_INLINE = 1;

  // SC_ALPHA_ enumeration
  SC_ALPHA_TRANSPARENT = 0;
  SC_ALPHA_OPAQUE = 255;
  SC_ALPHA_NOALPHA = 256;

  // SC_CURSOR enumeration
  SC_CURSORNORMAL = -1;
  SC_CURSORARROW = 2;
  SC_CURSORWAIT = 4;
  SC_CURSORREVERSEARROW = 7;
  MARKER_MAX = 31;

  // SC_MARK_ enumeration
  SC_MARK_CIRCLE = 0;
  SC_MARK_ROUNDRECT = 1;
  SC_MARK_ARROW = 2;
  SC_MARK_SMALLRECT = 3;
  SC_MARK_SHORTARROW = 4;
  SC_MARK_EMPTY = 5;
  SC_MARK_ARROWDOWN = 6;
  SC_MARK_MINUS = 7;
  SC_MARK_PLUS = 8;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_VLINE = 9;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_LCORNER = 10;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_TCORNER = 11;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_BOXPLUS = 12;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_BOXPLUSCONNECTED = 13;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_BOXMINUS = 14;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_BOXMINUSCONNECTED = 15;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_LCORNERCURVE = 16;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_TCORNERCURVE = 17;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_CIRCLEPLUS = 18;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_CIRCLEPLUSCONNECTED = 19;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_CIRCLEMINUS = 20;
  /// <summary>
  /// Shapes used for outlining column.
  /// </summary>
  SC_MARK_CIRCLEMINUSCONNECTED = 21;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_BACKGROUND = 22;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_DOTDOTDOT = 23;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_ARROWS = 24;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_PIXMAP = 25;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_FULLRECT = 26;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_LEFTRECT = 27;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_AVAILABLE = 28;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_UNDERLINE = 29;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_RGBAIMAGE = 30;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_BOOKMARK = 31;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_VERTICALBOOKMARK = 32;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_BAR = 33;
  /// <summary>
  /// Invisible mark that only sets the line background colour.
  /// </summary>
  SC_MARK_CHARACTER = 10000;

  // SC_MARKNUM_ enumeration
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_HISTORY_REVERTED_TO_ORIGIN = 21;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_HISTORY_SAVED = 22;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_HISTORY_MODIFIED = 23;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_HISTORY_REVERTED_TO_MODIFIED = 24;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_FOLDEREND = 25;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_FOLDEROPENMID = 26;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_FOLDERMIDTAIL = 27;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_FOLDERTAIL = 28;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_FOLDERSUB = 29;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_FOLDER = 30;
  /// <summary>
  /// Markers used for outlining and change history columns.
  /// </summary>
  SC_MARKNUM_FOLDEROPEN = 31;
  SC_MASK_HISTORY = $01E00000;
  /// <summary>
  /// SC_MASK_FOLDERS doesn't go in an enumeration as larger than max 32-bit positive integer
  /// </summary>
  SC_MASK_FOLDERS = $FE000000;
  SC_MAX_MARGIN = 4;

  // SC_MARGIN_ enumeration
  SC_MARGIN_SYMBOL = 0;
  SC_MARGIN_NUMBER = 1;
  SC_MARGIN_BACK = 2;
  SC_MARGIN_FORE = 3;
  SC_MARGIN_TEXT = 4;
  SC_MARGIN_RTEXT = 5;
  SC_MARGIN_COLOUR = 6;

  // STYLE_ enumeration
  STYLE_DEFAULT = 32;
  STYLE_LINENUMBER = 33;
  STYLE_BRACELIGHT = 34;
  STYLE_BRACEBAD = 35;
  STYLE_CONTROLCHAR = 36;
  STYLE_INDENTGUIDE = 37;
  STYLE_CALLTIP = 38;
  STYLE_FOLDDISPLAYTEXT = 39;
  STYLE_LASTPREDEFINED = 39;
  STYLE_MAX = 255;

  // SC_CHARSET_ enumeration
  SC_CHARSET_ANSI = 0;
  SC_CHARSET_DEFAULT = 1;
  SC_CHARSET_BALTIC = 186;
  SC_CHARSET_CHINESEBIG5 = 136;
  SC_CHARSET_EASTEUROPE = 238;
  SC_CHARSET_GB2312 = 134;
  SC_CHARSET_GREEK = 161;
  SC_CHARSET_HANGUL = 129;
  SC_CHARSET_MAC = 77;
  SC_CHARSET_OEM = 255;
  SC_CHARSET_RUSSIAN = 204;
  SC_CHARSET_OEM866 = 866;
  SC_CHARSET_CYRILLIC = 1251;
  SC_CHARSET_SHIFTJIS = 128;
  SC_CHARSET_SYMBOL = 2;
  SC_CHARSET_TURKISH = 162;
  SC_CHARSET_JOHAB = 130;
  SC_CHARSET_HEBREW = 177;
  SC_CHARSET_ARABIC = 178;
  SC_CHARSET_VIETNAMESE = 163;
  SC_CHARSET_THAI = 222;
  SC_CHARSET_8859_15 = 1000;

  // SC_CASE_ enumeration
  SC_CASE_MIXED = 0;
  SC_CASE_UPPER = 1;
  SC_CASE_LOWER = 2;
  SC_CASE_CAMEL = 3;
  SC_FONT_SIZE_MULTIPLIER = 100;

  // SC_WEIGHT_ enumeration
  SC_WEIGHT_NORMAL = 400;
  SC_WEIGHT_SEMIBOLD = 600;
  SC_WEIGHT_BOLD = 700;

  // SC_STRETCH_ enumeration
  SC_STRETCH_ULTRA_CONDENSED = 1;
  SC_STRETCH_EXTRA_CONDENSED = 2;
  SC_STRETCH_CONDENSED = 3;
  SC_STRETCH_SEMI_CONDENSED = 4;
  SC_STRETCH_NORMAL = 5;
  SC_STRETCH_SEMI_EXPANDED = 6;
  SC_STRETCH_EXPANDED = 7;
  SC_STRETCH_EXTRA_EXPANDED = 8;
  SC_STRETCH_ULTRA_EXPANDED = 9;

  // SC_ELEMENT_ enumeration
  SC_ELEMENT_LIST = 0;
  SC_ELEMENT_LIST_BACK = 1;
  SC_ELEMENT_LIST_SELECTED = 2;
  SC_ELEMENT_LIST_SELECTED_BACK = 3;
  SC_ELEMENT_SELECTION_TEXT = 10;
  SC_ELEMENT_SELECTION_BACK = 11;
  SC_ELEMENT_SELECTION_ADDITIONAL_TEXT = 12;
  SC_ELEMENT_SELECTION_ADDITIONAL_BACK = 13;
  SC_ELEMENT_SELECTION_SECONDARY_TEXT = 14;
  SC_ELEMENT_SELECTION_SECONDARY_BACK = 15;
  SC_ELEMENT_SELECTION_INACTIVE_TEXT = 16;
  SC_ELEMENT_SELECTION_INACTIVE_BACK = 17;
  SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_TEXT = 18;
  SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_BACK = 19;
  SC_ELEMENT_CARET = 40;
  SC_ELEMENT_CARET_ADDITIONAL = 41;
  SC_ELEMENT_CARET_LINE_BACK = 50;
  SC_ELEMENT_WHITE_SPACE = 60;
  SC_ELEMENT_WHITE_SPACE_BACK = 61;
  SC_ELEMENT_HOT_SPOT_ACTIVE = 70;
  SC_ELEMENT_HOT_SPOT_ACTIVE_BACK = 71;
  SC_ELEMENT_FOLD_LINE = 80;
  SC_ELEMENT_HIDDEN_LINE = 81;

  // SC_LAYER_ enumeration
  SC_LAYER_BASE = 0;
  SC_LAYER_UNDER_TEXT = 1;
  SC_LAYER_OVER_TEXT = 2;

  // INDIC_ enumeration
  INDIC_PLAIN = 0;
  INDIC_SQUIGGLE = 1;
  INDIC_TT = 2;
  INDIC_DIAGONAL = 3;
  INDIC_STRIKE = 4;
  INDIC_HIDDEN = 5;
  INDIC_BOX = 6;
  INDIC_ROUNDBOX = 7;
  INDIC_STRAIGHTBOX = 8;
  INDIC_DASH = 9;
  INDIC_DOTS = 10;
  INDIC_SQUIGGLELOW = 11;
  INDIC_DOTBOX = 12;
  INDIC_SQUIGGLEPIXMAP = 13;
  INDIC_COMPOSITIONTHICK = 14;
  INDIC_COMPOSITIONTHIN = 15;
  INDIC_FULLBOX = 16;
  INDIC_TEXTFORE = 17;
  INDIC_POINT = 18;
  INDIC_POINTCHARACTER = 19;
  INDIC_GRADIENT = 20;
  INDIC_GRADIENTCENTRE = 21;
  INDIC_POINT_TOP = 22;
  /// <summary>
  /// INDIC_CONTAINER, INDIC_IME, INDIC_IME_MAX, and INDIC_MAX are indicator numbers,
  /// not IndicatorStyles so should not really be in the INDIC_ enumeration.
  /// They are redeclared in IndicatorNumbers INDICATOR_.
  /// </summary>
  INDIC_CONTAINER = 8;
  /// <summary>
  /// INDIC_CONTAINER, INDIC_IME, INDIC_IME_MAX, and INDIC_MAX are indicator numbers,
  /// not IndicatorStyles so should not really be in the INDIC_ enumeration.
  /// They are redeclared in IndicatorNumbers INDICATOR_.
  /// </summary>
  INDIC_IME = 32;
  /// <summary>
  /// INDIC_CONTAINER, INDIC_IME, INDIC_IME_MAX, and INDIC_MAX are indicator numbers,
  /// not IndicatorStyles so should not really be in the INDIC_ enumeration.
  /// They are redeclared in IndicatorNumbers INDICATOR_.
  /// </summary>
  INDIC_IME_MAX = 35;
  /// <summary>
  /// INDIC_CONTAINER, INDIC_IME, INDIC_IME_MAX, and INDIC_MAX are indicator numbers,
  /// not IndicatorStyles so should not really be in the INDIC_ enumeration.
  /// They are redeclared in IndicatorNumbers INDICATOR_.
  /// </summary>
  INDIC_MAX = 35;

  // INDICATOR_ enumeration
  INDICATOR_CONTAINER = 8;
  INDICATOR_IME = 32;
  INDICATOR_IME_MAX = 35;
  INDICATOR_HISTORY_REVERTED_TO_ORIGIN_INSERTION = 36;
  INDICATOR_HISTORY_REVERTED_TO_ORIGIN_DELETION = 37;
  INDICATOR_HISTORY_SAVED_INSERTION = 38;
  INDICATOR_HISTORY_SAVED_DELETION = 39;
  INDICATOR_HISTORY_MODIFIED_INSERTION = 40;
  INDICATOR_HISTORY_MODIFIED_DELETION = 41;
  INDICATOR_HISTORY_REVERTED_TO_MODIFIED_INSERTION = 42;
  INDICATOR_HISTORY_REVERTED_TO_MODIFIED_DELETION = 43;
  INDICATOR_MAX = 43;

  // SC_INDICVALUE enumeration
  SC_INDICVALUEBIT = $1000000;
  SC_INDICVALUEMASK = $FFFFFF;

  // SC_INDICFLAG_ enumeration
  SC_INDICFLAG_NONE = 0;
  SC_INDICFLAG_VALUEFORE = 1;

  // SC_AUTOCOMPLETE_ enumeration
  SC_AUTOCOMPLETE_NORMAL = 0;
  /// <summary>
  /// Win32 specific:
  /// </summary>
  SC_AUTOCOMPLETE_FIXED_SIZE = 1;
  /// <summary>
  /// Always select the first item in the autocompletion list:
  /// </summary>
  SC_AUTOCOMPLETE_SELECT_FIRST_ITEM = 2;

  // SC_IV_ enumeration
  SC_IV_NONE = 0;
  SC_IV_REAL = 1;
  SC_IV_LOOKFORWARD = 2;
  SC_IV_LOOKBOTH = 3;

  // SC_PRINT_ enumeration
  /// <summary>
  /// PrintColourMode - use same colours as screen.
  /// with the exception of line number margins, which use a white background
  /// </summary>
  SC_PRINT_NORMAL = 0;
  /// <summary>
  /// PrintColourMode - invert the light value of each style for printing.
  /// </summary>
  SC_PRINT_INVERTLIGHT = 1;
  /// <summary>
  /// PrintColourMode - force black text on white background for printing.
  /// </summary>
  SC_PRINT_BLACKONWHITE = 2;
  /// <summary>
  /// PrintColourMode - text stays coloured, but all background is forced to be white for printing.
  /// </summary>
  SC_PRINT_COLOURONWHITE = 3;
  /// <summary>
  /// PrintColourMode - only the default-background is forced to be white for printing.
  /// </summary>
  SC_PRINT_COLOURONWHITEDEFAULTBG = 4;
  /// <summary>
  /// PrintColourMode - use same colours as screen, including line number margins.
  /// </summary>
  SC_PRINT_SCREENCOLOURS = 5;

  // SCFIND_ enumeration
  SCFIND_NONE = $0;
  SCFIND_WHOLEWORD = $2;
  SCFIND_MATCHCASE = $4;
  SCFIND_WORDSTART = $00100000;
  SCFIND_REGEXP = $00200000;
  SCFIND_POSIX = $00400000;
  SCFIND_CXX11REGEX = $00800000;

  // SC_CHANGE_HISTORY_ enumeration
  SC_CHANGE_HISTORY_DISABLED = 0;
  SC_CHANGE_HISTORY_ENABLED = 1;
  SC_CHANGE_HISTORY_MARKERS = 2;
  SC_CHANGE_HISTORY_INDICATORS = 4;

  // SC_UNDO_SELECTION_HISTORY_ enumeration
  SC_UNDO_SELECTION_HISTORY_DISABLED = 0;
  SC_UNDO_SELECTION_HISTORY_ENABLED = 1;

  // SC_FOLDLEVEL enumeration
  SC_FOLDLEVELNONE = $0;
  SC_FOLDLEVELBASE = $400;
  SC_FOLDLEVELWHITEFLAG = $1000;
  SC_FOLDLEVELHEADERFLAG = $2000;
  SC_FOLDLEVELNUMBERMASK = $0FFF;

  // SC_FOLDDISPLAYTEXT_ enumeration
  SC_FOLDDISPLAYTEXT_HIDDEN = 0;
  SC_FOLDDISPLAYTEXT_STANDARD = 1;
  SC_FOLDDISPLAYTEXT_BOXED = 2;

  // SC_FOLDACTION_ enumeration
  SC_FOLDACTION_CONTRACT = 0;
  SC_FOLDACTION_EXPAND = 1;
  SC_FOLDACTION_TOGGLE = 2;
  SC_FOLDACTION_CONTRACT_EVERY_LEVEL = 4;

  // SC_AUTOMATICFOLD_ enumeration
  SC_AUTOMATICFOLD_NONE = $0000;
  SC_AUTOMATICFOLD_SHOW = $0001;
  SC_AUTOMATICFOLD_CLICK = $0002;
  SC_AUTOMATICFOLD_CHANGE = $0004;

  // SC_FOLDFLAG_ enumeration
  SC_FOLDFLAG_NONE = $0000;
  SC_FOLDFLAG_LINEBEFORE_EXPANDED = $0002;
  SC_FOLDFLAG_LINEBEFORE_CONTRACTED = $0004;
  SC_FOLDFLAG_LINEAFTER_EXPANDED = $0008;
  SC_FOLDFLAG_LINEAFTER_CONTRACTED = $0010;
  SC_FOLDFLAG_LEVELNUMBERS = $0040;
  SC_FOLDFLAG_LINESTATE = $0080;
  SC_TIME_FOREVER = 10000000;

  // SC_IDLESTYLING_ enumeration
  SC_IDLESTYLING_NONE = 0;
  SC_IDLESTYLING_TOVISIBLE = 1;
  SC_IDLESTYLING_AFTERVISIBLE = 2;
  SC_IDLESTYLING_ALL = 3;

  // SC_WRAP_ enumeration
  SC_WRAP_NONE = 0;
  SC_WRAP_WORD = 1;
  SC_WRAP_CHAR = 2;
  SC_WRAP_WHITESPACE = 3;

  // SC_WRAPVISUALFLAG_ enumeration
  SC_WRAPVISUALFLAG_NONE = $0000;
  SC_WRAPVISUALFLAG_END = $0001;
  SC_WRAPVISUALFLAG_START = $0002;
  SC_WRAPVISUALFLAG_MARGIN = $0004;

  // SC_WRAPVISUALFLAGLOC_ enumeration
  SC_WRAPVISUALFLAGLOC_DEFAULT = $0000;
  SC_WRAPVISUALFLAGLOC_END_BY_TEXT = $0001;
  SC_WRAPVISUALFLAGLOC_START_BY_TEXT = $0002;

  // SC_WRAPINDENT_ enumeration
  SC_WRAPINDENT_FIXED = 0;
  SC_WRAPINDENT_SAME = 1;
  SC_WRAPINDENT_INDENT = 2;
  SC_WRAPINDENT_DEEPINDENT = 3;

  // SC_CACHE_ enumeration
  SC_CACHE_NONE = 0;
  SC_CACHE_CARET = 1;
  SC_CACHE_PAGE = 2;
  SC_CACHE_DOCUMENT = 3;

  // SC_PHASES_ enumeration
  SC_PHASES_ONE = 0;
  SC_PHASES_TWO = 1;
  SC_PHASES_MULTIPLE = 2;

  // SC_EFF_ enumeration
  SC_EFF_QUALITY_MASK = $F;
  SC_EFF_QUALITY_DEFAULT = 0;
  SC_EFF_QUALITY_NON_ANTIALIASED = 1;
  SC_EFF_QUALITY_ANTIALIASED = 2;
  SC_EFF_QUALITY_LCD_OPTIMIZED = 3;

  // SC_MULTIPASTE_ enumeration
  SC_MULTIPASTE_ONCE = 0;
  SC_MULTIPASTE_EACH = 1;

  // SC_ACCESSIBILITY_ enumeration
  SC_ACCESSIBILITY_DISABLED = 0;
  SC_ACCESSIBILITY_ENABLED = 1;

  // EDGE_ enumeration
  EDGE_NONE = 0;
  EDGE_LINE = 1;
  EDGE_BACKGROUND = 2;
  EDGE_MULTILINE = 3;

  // SC_POPUP_ enumeration
  SC_POPUP_NEVER = 0;
  SC_POPUP_ALL = 1;
  SC_POPUP_TEXT = 2;

  // SC_DOCUMENTOPTION_ enumeration
  SC_DOCUMENTOPTION_DEFAULT = 0;
  SC_DOCUMENTOPTION_STYLES_NONE = $1;
  SC_DOCUMENTOPTION_TEXT_LARGE = $100;

  // SC_STATUS_ enumeration
  SC_STATUS_OK = 0;
  SC_STATUS_FAILURE = 1;
  SC_STATUS_BADALLOC = 2;
  SC_STATUS_WARN_START = 1000;
  SC_STATUS_WARN_REGEX = 1001;

  // VISIBLE_ enumeration
  VISIBLE_SLOP = $01;
  VISIBLE_STRICT = $04;

  // CARET_ enumeration
  /// <summary>
  /// Caret policy, used by SetXCaretPolicy and SetYCaretPolicy.
  /// If CARET_SLOP is set, we can define a slop value: caretSlop.
  /// This value defines an unwanted zone (UZ) where the caret is... unwanted.
  /// This zone is defined as a number of pixels near the vertical margins,
  /// and as a number of lines near the horizontal margins.
  /// By keeping the caret away from the edges, it is seen within its context,
  /// so it is likely that the identifier that the caret is on can be completely seen,
  /// and that the current line is seen with some of the lines following it which are
  /// often dependent on that line.
  /// </summary>
  CARET_SLOP = $01;
  /// <summary>
  /// If CARET_STRICT is set, the policy is enforced... strictly.
  /// The caret is centred on the display if slop is not set,
  /// and cannot go in the UZ if slop is set.
  /// </summary>
  CARET_STRICT = $04;
  /// <summary>
  /// If CARET_JUMPS is set, the display is moved more energetically
  /// so the caret can move in the same direction longer before the policy is applied again.
  /// </summary>
  CARET_JUMPS = $10;
  /// <summary>
  /// If CARET_EVEN is not set, instead of having symmetrical UZs,
  /// the left and bottom UZs are extended up to right and top UZs respectively.
  /// This way, we favour the displaying of useful information: the beginning of lines,
  /// where most code reside, and the lines after the caret, eg. the body of a function.
  /// </summary>
  CARET_EVEN = $08;

  // SC_SEL_ enumeration
  SC_SEL_STREAM = 0;
  SC_SEL_RECTANGLE = 1;
  SC_SEL_LINES = 2;
  SC_SEL_THIN = 3;

  // SC_CASEINSENSITIVEBEHAVIOUR_ enumeration
  SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE = 0;
  SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE = 1;

  // SC_MULTIAUTOC_ enumeration
  SC_MULTIAUTOC_ONCE = 0;
  SC_MULTIAUTOC_EACH = 1;

  // SC_ORDER_ enumeration
  SC_ORDER_PRESORTED = 0;
  SC_ORDER_PERFORMSORT = 1;
  SC_ORDER_CUSTOM = 2;

  // SC_CARETSTICKY_ enumeration
  SC_CARETSTICKY_OFF = 0;
  SC_CARETSTICKY_ON = 1;
  SC_CARETSTICKY_WHITESPACE = 2;

  // CARETSTYLE_ enumeration
  CARETSTYLE_INVISIBLE = 0;
  CARETSTYLE_LINE = 1;
  CARETSTYLE_BLOCK = 2;
  CARETSTYLE_OVERSTRIKE_BAR = 0;
  CARETSTYLE_OVERSTRIKE_BLOCK = $10;
  CARETSTYLE_CURSES = $20;
  CARETSTYLE_INS_MASK = $F;
  CARETSTYLE_BLOCK_AFTER = $100;

  // SC_MARGINOPTION_ enumeration
  SC_MARGINOPTION_NONE = 0;
  SC_MARGINOPTION_SUBLINESELECT = 1;

  // ANNOTATION_ enumeration
  ANNOTATION_HIDDEN = 0;
  ANNOTATION_STANDARD = 1;
  ANNOTATION_BOXED = 2;
  ANNOTATION_INDENTED = 3;

  // UNDO_ enumeration
  UNDO_NONE = 0;
  UNDO_MAY_COALESCE = 1;

  // SCVS_ enumeration
  SCVS_NONE = 0;
  SCVS_RECTANGULARSELECTION = 1;
  SCVS_USERACCESSIBLE = 2;
  SCVS_NOWRAPLINESTART = 4;

  // SC_TECHNOLOGY_ enumeration
  SC_TECHNOLOGY_DEFAULT = 0;
  SC_TECHNOLOGY_DIRECTWRITE = 1;
  SC_TECHNOLOGY_DIRECTWRITERETAIN = 2;
  SC_TECHNOLOGY_DIRECTWRITEDC = 3;
  SC_TECHNOLOGY_DIRECT_WRITE_1 = 4;

  // SC_LINE_END_TYPE_ enumeration
  SC_LINE_END_TYPE_DEFAULT = 0;
  SC_LINE_END_TYPE_UNICODE = 1;

  // SC_REPRESENTATION enumeration
  SC_REPRESENTATION_PLAIN = 0;
  SC_REPRESENTATION_BLOB = 1;
  SC_REPRESENTATION_COLOUR = $10;

  // EOLANNOTATION_ enumeration
  EOLANNOTATION_HIDDEN = $0;
  EOLANNOTATION_STANDARD = $1;
  EOLANNOTATION_BOXED = $2;
  EOLANNOTATION_STADIUM = $100;
  EOLANNOTATION_FLAT_CIRCLE = $101;
  EOLANNOTATION_ANGLE_CIRCLE = $102;
  EOLANNOTATION_CIRCLE_FLAT = $110;
  EOLANNOTATION_FLATS = $111;
  EOLANNOTATION_ANGLE_FLAT = $112;
  EOLANNOTATION_CIRCLE_ANGLE = $120;
  EOLANNOTATION_FLAT_ANGLE = $121;
  EOLANNOTATION_ANGLES = $122;

  // SC_SUPPORTS_ enumeration
  SC_SUPPORTS_LINE_DRAWS_FINAL = 0;
  SC_SUPPORTS_PIXEL_DIVISIONS = 1;
  SC_SUPPORTS_FRACTIONAL_STROKE_WIDTH = 2;
  SC_SUPPORTS_TRANSLUCENT_STROKE = 3;
  SC_SUPPORTS_PIXEL_MODIFICATION = 4;
  SC_SUPPORTS_THREAD_SAFE_MEASURE_WIDTHS = 5;

  // SC_LINECHARACTERINDEX_ enumeration
  SC_LINECHARACTERINDEX_NONE = 0;
  SC_LINECHARACTERINDEX_UTF32 = 1;
  SC_LINECHARACTERINDEX_UTF16 = 2;
  /// <summary>
  /// Maximum value of keywordSet parameter of SetKeyWords.
  /// </summary>
  KEYWORDSET_MAX = 8;

  // SC_TYPE_ enumeration
  SC_TYPE_BOOLEAN = 0;
  SC_TYPE_INTEGER = 1;
  SC_TYPE_STRING = 2;

  // SC_MOD_ enumeration
  SC_MOD_NONE = $0;
  SC_MOD_INSERTTEXT = $1;
  SC_MOD_DELETETEXT = $2;
  SC_MOD_CHANGESTYLE = $4;
  SC_MOD_CHANGEFOLD = $8;

  // SC_PERFORMED_ enumeration
  SC_PERFORMED_USER = $10;
  SC_PERFORMED_UNDO = $20;
  SC_PERFORMED_REDO = $40;

  // SC_MULTISTEPUNDOREDO enumeration
  SC_MULTISTEPUNDOREDO = $80;

  // SC_LASTSTEPINUNDOREDO enumeration
  SC_LASTSTEPINUNDOREDO = $100;

  // SC_MOD_ enumeration
  SC_MOD_CHANGEMARKER = $200;
  SC_MOD_BEFOREINSERT = $400;
  SC_MOD_BEFOREDELETE = $800;

  // SC_MULTILINEUNDOREDO enumeration
  SC_MULTILINEUNDOREDO = $1000;

  // SC_STARTACTION enumeration
  SC_STARTACTION = $2000;

  // SC_MOD_ enumeration
  SC_MOD_CHANGEINDICATOR = $4000;
  SC_MOD_CHANGELINESTATE = $8000;
  SC_MOD_CHANGEMARGIN = $10000;
  SC_MOD_CHANGEANNOTATION = $20000;
  SC_MOD_CONTAINER = $40000;
  SC_MOD_LEXERSTATE = $80000;
  SC_MOD_INSERTCHECK = $100000;
  SC_MOD_CHANGETABSTOPS = $200000;
  SC_MOD_CHANGEEOLANNOTATION = $400000;

  // SC_MODEVENTMASKALL enumeration
  SC_MODEVENTMASKALL = $7FFFFF;

  // SC_UPDATE_ enumeration
  SC_UPDATE_NONE = $0;
  SC_UPDATE_CONTENT = $1;
  SC_UPDATE_SELECTION = $2;
  SC_UPDATE_V_SCROLL = $4;
  SC_UPDATE_H_SCROLL = $8;
  SCEN_CHANGE = 768;
  SCEN_SETFOCUS = 512;
  SCEN_KILLFOCUS = 256;

  // SCK_ enumeration
  SCK_DOWN = 300;
  SCK_UP = 301;
  SCK_LEFT = 302;
  SCK_RIGHT = 303;
  SCK_HOME = 304;
  SCK_END = 305;
  SCK_PRIOR = 306;
  SCK_NEXT = 307;
  SCK_DELETE = 308;
  SCK_INSERT = 309;
  SCK_ESCAPE = 7;
  SCK_BACK = 8;
  SCK_TAB = 9;
  SCK_RETURN = 13;
  SCK_ADD = 310;
  SCK_SUBTRACT = 311;
  SCK_DIVIDE = 312;
  SCK_WIN = 313;
  SCK_RWIN = 314;
  SCK_MENU = 315;

  // SCMOD_ enumeration
  SCMOD_NORM = 0;
  SCMOD_SHIFT = 1;
  SCMOD_CTRL = 2;
  SCMOD_ALT = 4;
  SCMOD_SUPER = 8;
  SCMOD_META = 16;

  // SC_AC_ enumeration
  SC_AC_FILLUP = 1;
  SC_AC_DOUBLECLICK = 2;
  SC_AC_TAB = 3;
  SC_AC_NEWLINE = 4;
  SC_AC_COMMAND = 5;
  SC_AC_SINGLE_CHOICE = 6;

  // SC_CHARACTERSOURCE_ enumeration
  /// <summary>
  /// Direct input characters.
  /// </summary>
  SC_CHARACTERSOURCE_DIRECT_INPUT = 0;
  /// <summary>
  /// IME (inline mode) or dead key tentative input characters.
  /// </summary>
  SC_CHARACTERSOURCE_TENTATIVE_INPUT = 1;
  /// <summary>
  /// IME (either inline or windowed mode) full composited string.
  /// </summary>
  SC_CHARACTERSOURCE_IME_RESULT = 2;

  // SC_BIDIRECTIONAL_ enumeration
  SC_BIDIRECTIONAL_DISABLED = 0;
  SC_BIDIRECTIONAL_L2R = 1;
  SC_BIDIRECTIONAL_R2L = 2;

  // Scintilla messages
  SCI_ADDTEXT = 2001;
  SCI_ADDSTYLEDTEXT = 2002;
  SCI_INSERTTEXT = 2003;
  SCI_CHANGEINSERTION = 2672;
  SCI_CLEARALL = 2004;
  SCI_DELETERANGE = 2645;
  SCI_CLEARDOCUMENTSTYLE = 2005;
  SCI_GETLENGTH = 2006;
  SCI_GETCHARAT = 2007;
  SCI_GETCURRENTPOS = 2008;
  SCI_GETANCHOR = 2009;
  SCI_GETSTYLEAT = 2010;
  SCI_GETSTYLEINDEXAT = 2038;
  SCI_REDO = 2011;
  SCI_SETUNDOCOLLECTION = 2012;
  SCI_SELECTALL = 2013;
  SCI_SETSAVEPOINT = 2014;
  SCI_GETSTYLEDTEXT = 2015;
  SCI_GETSTYLEDTEXTFULL = 2778;
  SCI_CANREDO = 2016;
  SCI_MARKERLINEFROMHANDLE = 2017;
  SCI_MARKERDELETEHANDLE = 2018;
  SCI_MARKERHANDLEFROMLINE = 2732;
  SCI_MARKERNUMBERFROMLINE = 2733;
  SCI_GETUNDOCOLLECTION = 2019;
  SCI_GETVIEWWS = 2020;
  SCI_SETVIEWWS = 2021;
  SCI_GETTABDRAWMODE = 2698;
  SCI_SETTABDRAWMODE = 2699;
  SCI_POSITIONFROMPOINT = 2022;
  SCI_POSITIONFROMPOINTCLOSE = 2023;
  SCI_GOTOLINE = 2024;
  SCI_GOTOPOS = 2025;
  SCI_SETANCHOR = 2026;
  SCI_GETCURLINE = 2027;
  SCI_GETENDSTYLED = 2028;
  SCI_CONVERTEOLS = 2029;
  SCI_GETEOLMODE = 2030;
  SCI_SETEOLMODE = 2031;
  SCI_STARTSTYLING = 2032;
  SCI_SETSTYLING = 2033;
  SCI_GETBUFFEREDDRAW = 2034;
  SCI_SETBUFFEREDDRAW = 2035;
  SCI_SETTABWIDTH = 2036;
  SCI_GETTABWIDTH = 2121;
  SCI_SETTABMINIMUMWIDTH = 2724;
  SCI_GETTABMINIMUMWIDTH = 2725;
  SCI_CLEARTABSTOPS = 2675;
  SCI_ADDTABSTOP = 2676;
  SCI_GETNEXTTABSTOP = 2677;
  SCI_SETCODEPAGE = 2037;
  SCI_SETFONTLOCALE = 2760;
  SCI_GETFONTLOCALE = 2761;
  SCI_GETIMEINTERACTION = 2678;
  SCI_SETIMEINTERACTION = 2679;
  SCI_MARKERDEFINE = 2040;
  SCI_MARKERSETFORE = 2041;
  SCI_MARKERSETBACK = 2042;
  SCI_MARKERSETBACKSELECTED = 2292;
  SCI_MARKERSETFORETRANSLUCENT = 2294;
  SCI_MARKERSETBACKTRANSLUCENT = 2295;
  SCI_MARKERSETBACKSELECTEDTRANSLUCENT = 2296;
  SCI_MARKERSETSTROKEWIDTH = 2297;
  SCI_MARKERENABLEHIGHLIGHT = 2293;
  SCI_MARKERADD = 2043;
  SCI_MARKERDELETE = 2044;
  SCI_MARKERDELETEALL = 2045;
  SCI_MARKERGET = 2046;
  SCI_MARKERNEXT = 2047;
  SCI_MARKERPREVIOUS = 2048;
  SCI_MARKERDEFINEPIXMAP = 2049;
  SCI_MARKERADDSET = 2466;
  SCI_MARKERSETALPHA = 2476;
  SCI_MARKERGETLAYER = 2734;
  SCI_MARKERSETLAYER = 2735;
  SCI_SETMARGINTYPEN = 2240;
  SCI_GETMARGINTYPEN = 2241;
  SCI_SETMARGINWIDTHN = 2242;
  SCI_GETMARGINWIDTHN = 2243;
  SCI_SETMARGINMASKN = 2244;
  SCI_GETMARGINMASKN = 2245;
  SCI_SETMARGINSENSITIVEN = 2246;
  SCI_GETMARGINSENSITIVEN = 2247;
  SCI_SETMARGINCURSORN = 2248;
  SCI_GETMARGINCURSORN = 2249;
  SCI_SETMARGINBACKN = 2250;
  SCI_GETMARGINBACKN = 2251;
  SCI_SETMARGINS = 2252;
  SCI_GETMARGINS = 2253;
  SCI_STYLECLEARALL = 2050;
  SCI_STYLESETFORE = 2051;
  SCI_STYLESETBACK = 2052;
  SCI_STYLESETBOLD = 2053;
  SCI_STYLESETITALIC = 2054;
  SCI_STYLESETSIZE = 2055;
  SCI_STYLESETFONT = 2056;
  SCI_STYLESETEOLFILLED = 2057;
  SCI_STYLERESETDEFAULT = 2058;
  SCI_STYLESETUNDERLINE = 2059;
  SCI_STYLEGETFORE = 2481;
  SCI_STYLEGETBACK = 2482;
  SCI_STYLEGETBOLD = 2483;
  SCI_STYLEGETITALIC = 2484;
  SCI_STYLEGETSIZE = 2485;
  SCI_STYLEGETFONT = 2486;
  SCI_STYLEGETEOLFILLED = 2487;
  SCI_STYLEGETUNDERLINE = 2488;
  SCI_STYLEGETCASE = 2489;
  SCI_STYLEGETCHARACTERSET = 2490;
  SCI_STYLEGETVISIBLE = 2491;
  SCI_STYLEGETCHANGEABLE = 2492;
  SCI_STYLEGETHOTSPOT = 2493;
  SCI_STYLESETCASE = 2060;
  SCI_STYLESETSIZEFRACTIONAL = 2061;
  SCI_STYLEGETSIZEFRACTIONAL = 2062;
  SCI_STYLESETWEIGHT = 2063;
  SCI_STYLEGETWEIGHT = 2064;
  SCI_STYLESETCHARACTERSET = 2066;
  SCI_STYLESETHOTSPOT = 2409;
  SCI_STYLESETCHECKMONOSPACED = 2254;
  SCI_STYLEGETCHECKMONOSPACED = 2255;
  SCI_STYLESETSTRETCH = 2258;
  SCI_STYLEGETSTRETCH = 2259;
  SCI_STYLESETINVISIBLEREPRESENTATION = 2256;
  SCI_STYLEGETINVISIBLEREPRESENTATION = 2257;
  SCI_SETELEMENTCOLOUR = 2753;
  SCI_GETELEMENTCOLOUR = 2754;
  SCI_RESETELEMENTCOLOUR = 2755;
  SCI_GETELEMENTISSET = 2756;
  SCI_GETELEMENTALLOWSTRANSLUCENT = 2757;
  SCI_GETELEMENTBASECOLOUR = 2758;
  SCI_SETSELFORE = 2067;
  SCI_SETSELBACK = 2068;
  SCI_GETSELALPHA = 2477;
  SCI_SETSELALPHA = 2478;
  SCI_GETSELEOLFILLED = 2479;
  SCI_SETSELEOLFILLED = 2480;
  SCI_GETSELECTIONLAYER = 2762;
  SCI_SETSELECTIONLAYER = 2763;
  SCI_GETCARETLINELAYER = 2764;
  SCI_SETCARETLINELAYER = 2765;
  SCI_GETCARETLINEHIGHLIGHTSUBLINE = 2773;
  SCI_SETCARETLINEHIGHLIGHTSUBLINE = 2774;
  SCI_SETCARETFORE = 2069;
  SCI_ASSIGNCMDKEY = 2070;
  SCI_CLEARCMDKEY = 2071;
  SCI_CLEARALLCMDKEYS = 2072;
  SCI_SETSTYLINGEX = 2073;
  SCI_STYLESETVISIBLE = 2074;
  SCI_GETCARETPERIOD = 2075;
  SCI_SETCARETPERIOD = 2076;
  SCI_SETWORDCHARS = 2077;
  SCI_GETWORDCHARS = 2646;
  SCI_SETCHARACTERCATEGORYOPTIMIZATION = 2720;
  SCI_GETCHARACTERCATEGORYOPTIMIZATION = 2721;
  SCI_BEGINUNDOACTION = 2078;
  SCI_ENDUNDOACTION = 2079;
  SCI_GETUNDOSEQUENCE = 2799;
  SCI_GETUNDOACTIONS = 2790;
  SCI_SETUNDOSAVEPOINT = 2791;
  SCI_GETUNDOSAVEPOINT = 2792;
  SCI_SETUNDODETACH = 2793;
  SCI_GETUNDODETACH = 2794;
  SCI_SETUNDOTENTATIVE = 2795;
  SCI_GETUNDOTENTATIVE = 2796;
  SCI_SETUNDOCURRENT = 2797;
  SCI_GETUNDOCURRENT = 2798;
  SCI_PUSHUNDOACTIONTYPE = 2800;
  SCI_CHANGELASTUNDOACTIONTEXT = 2801;
  SCI_GETUNDOACTIONTYPE = 2802;
  SCI_GETUNDOACTIONPOSITION = 2803;
  SCI_GETUNDOACTIONTEXT = 2804;
  SCI_INDICSETSTYLE = 2080;
  SCI_INDICGETSTYLE = 2081;
  SCI_INDICSETFORE = 2082;
  SCI_INDICGETFORE = 2083;
  SCI_INDICSETUNDER = 2510;
  SCI_INDICGETUNDER = 2511;
  SCI_INDICSETHOVERSTYLE = 2680;
  SCI_INDICGETHOVERSTYLE = 2681;
  SCI_INDICSETHOVERFORE = 2682;
  SCI_INDICGETHOVERFORE = 2683;
  SCI_INDICSETFLAGS = 2684;
  SCI_INDICGETFLAGS = 2685;
  SCI_INDICSETSTROKEWIDTH = 2751;
  SCI_INDICGETSTROKEWIDTH = 2752;
  SCI_SETWHITESPACEFORE = 2084;
  SCI_SETWHITESPACEBACK = 2085;
  SCI_SETWHITESPACESIZE = 2086;
  SCI_GETWHITESPACESIZE = 2087;
  SCI_SETLINESTATE = 2092;
  SCI_GETLINESTATE = 2093;
  SCI_GETMAXLINESTATE = 2094;
  SCI_GETCARETLINEVISIBLE = 2095;
  SCI_SETCARETLINEVISIBLE = 2096;
  SCI_GETCARETLINEBACK = 2097;
  SCI_SETCARETLINEBACK = 2098;
  SCI_GETCARETLINEFRAME = 2704;
  SCI_SETCARETLINEFRAME = 2705;
  SCI_STYLESETCHANGEABLE = 2099;
  SCI_AUTOCSHOW = 2100;
  SCI_AUTOCCANCEL = 2101;
  SCI_AUTOCACTIVE = 2102;
  SCI_AUTOCPOSSTART = 2103;
  SCI_AUTOCCOMPLETE = 2104;
  SCI_AUTOCSTOPS = 2105;
  SCI_AUTOCSETSEPARATOR = 2106;
  SCI_AUTOCGETSEPARATOR = 2107;
  SCI_AUTOCSELECT = 2108;
  SCI_AUTOCSETCANCELATSTART = 2110;
  SCI_AUTOCGETCANCELATSTART = 2111;
  SCI_AUTOCSETFILLUPS = 2112;
  SCI_AUTOCSETCHOOSESINGLE = 2113;
  SCI_AUTOCGETCHOOSESINGLE = 2114;
  SCI_AUTOCSETIGNORECASE = 2115;
  SCI_AUTOCGETIGNORECASE = 2116;
  SCI_USERLISTSHOW = 2117;
  SCI_AUTOCSETAUTOHIDE = 2118;
  SCI_AUTOCGETAUTOHIDE = 2119;
  SCI_AUTOCSETOPTIONS = 2638;
  SCI_AUTOCGETOPTIONS = 2639;
  SCI_AUTOCSETDROPRESTOFWORD = 2270;
  SCI_AUTOCGETDROPRESTOFWORD = 2271;
  SCI_REGISTERIMAGE = 2405;
  SCI_CLEARREGISTEREDIMAGES = 2408;
  SCI_AUTOCGETTYPESEPARATOR = 2285;
  SCI_AUTOCSETTYPESEPARATOR = 2286;
  SCI_AUTOCSETMAXWIDTH = 2208;
  SCI_AUTOCGETMAXWIDTH = 2209;
  SCI_AUTOCSETMAXHEIGHT = 2210;
  SCI_AUTOCGETMAXHEIGHT = 2211;
  SCI_AUTOCSETSTYLE = 2109;
  SCI_AUTOCGETSTYLE = 2120;
  SCI_SETINDENT = 2122;
  SCI_GETINDENT = 2123;
  SCI_SETUSETABS = 2124;
  SCI_GETUSETABS = 2125;
  SCI_SETLINEINDENTATION = 2126;
  SCI_GETLINEINDENTATION = 2127;
  SCI_GETLINEINDENTPOSITION = 2128;
  SCI_GETCOLUMN = 2129;
  SCI_COUNTCHARACTERS = 2633;
  SCI_COUNTCODEUNITS = 2715;
  SCI_SETHSCROLLBAR = 2130;
  SCI_GETHSCROLLBAR = 2131;
  SCI_SETINDENTATIONGUIDES = 2132;
  SCI_GETINDENTATIONGUIDES = 2133;
  SCI_SETHIGHLIGHTGUIDE = 2134;
  SCI_GETHIGHLIGHTGUIDE = 2135;
  SCI_GETLINEENDPOSITION = 2136;
  SCI_GETCODEPAGE = 2137;
  SCI_GETCARETFORE = 2138;
  SCI_GETREADONLY = 2140;
  SCI_SETCURRENTPOS = 2141;
  SCI_SETSELECTIONSTART = 2142;
  SCI_GETSELECTIONSTART = 2143;
  SCI_SETSELECTIONEND = 2144;
  SCI_GETSELECTIONEND = 2145;
  SCI_SETEMPTYSELECTION = 2556;
  SCI_SETPRINTMAGNIFICATION = 2146;
  SCI_GETPRINTMAGNIFICATION = 2147;
  SCI_SETPRINTCOLOURMODE = 2148;
  SCI_GETPRINTCOLOURMODE = 2149;
  SCI_FINDTEXT = 2150;
  SCI_FINDTEXTFULL = 2196;
  SCI_FORMATRANGE = 2151;
  SCI_FORMATRANGEFULL = 2777;
  SCI_SETCHANGEHISTORY = 2780;
  SCI_GETCHANGEHISTORY = 2781;
  SCI_SETUNDOSELECTIONHISTORY = 2782;
  SCI_GETUNDOSELECTIONHISTORY = 2783;
  SCI_SETSELECTIONSERIALIZED = 2784;
  SCI_GETSELECTIONSERIALIZED = 2785;
  SCI_GETFIRSTVISIBLELINE = 2152;
  SCI_GETLINE = 2153;
  SCI_GETLINECOUNT = 2154;
  SCI_ALLOCATELINES = 2089;
  SCI_SETMARGINLEFT = 2155;
  SCI_GETMARGINLEFT = 2156;
  SCI_SETMARGINRIGHT = 2157;
  SCI_GETMARGINRIGHT = 2158;
  SCI_GETMODIFY = 2159;
  SCI_SETSEL = 2160;
  SCI_GETSELTEXT = 2161;
  SCI_GETTEXTRANGE = 2162;
  SCI_GETTEXTRANGEFULL = 2039;
  SCI_HIDESELECTION = 2163;
  SCI_GETSELECTIONHIDDEN = 2088;
  SCI_POINTXFROMPOSITION = 2164;
  SCI_POINTYFROMPOSITION = 2165;
  SCI_LINEFROMPOSITION = 2166;
  SCI_POSITIONFROMLINE = 2167;
  SCI_LINESCROLL = 2168;
  SCI_SCROLLCARET = 2169;
  SCI_SCROLLRANGE = 2569;
  SCI_REPLACESEL = 2170;
  SCI_SETREADONLY = 2171;
  SCI_NULL = 2172;
  SCI_CANPASTE = 2173;
  SCI_CANUNDO = 2174;
  SCI_EMPTYUNDOBUFFER = 2175;
  SCI_UNDO = 2176;
  SCI_CUT = 2177;
  SCI_COPY = 2178;
  SCI_PASTE = 2179;
  SCI_CLEAR = 2180;
  SCI_SETTEXT = 2181;
  SCI_GETTEXT = 2182;
  SCI_GETTEXTLENGTH = 2183;
  SCI_GETDIRECTFUNCTION = 2184;
  SCI_GETDIRECTSTATUSFUNCTION = 2772;
  SCI_GETDIRECTPOINTER = 2185;
  SCI_SETOVERTYPE = 2186;
  SCI_GETOVERTYPE = 2187;
  SCI_SETCARETWIDTH = 2188;
  SCI_GETCARETWIDTH = 2189;
  SCI_SETTARGETSTART = 2190;
  SCI_GETTARGETSTART = 2191;
  SCI_SETTARGETSTARTVIRTUALSPACE = 2728;
  SCI_GETTARGETSTARTVIRTUALSPACE = 2729;
  SCI_SETTARGETEND = 2192;
  SCI_GETTARGETEND = 2193;
  SCI_SETTARGETENDVIRTUALSPACE = 2730;
  SCI_GETTARGETENDVIRTUALSPACE = 2731;
  SCI_SETTARGETRANGE = 2686;
  SCI_GETTARGETTEXT = 2687;
  SCI_TARGETFROMSELECTION = 2287;
  SCI_TARGETWHOLEDOCUMENT = 2690;
  SCI_REPLACETARGET = 2194;
  SCI_REPLACETARGETRE = 2195;
  SCI_REPLACETARGETMINIMAL = 2779;
  SCI_SEARCHINTARGET = 2197;
  SCI_SETSEARCHFLAGS = 2198;
  SCI_GETSEARCHFLAGS = 2199;
  SCI_CALLTIPSHOW = 2200;
  SCI_CALLTIPCANCEL = 2201;
  SCI_CALLTIPACTIVE = 2202;
  SCI_CALLTIPPOSSTART = 2203;
  SCI_CALLTIPSETPOSSTART = 2214;
  SCI_CALLTIPSETHLT = 2204;
  SCI_CALLTIPSETBACK = 2205;
  SCI_CALLTIPSETFORE = 2206;
  SCI_CALLTIPSETFOREHLT = 2207;
  SCI_CALLTIPUSESTYLE = 2212;
  SCI_CALLTIPSETPOSITION = 2213;
  SCI_VISIBLEFROMDOCLINE = 2220;
  SCI_DOCLINEFROMVISIBLE = 2221;
  SCI_WRAPCOUNT = 2235;
  SCI_SETFOLDLEVEL = 2222;
  SCI_GETFOLDLEVEL = 2223;
  SCI_GETLASTCHILD = 2224;
  SCI_GETFOLDPARENT = 2225;
  SCI_SHOWLINES = 2226;
  SCI_HIDELINES = 2227;
  SCI_GETLINEVISIBLE = 2228;
  SCI_GETALLLINESVISIBLE = 2236;
  SCI_SETFOLDEXPANDED = 2229;
  SCI_GETFOLDEXPANDED = 2230;
  SCI_TOGGLEFOLD = 2231;
  SCI_TOGGLEFOLDSHOWTEXT = 2700;
  SCI_FOLDDISPLAYTEXTSETSTYLE = 2701;
  SCI_FOLDDISPLAYTEXTGETSTYLE = 2707;
  SCI_SETDEFAULTFOLDDISPLAYTEXT = 2722;
  SCI_GETDEFAULTFOLDDISPLAYTEXT = 2723;
  SCI_FOLDLINE = 2237;
  SCI_FOLDCHILDREN = 2238;
  SCI_EXPANDCHILDREN = 2239;
  SCI_FOLDALL = 2662;
  SCI_ENSUREVISIBLE = 2232;
  SCI_SETAUTOMATICFOLD = 2663;
  SCI_GETAUTOMATICFOLD = 2664;
  SCI_SETFOLDFLAGS = 2233;
  SCI_ENSUREVISIBLEENFORCEPOLICY = 2234;
  SCI_SETTABINDENTS = 2260;
  SCI_GETTABINDENTS = 2261;
  SCI_SETBACKSPACEUNINDENTS = 2262;
  SCI_GETBACKSPACEUNINDENTS = 2263;
  SCI_SETMOUSEDWELLTIME = 2264;
  SCI_GETMOUSEDWELLTIME = 2265;
  SCI_WORDSTARTPOSITION = 2266;
  SCI_WORDENDPOSITION = 2267;
  SCI_ISRANGEWORD = 2691;
  SCI_SETIDLESTYLING = 2692;
  SCI_GETIDLESTYLING = 2693;
  SCI_SETWRAPMODE = 2268;
  SCI_GETWRAPMODE = 2269;
  SCI_SETWRAPVISUALFLAGS = 2460;
  SCI_GETWRAPVISUALFLAGS = 2461;
  SCI_SETWRAPVISUALFLAGSLOCATION = 2462;
  SCI_GETWRAPVISUALFLAGSLOCATION = 2463;
  SCI_SETWRAPSTARTINDENT = 2464;
  SCI_GETWRAPSTARTINDENT = 2465;
  SCI_SETWRAPINDENTMODE = 2472;
  SCI_GETWRAPINDENTMODE = 2473;
  SCI_SETLAYOUTCACHE = 2272;
  SCI_GETLAYOUTCACHE = 2273;
  SCI_SETSCROLLWIDTH = 2274;
  SCI_GETSCROLLWIDTH = 2275;
  SCI_SETSCROLLWIDTHTRACKING = 2516;
  SCI_GETSCROLLWIDTHTRACKING = 2517;
  SCI_TEXTWIDTH = 2276;
  SCI_SETENDATLASTLINE = 2277;
  SCI_GETENDATLASTLINE = 2278;
  SCI_TEXTHEIGHT = 2279;
  SCI_SETVSCROLLBAR = 2280;
  SCI_GETVSCROLLBAR = 2281;
  SCI_APPENDTEXT = 2282;
  SCI_GETPHASESDRAW = 2673;
  SCI_SETPHASESDRAW = 2674;
  SCI_SETFONTQUALITY = 2611;
  SCI_GETFONTQUALITY = 2612;
  SCI_SETFIRSTVISIBLELINE = 2613;
  SCI_SETMULTIPASTE = 2614;
  SCI_GETMULTIPASTE = 2615;
  SCI_GETTAG = 2616;
  SCI_LINESJOIN = 2288;
  SCI_LINESSPLIT = 2289;
  SCI_SETFOLDMARGINCOLOUR = 2290;
  SCI_SETFOLDMARGINHICOLOUR = 2291;
  SCI_SETACCESSIBILITY = 2702;
  SCI_GETACCESSIBILITY = 2703;
  SCI_LINEDOWN = 2300;
  SCI_LINEDOWNEXTEND = 2301;
  SCI_LINEUP = 2302;
  SCI_LINEUPEXTEND = 2303;
  SCI_CHARLEFT = 2304;
  SCI_CHARLEFTEXTEND = 2305;
  SCI_CHARRIGHT = 2306;
  SCI_CHARRIGHTEXTEND = 2307;
  SCI_WORDLEFT = 2308;
  SCI_WORDLEFTEXTEND = 2309;
  SCI_WORDRIGHT = 2310;
  SCI_WORDRIGHTEXTEND = 2311;
  SCI_HOME = 2312;
  SCI_HOMEEXTEND = 2313;
  SCI_LINEEND = 2314;
  SCI_LINEENDEXTEND = 2315;
  SCI_DOCUMENTSTART = 2316;
  SCI_DOCUMENTSTARTEXTEND = 2317;
  SCI_DOCUMENTEND = 2318;
  SCI_DOCUMENTENDEXTEND = 2319;
  SCI_PAGEUP = 2320;
  SCI_PAGEUPEXTEND = 2321;
  SCI_PAGEDOWN = 2322;
  SCI_PAGEDOWNEXTEND = 2323;
  SCI_EDITTOGGLEOVERTYPE = 2324;
  SCI_CANCEL = 2325;
  SCI_DELETEBACK = 2326;
  SCI_TAB = 2327;
  SCI_LINEINDENT = 2813;
  SCI_BACKTAB = 2328;
  SCI_LINEDEDENT = 2814;
  SCI_NEWLINE = 2329;
  SCI_FORMFEED = 2330;
  SCI_VCHOME = 2331;
  SCI_VCHOMEEXTEND = 2332;
  SCI_ZOOMIN = 2333;
  SCI_ZOOMOUT = 2334;
  SCI_DELWORDLEFT = 2335;
  SCI_DELWORDRIGHT = 2336;
  SCI_DELWORDRIGHTEND = 2518;
  SCI_LINECUT = 2337;
  SCI_LINEDELETE = 2338;
  SCI_LINETRANSPOSE = 2339;
  SCI_LINEREVERSE = 2354;
  SCI_LINEDUPLICATE = 2404;
  SCI_LOWERCASE = 2340;
  SCI_UPPERCASE = 2341;
  SCI_LINESCROLLDOWN = 2342;
  SCI_LINESCROLLUP = 2343;
  SCI_DELETEBACKNOTLINE = 2344;
  SCI_HOMEDISPLAY = 2345;
  SCI_HOMEDISPLAYEXTEND = 2346;
  SCI_LINEENDDISPLAY = 2347;
  SCI_LINEENDDISPLAYEXTEND = 2348;
  SCI_HOMEWRAP = 2349;
  SCI_HOMEWRAPEXTEND = 2450;
  SCI_LINEENDWRAP = 2451;
  SCI_LINEENDWRAPEXTEND = 2452;
  SCI_VCHOMEWRAP = 2453;
  SCI_VCHOMEWRAPEXTEND = 2454;
  SCI_LINECOPY = 2455;
  SCI_MOVECARETINSIDEVIEW = 2401;
  SCI_LINELENGTH = 2350;
  SCI_BRACEHIGHLIGHT = 2351;
  SCI_BRACEHIGHLIGHTINDICATOR = 2498;
  SCI_BRACEBADLIGHT = 2352;
  SCI_BRACEBADLIGHTINDICATOR = 2499;
  SCI_BRACEMATCH = 2353;
  SCI_BRACEMATCHNEXT = 2369;
  SCI_GETVIEWEOL = 2355;
  SCI_SETVIEWEOL = 2356;
  SCI_GETDOCPOINTER = 2357;
  SCI_SETDOCPOINTER = 2358;
  SCI_SETMODEVENTMASK = 2359;
  SCI_GETEDGECOLUMN = 2360;
  SCI_SETEDGECOLUMN = 2361;
  SCI_GETEDGEMODE = 2362;
  SCI_SETEDGEMODE = 2363;
  SCI_GETEDGECOLOUR = 2364;
  SCI_SETEDGECOLOUR = 2365;
  SCI_MULTIEDGEADDLINE = 2694;
  SCI_MULTIEDGECLEARALL = 2695;
  SCI_GETMULTIEDGECOLUMN = 2749;
  SCI_SEARCHANCHOR = 2366;
  SCI_SEARCHNEXT = 2367;
  SCI_SEARCHPREV = 2368;
  SCI_LINESONSCREEN = 2370;
  SCI_USEPOPUP = 2371;
  SCI_SELECTIONISRECTANGLE = 2372;
  SCI_SETZOOM = 2373;
  SCI_GETZOOM = 2374;
  SCI_CREATEDOCUMENT = 2375;
  SCI_ADDREFDOCUMENT = 2376;
  SCI_RELEASEDOCUMENT = 2377;
  SCI_GETDOCUMENTOPTIONS = 2379;
  SCI_GETMODEVENTMASK = 2378;
  SCI_SETCOMMANDEVENTS = 2717;
  SCI_GETCOMMANDEVENTS = 2718;
  SCI_SETFOCUS = 2380;
  SCI_GETFOCUS = 2381;
  SCI_SETSTATUS = 2382;
  SCI_GETSTATUS = 2383;
  SCI_SETMOUSEDOWNCAPTURES = 2384;
  SCI_GETMOUSEDOWNCAPTURES = 2385;
  SCI_SETMOUSEWHEELCAPTURES = 2696;
  SCI_GETMOUSEWHEELCAPTURES = 2697;
  SCI_SETCURSOR = 2386;
  SCI_GETCURSOR = 2387;
  SCI_SETCONTROLCHARSYMBOL = 2388;
  SCI_GETCONTROLCHARSYMBOL = 2389;
  SCI_WORDPARTLEFT = 2390;
  SCI_WORDPARTLEFTEXTEND = 2391;
  SCI_WORDPARTRIGHT = 2392;
  SCI_WORDPARTRIGHTEXTEND = 2393;
  SCI_SETVISIBLEPOLICY = 2394;
  SCI_DELLINELEFT = 2395;
  SCI_DELLINERIGHT = 2396;
  SCI_SETXOFFSET = 2397;
  SCI_GETXOFFSET = 2398;
  SCI_CHOOSECARETX = 2399;
  SCI_GRABFOCUS = 2400;
  SCI_SETXCARETPOLICY = 2402;
  SCI_SETYCARETPOLICY = 2403;
  SCI_SETPRINTWRAPMODE = 2406;
  SCI_GETPRINTWRAPMODE = 2407;
  SCI_SETHOTSPOTACTIVEFORE = 2410;
  SCI_GETHOTSPOTACTIVEFORE = 2494;
  SCI_SETHOTSPOTACTIVEBACK = 2411;
  SCI_GETHOTSPOTACTIVEBACK = 2495;
  SCI_SETHOTSPOTACTIVEUNDERLINE = 2412;
  SCI_GETHOTSPOTACTIVEUNDERLINE = 2496;
  SCI_SETHOTSPOTSINGLELINE = 2421;
  SCI_GETHOTSPOTSINGLELINE = 2497;
  SCI_PARADOWN = 2413;
  SCI_PARADOWNEXTEND = 2414;
  SCI_PARAUP = 2415;
  SCI_PARAUPEXTEND = 2416;
  SCI_POSITIONBEFORE = 2417;
  SCI_POSITIONAFTER = 2418;
  SCI_POSITIONRELATIVE = 2670;
  SCI_POSITIONRELATIVECODEUNITS = 2716;
  SCI_COPYRANGE = 2419;
  SCI_COPYTEXT = 2420;
  SCI_SETSELECTIONMODE = 2422;
  SCI_CHANGESELECTIONMODE = 2659;
  SCI_GETSELECTIONMODE = 2423;
  SCI_SETMOVEEXTENDSSELECTION = 2719;
  SCI_GETMOVEEXTENDSSELECTION = 2706;
  SCI_GETLINESELSTARTPOSITION = 2424;
  SCI_GETLINESELENDPOSITION = 2425;
  SCI_LINEDOWNRECTEXTEND = 2426;
  SCI_LINEUPRECTEXTEND = 2427;
  SCI_CHARLEFTRECTEXTEND = 2428;
  SCI_CHARRIGHTRECTEXTEND = 2429;
  SCI_HOMERECTEXTEND = 2430;
  SCI_VCHOMERECTEXTEND = 2431;
  SCI_LINEENDRECTEXTEND = 2432;
  SCI_PAGEUPRECTEXTEND = 2433;
  SCI_PAGEDOWNRECTEXTEND = 2434;
  SCI_STUTTEREDPAGEUP = 2435;
  SCI_STUTTEREDPAGEUPEXTEND = 2436;
  SCI_STUTTEREDPAGEDOWN = 2437;
  SCI_STUTTEREDPAGEDOWNEXTEND = 2438;
  SCI_WORDLEFTEND = 2439;
  SCI_WORDLEFTENDEXTEND = 2440;
  SCI_WORDRIGHTEND = 2441;
  SCI_WORDRIGHTENDEXTEND = 2442;
  SCI_SETWHITESPACECHARS = 2443;
  SCI_GETWHITESPACECHARS = 2647;
  SCI_SETPUNCTUATIONCHARS = 2648;
  SCI_GETPUNCTUATIONCHARS = 2649;
  SCI_SETCHARSDEFAULT = 2444;
  SCI_AUTOCGETCURRENT = 2445;
  SCI_AUTOCGETCURRENTTEXT = 2610;
  SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR = 2634;
  SCI_AUTOCGETCASEINSENSITIVEBEHAVIOUR = 2635;
  SCI_AUTOCSETMULTI = 2636;
  SCI_AUTOCGETMULTI = 2637;
  SCI_AUTOCSETORDER = 2660;
  SCI_AUTOCGETORDER = 2661;
  SCI_ALLOCATE = 2446;
  SCI_TARGETASUTF8 = 2447;
  SCI_SETLENGTHFORENCODE = 2448;
  SCI_ENCODEDFROMUTF8 = 2449;
  SCI_FINDCOLUMN = 2456;
  SCI_GETCARETSTICKY = 2457;
  SCI_SETCARETSTICKY = 2458;
  SCI_TOGGLECARETSTICKY = 2459;
  SCI_SETPASTECONVERTENDINGS = 2467;
  SCI_GETPASTECONVERTENDINGS = 2468;
  SCI_REPLACERECTANGULAR = 2771;
  SCI_SELECTIONDUPLICATE = 2469;
  SCI_SETCARETLINEBACKALPHA = 2470;
  SCI_GETCARETLINEBACKALPHA = 2471;
  SCI_SETCARETSTYLE = 2512;
  SCI_GETCARETSTYLE = 2513;
  SCI_SETINDICATORCURRENT = 2500;
  SCI_GETINDICATORCURRENT = 2501;
  SCI_SETINDICATORVALUE = 2502;
  SCI_GETINDICATORVALUE = 2503;
  SCI_INDICATORFILLRANGE = 2504;
  SCI_INDICATORCLEARRANGE = 2505;
  SCI_INDICATORALLONFOR = 2506;
  SCI_INDICATORVALUEAT = 2507;
  SCI_INDICATORSTART = 2508;
  SCI_INDICATOREND = 2509;
  SCI_SETPOSITIONCACHE = 2514;
  SCI_GETPOSITIONCACHE = 2515;
  SCI_SETLAYOUTTHREADS = 2775;
  SCI_GETLAYOUTTHREADS = 2776;
  SCI_COPYALLOWLINE = 2519;
  SCI_CUTALLOWLINE = 2810;
  SCI_SETCOPYSEPARATOR = 2811;
  SCI_GETCOPYSEPARATOR = 2812;
  SCI_GETCHARACTERPOINTER = 2520;
  SCI_GETRANGEPOINTER = 2643;
  SCI_GETGAPPOSITION = 2644;
  SCI_INDICSETALPHA = 2523;
  SCI_INDICGETALPHA = 2524;
  SCI_INDICSETOUTLINEALPHA = 2558;
  SCI_INDICGETOUTLINEALPHA = 2559;
  SCI_SETEXTRAASCENT = 2525;
  SCI_GETEXTRAASCENT = 2526;
  SCI_SETEXTRADESCENT = 2527;
  SCI_GETEXTRADESCENT = 2528;
  SCI_MARKERSYMBOLDEFINED = 2529;
  SCI_MARGINSETTEXT = 2530;
  SCI_MARGINGETTEXT = 2531;
  SCI_MARGINSETSTYLE = 2532;
  SCI_MARGINGETSTYLE = 2533;
  SCI_MARGINSETSTYLES = 2534;
  SCI_MARGINGETSTYLES = 2535;
  SCI_MARGINTEXTCLEARALL = 2536;
  SCI_MARGINSETSTYLEOFFSET = 2537;
  SCI_MARGINGETSTYLEOFFSET = 2538;
  SCI_SETMARGINOPTIONS = 2539;
  SCI_GETMARGINOPTIONS = 2557;
  SCI_ANNOTATIONSETTEXT = 2540;
  SCI_ANNOTATIONGETTEXT = 2541;
  SCI_ANNOTATIONSETSTYLE = 2542;
  SCI_ANNOTATIONGETSTYLE = 2543;
  SCI_ANNOTATIONSETSTYLES = 2544;
  SCI_ANNOTATIONGETSTYLES = 2545;
  SCI_ANNOTATIONGETLINES = 2546;
  SCI_ANNOTATIONCLEARALL = 2547;
  SCI_ANNOTATIONSETVISIBLE = 2548;
  SCI_ANNOTATIONGETVISIBLE = 2549;
  SCI_ANNOTATIONSETSTYLEOFFSET = 2550;
  SCI_ANNOTATIONGETSTYLEOFFSET = 2551;
  SCI_RELEASEALLEXTENDEDSTYLES = 2552;
  SCI_ALLOCATEEXTENDEDSTYLES = 2553;
  SCI_ADDUNDOACTION = 2560;
  SCI_CHARPOSITIONFROMPOINT = 2561;
  SCI_CHARPOSITIONFROMPOINTCLOSE = 2562;
  SCI_SETMOUSESELECTIONRECTANGULARSWITCH = 2668;
  SCI_GETMOUSESELECTIONRECTANGULARSWITCH = 2669;
  SCI_SETMULTIPLESELECTION = 2563;
  SCI_GETMULTIPLESELECTION = 2564;
  SCI_SETADDITIONALSELECTIONTYPING = 2565;
  SCI_GETADDITIONALSELECTIONTYPING = 2566;
  SCI_SETADDITIONALCARETSBLINK = 2567;
  SCI_GETADDITIONALCARETSBLINK = 2568;
  SCI_SETADDITIONALCARETSVISIBLE = 2608;
  SCI_GETADDITIONALCARETSVISIBLE = 2609;
  SCI_GETSELECTIONS = 2570;
  SCI_GETSELECTIONEMPTY = 2650;
  SCI_CLEARSELECTIONS = 2571;
  SCI_SETSELECTION = 2572;
  SCI_ADDSELECTION = 2573;
  SCI_SELECTIONFROMPOINT = 2474;
  SCI_DROPSELECTIONN = 2671;
  SCI_SETMAINSELECTION = 2574;
  SCI_GETMAINSELECTION = 2575;
  SCI_SETSELECTIONNCARET = 2576;
  SCI_GETSELECTIONNCARET = 2577;
  SCI_SETSELECTIONNANCHOR = 2578;
  SCI_GETSELECTIONNANCHOR = 2579;
  SCI_SETSELECTIONNCARETVIRTUALSPACE = 2580;
  SCI_GETSELECTIONNCARETVIRTUALSPACE = 2581;
  SCI_SETSELECTIONNANCHORVIRTUALSPACE = 2582;
  SCI_GETSELECTIONNANCHORVIRTUALSPACE = 2583;
  SCI_SETSELECTIONNSTART = 2584;
  SCI_GETSELECTIONNSTART = 2585;
  SCI_GETSELECTIONNSTARTVIRTUALSPACE = 2726;
  SCI_SETSELECTIONNEND = 2586;
  SCI_GETSELECTIONNENDVIRTUALSPACE = 2727;
  SCI_GETSELECTIONNEND = 2587;
  SCI_SETRECTANGULARSELECTIONCARET = 2588;
  SCI_GETRECTANGULARSELECTIONCARET = 2589;
  SCI_SETRECTANGULARSELECTIONANCHOR = 2590;
  SCI_GETRECTANGULARSELECTIONANCHOR = 2591;
  SCI_SETRECTANGULARSELECTIONCARETVIRTUALSPACE = 2592;
  SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE = 2593;
  SCI_SETRECTANGULARSELECTIONANCHORVIRTUALSPACE = 2594;
  SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE = 2595;
  SCI_SETVIRTUALSPACEOPTIONS = 2596;
  SCI_GETVIRTUALSPACEOPTIONS = 2597;
  SCI_SETRECTANGULARSELECTIONMODIFIER = 2598;
  SCI_GETRECTANGULARSELECTIONMODIFIER = 2599;
  SCI_SETADDITIONALSELFORE = 2600;
  SCI_SETADDITIONALSELBACK = 2601;
  SCI_SETADDITIONALSELALPHA = 2602;
  SCI_GETADDITIONALSELALPHA = 2603;
  SCI_SETADDITIONALCARETFORE = 2604;
  SCI_GETADDITIONALCARETFORE = 2605;
  SCI_ROTATESELECTION = 2606;
  SCI_SWAPMAINANCHORCARET = 2607;
  SCI_MULTIPLESELECTADDNEXT = 2688;
  SCI_MULTIPLESELECTADDEACH = 2689;
  SCI_CHANGELEXERSTATE = 2617;
  SCI_CONTRACTEDFOLDNEXT = 2618;
  SCI_VERTICALCENTRECARET = 2619;
  SCI_MOVESELECTEDLINESUP = 2620;
  SCI_MOVESELECTEDLINESDOWN = 2621;
  SCI_SETIDENTIFIER = 2622;
  SCI_GETIDENTIFIER = 2623;
  SCI_RGBAIMAGESETWIDTH = 2624;
  SCI_RGBAIMAGESETHEIGHT = 2625;
  SCI_RGBAIMAGESETSCALE = 2651;
  SCI_MARKERDEFINERGBAIMAGE = 2626;
  SCI_REGISTERRGBAIMAGE = 2627;
  SCI_SCROLLTOSTART = 2628;
  SCI_SCROLLTOEND = 2629;
  SCI_SETTECHNOLOGY = 2630;
  SCI_GETTECHNOLOGY = 2631;
  SCI_CREATELOADER = 2632;
  SCI_FINDINDICATORSHOW = 2640;
  SCI_FINDINDICATORFLASH = 2641;
  SCI_FINDINDICATORHIDE = 2642;
  SCI_VCHOMEDISPLAY = 2652;
  SCI_VCHOMEDISPLAYEXTEND = 2653;
  SCI_GETCARETLINEVISIBLEALWAYS = 2654;
  SCI_SETCARETLINEVISIBLEALWAYS = 2655;
  SCI_SETLINEENDTYPESALLOWED = 2656;
  SCI_GETLINEENDTYPESALLOWED = 2657;
  SCI_GETLINEENDTYPESACTIVE = 2658;
  SCI_SETREPRESENTATION = 2665;
  SCI_GETREPRESENTATION = 2666;
  SCI_CLEARREPRESENTATION = 2667;
  SCI_CLEARALLREPRESENTATIONS = 2770;
  SCI_SETREPRESENTATIONAPPEARANCE = 2766;
  SCI_GETREPRESENTATIONAPPEARANCE = 2767;
  SCI_SETREPRESENTATIONCOLOUR = 2768;
  SCI_GETREPRESENTATIONCOLOUR = 2769;
  SCI_EOLANNOTATIONSETTEXT = 2740;
  SCI_EOLANNOTATIONGETTEXT = 2741;
  SCI_EOLANNOTATIONSETSTYLE = 2742;
  SCI_EOLANNOTATIONGETSTYLE = 2743;
  SCI_EOLANNOTATIONCLEARALL = 2744;
  SCI_EOLANNOTATIONSETVISIBLE = 2745;
  SCI_EOLANNOTATIONGETVISIBLE = 2746;
  SCI_EOLANNOTATIONSETSTYLEOFFSET = 2747;
  SCI_EOLANNOTATIONGETSTYLEOFFSET = 2748;
  SCI_SUPPORTSFEATURE = 2750;
  SCI_GETLINECHARACTERINDEX = 2710;
  SCI_ALLOCATELINECHARACTERINDEX = 2711;
  SCI_RELEASELINECHARACTERINDEX = 2712;
  SCI_LINEFROMINDEXPOSITION = 2713;
  SCI_INDEXPOSITIONFROMLINE = 2714;
  SCI_STARTRECORD = 3001;
  SCI_STOPRECORD = 3002;
  SCI_GETLEXER = 4002;
  SCI_COLOURISE = 4003;
  SCI_SETPROPERTY = 4004;
  SCI_SETKEYWORDS = 4005;
  SCI_GETPROPERTY = 4008;
  SCI_GETPROPERTYEXPANDED = 4009;
  SCI_GETPROPERTYINT = 4010;
  SCI_GETLEXERLANGUAGE = 4012;
  SCI_PRIVATELEXERCALL = 4013;
  SCI_PROPERTYNAMES = 4014;
  SCI_PROPERTYTYPE = 4015;
  SCI_DESCRIBEPROPERTY = 4016;
  SCI_DESCRIBEKEYWORDSETS = 4017;
  SCI_GETLINEENDTYPESSUPPORTED = 4018;
  SCI_ALLOCATESUBSTYLES = 4020;
  SCI_GETSUBSTYLESSTART = 4021;
  SCI_GETSUBSTYLESLENGTH = 4022;
  SCI_GETSTYLEFROMSUBSTYLE = 4027;
  SCI_GETPRIMARYSTYLEFROMSTYLE = 4028;
  SCI_FREESUBSTYLES = 4023;
  SCI_SETIDENTIFIERS = 4024;
  SCI_DISTANCETOSECONDARYSTYLES = 4025;
  SCI_GETSUBSTYLEBASES = 4026;
  SCI_GETNAMEDSTYLES = 4029;
  SCI_NAMEOFSTYLE = 4030;
  SCI_TAGSOFSTYLE = 4031;
  SCI_DESCRIPTIONOFSTYLE = 4032;
  SCI_SETILEXER = 4033;
  SCI_GETBIDIRECTIONAL = 2708;
  SCI_SETBIDIRECTIONAL = 2709;

  // Scintilla notifications
  SCN_STYLENEEDED = 2000;
  SCN_CHARADDED = 2001;
  SCN_SAVEPOINTREACHED = 2002;
  SCN_SAVEPOINTLEFT = 2003;
  SCN_MODIFYATTEMPTRO = 2004;
  SCN_KEY = 2005;
  SCN_DOUBLECLICK = 2006;
  SCN_UPDATEUI = 2007;
  SCN_MODIFIED = 2008;
  SCN_MACRORECORD = 2009;
  SCN_MARGINCLICK = 2010;
  SCN_NEEDSHOWN = 2011;
  SCN_PAINTED = 2013;
  SCN_USERLISTSELECTION = 2014;
  SCN_URIDROPPED = 2015;
  SCN_DWELLSTART = 2016;
  SCN_DWELLEND = 2017;
  SCN_ZOOM = 2018;
  SCN_HOTSPOTCLICK = 2019;
  SCN_HOTSPOTDOUBLECLICK = 2020;
  SCN_CALLTIPCLICK = 2021;
  SCN_AUTOCSELECTION = 2022;
  SCN_INDICATORCLICK = 2023;
  SCN_INDICATORRELEASE = 2024;
  SCN_AUTOCCANCELLED = 2025;
  SCN_AUTOCCHARDELETED = 2026;
  SCN_HOTSPOTRELEASECLICK = 2027;
  SCN_FOCUSIN = 2028;
  SCN_FOCUSOUT = 2029;
  SCN_AUTOCCOMPLETED = 2030;
  SCN_MARGINRIGHTCLICK = 2031;
  SCN_AUTOCSELECTIONCHANGE = 2032;

type
  TSciPosition = Integer;
  TSciLine = Integer;
  TColorAlpha = Cardinal;

  PTextRange = ^TTextRange;
  TTextRange = record
    chrg: TCharRange;
    lpstrText: PAnsiChar;
  end;

  PTextRangeFull = ^TTextRangeFull;
  TTextRangeFull = record
    cpMin: Int64;
    cpMax: Int64;
    lpstrText: PAnsiChar;
  end;

  PFindText = ^TFindText;
  TFindText = record
    chrg: TCharRange;
    lpstrText: PAnsiChar;
    chrgText: TCharRange;
  end;

  PFindTextFull = ^TFindTextFull;
  TFindTextFull = record
    cpMin: Int64;
    cpMax: Int64;
    lpstrText: PAnsiChar;
    cpMinText: Int64;
    cpMaxText: Int64;
  end;

  TScintilla = class(TWinControl)
  private
    FDirectPtr: Pointer;
    FDirectFunction: Pointer;
  protected
    procedure CreateWnd; override;
    procedure DestroyWnd; override;
    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    // Basics
    /// <summary>
    /// Add text to the document at current position.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure AddText(length: Integer; text: PAnsiChar);
    /// <summary>
    /// Add array of cells to document.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="c">
    /// The c parameter
    /// </param>
    procedure AddStyledText(length: Integer; c: PAnsiChar);
    /// <summary>
    /// Insert string at a position.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure InsertText(pos: Integer; text: PAnsiChar);
    /// <summary>
    /// Change the text that is being inserted in response to SC_MOD_INSERTCHECK
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure ChangeInsertion(length: Integer; text: PAnsiChar);
    /// <summary>
    /// Delete all text in the document.
    /// </summary>
    procedure ClearAll();
    /// <summary>
    /// Delete a range of text in the document.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="lengthDelete">
    /// Position in the document
    /// </param>
    procedure DeleteRange(start: Integer; lengthDelete: Integer);
    /// <summary>
    /// Set all style bytes to 0, remove all folding information.
    /// </summary>
    procedure ClearDocumentStyle();
    /// <summary>
    /// Returns the number of bytes in the document.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetLength(): Integer;
    /// <summary>
    /// Returns the character byte at the position.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetCharAt(pos: Integer): Integer;
    /// <summary>
    /// Returns the position of the caret.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetCurrentPos(): Integer;
    /// <summary>
    /// Returns the position of the opposite end of the selection to the caret.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetAnchor(): Integer;
    /// <summary>
    /// Returns the style byte at the position.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetStyleAt(pos: Integer): Integer;
    /// <summary>
    /// Returns the unsigned style byte at the position.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetStyleIndexAt(pos: Integer): Integer;
    /// <summary>
    /// Redoes the next action on the undo history.
    /// </summary>
    procedure Redo();
    /// <summary>
    /// Choose between collecting actions into the undo
    /// history and discarding them.
    /// </summary>
    /// <param name="collectUndo">
    /// Boolean value
    /// </param>
    procedure SetUndoCollection(collectUndo: Boolean);
    /// <summary>
    /// Select all the text in the document.
    /// </summary>
    procedure SelectAll();
    /// <summary>
    /// Remember the current position in the undo history as the position
    /// at which the document was saved.
    /// </summary>
    procedure SetSavePoint();
    /// <summary>
    /// Retrieve a buffer of cells.
    /// Returns the number of bytes in the buffer not including terminating NULs.
    /// </summary>
    /// <param name="tr">
    /// The tr parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetStyledText(tr: PTextRange): Integer;
    /// <summary>
    /// Retrieve a buffer of cells that can be past 2GB.
    /// Returns the number of bytes in the buffer not including terminating NULs.
    /// </summary>
    /// <param name="tr">
    /// The tr parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetStyledTextFull(tr: PTextRangeFull): Integer;
    /// <summary>
    /// Are there any redoable actions in the undo history?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function CanRedo(): Boolean;
    /// <summary>
    /// Retrieve the line number at which a particular marker is located.
    /// </summary>
    /// <param name="markerHandle">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function MarkerLineFromHandle(markerHandle: Integer): Integer;
    /// <summary>
    /// Delete a marker.
    /// </summary>
    /// <param name="markerHandle">
    /// Integer value
    /// </param>
    procedure MarkerDeleteHandle(markerHandle: Integer);
    /// <summary>
    /// Retrieve marker handles of a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="which">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarkerHandleFromLine(line: Integer; which: Integer): Integer;
    /// <summary>
    /// Retrieve marker number of a marker handle
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="which">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarkerNumberFromLine(line: Integer; which: Integer): Integer;
    /// <summary>
    /// Is undo history being collected?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetUndoCollection(): Boolean;
    /// <summary>
    /// Are white space characters currently visible?
    /// Returns one of SCWS_* constants.
    /// </summary>
    /// <returns>
    /// Returns the viewws
    /// </returns>
    function GetViewWS(): Integer;
    /// <summary>
    /// Make white space characters invisible, always visible or visible outside indentation.
    /// </summary>
    /// <param name="viewWS">
    /// The viewWS parameter
    /// </param>
    procedure SetViewWS(viewWS: Integer);
    /// <summary>
    /// Retrieve the current tab draw mode.
    /// Returns one of SCTD_* constants.
    /// </summary>
    /// <returns>
    /// Returns the tabdrawmode
    /// </returns>
    function GetTabDrawMode(): Integer;
    /// <summary>
    /// Set how tabs are drawn when visible.
    /// </summary>
    /// <param name="tabDrawMode">
    /// The tabDrawMode parameter
    /// </param>
    procedure SetTabDrawMode(tabDrawMode: Integer);
    /// <summary>
    /// Find the position from a point within the window.
    /// </summary>
    /// <param name="x">
    /// Integer value
    /// </param>
    /// <param name="y">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function PositionFromPoint(x: Integer; y: Integer): Integer;
    /// <summary>
    /// Find the position from a point within the window but return
    /// INVALID_POSITION if not close to text.
    /// </summary>
    /// <param name="x">
    /// Integer value
    /// </param>
    /// <param name="y">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function PositionFromPointClose(x: Integer; y: Integer): Integer;
    /// <summary>
    /// Set caret to start of a line and ensure it is visible.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    procedure GotoLine(line: Integer);
    /// <summary>
    /// Set caret to a position and ensure it is visible.
    /// </summary>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure GotoPos(caret: Integer);
    /// <summary>
    /// Set the selection anchor to a position. The anchor is the opposite
    /// end of the selection from the caret.
    /// </summary>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    procedure SetAnchor(anchor: Integer);
    /// <summary>
    /// Retrieve the text of the line containing the caret.
    /// Returns the index of the caret on the line.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetCurLine(length: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve the position of the last correctly styled character.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetEndStyled(): Integer;
    /// <summary>
    /// Convert all line endings in the document to one mode.
    /// </summary>
    /// <param name="eolMode">
    /// The eolMode parameter
    /// </param>
    procedure ConvertEOLs(eolMode: Integer);
    /// <summary>
    /// Retrieve the current end of line mode - one of CRLF, CR, or LF.
    /// </summary>
    /// <returns>
    /// Returns the eolmode
    /// </returns>
    function GetEOLMode(): Integer;
    /// <summary>
    /// Set the current end of line mode.
    /// </summary>
    /// <param name="eolMode">
    /// The eolMode parameter
    /// </param>
    procedure SetEOLMode(eolMode: Integer);
    /// <summary>
    /// Set the current styling position to start.
    /// The unused parameter is no longer used and should be set to 0.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="unused">
    /// Integer value
    /// </param>
    procedure StartStyling(start: Integer; unused: Integer);
    /// <summary>
    /// Change style from current styling position for length characters to a style
    /// and move the current styling position to after this newly styled segment.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure SetStyling(length: Integer; style: Integer);
    /// <summary>
    /// Is drawing done first into a buffer or direct to the screen?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetBufferedDraw(): Boolean;
    /// <summary>
    /// If drawing is buffered then each line of text is drawn into a bitmap buffer
    /// before drawing it to the screen to avoid flicker.
    /// </summary>
    /// <param name="buffered">
    /// Boolean value
    /// </param>
    procedure SetBufferedDraw(buffered: Boolean);
    /// <summary>
    /// Change the visible size of a tab to be a multiple of the width of a space character.
    /// </summary>
    /// <param name="tabWidth">
    /// Integer value
    /// </param>
    procedure SetTabWidth(tabWidth: Integer);
    /// <summary>
    /// Retrieve the visible size of a tab.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetTabWidth(): Integer;
    /// <summary>
    /// Set the minimum visual width of a tab.
    /// </summary>
    /// <param name="pixels">
    /// Integer value
    /// </param>
    procedure SetTabMinimumWidth(pixels: Integer);
    /// <summary>
    /// Get the minimum visual width of a tab.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetTabMinimumWidth(): Integer;
    /// <summary>
    /// Clear explicit tabstops on a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    procedure ClearTabStops(line: Integer);
    /// <summary>
    /// Add an explicit tab stop for a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="x">
    /// Integer value
    /// </param>
    procedure AddTabStop(line: Integer; x: Integer);
    /// <summary>
    /// Find the next explicit tab stop position on a line after a position.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="x">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetNextTabStop(line: Integer; x: Integer): Integer;
    /// <summary>
    /// Set the code page used to interpret the bytes of the document as characters.
    /// The SC_CP_UTF8 value can be used to enter Unicode mode.
    /// </summary>
    /// <param name="codePage">
    /// Integer value
    /// </param>
    procedure SetCodePage(codePage: Integer);
    /// <summary>
    /// Set the locale for displaying text.
    /// </summary>
    /// <param name="localeName">
    /// Text string
    /// </param>
    procedure SetFontLocale(localeName: PAnsiChar);
    /// <summary>
    /// Get the locale for displaying text.
    /// </summary>
    /// <param name="localeName">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetFontLocale(localeName: PAnsiChar): Integer;
    /// <summary>
    /// Is the IME displayed in a window or inline?
    /// </summary>
    /// <returns>
    /// Returns the imeinteraction
    /// </returns>
    function GetIMEInteraction(): Integer;
    /// <summary>
    /// Choose to display the IME in a window or inline.
    /// </summary>
    /// <param name="imeInteraction">
    /// The imeInteraction parameter
    /// </param>
    procedure SetIMEInteraction(imeInteraction: Integer);
    /// <summary>
    /// Set the symbol used for a particular marker number.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="markerSymbol">
    /// The markerSymbol parameter
    /// </param>
    procedure MarkerDefine(markerNumber: Integer; markerSymbol: Integer);
    /// <summary>
    /// Set the foreground colour used for a particular marker number.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure MarkerSetFore(markerNumber: Integer; fore: TColor);
    /// <summary>
    /// Set the background colour used for a particular marker number.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure MarkerSetBack(markerNumber: Integer; back: TColor);
    /// <summary>
    /// Set the background colour used for a particular marker number when its folding block is selected.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure MarkerSetBackSelected(markerNumber: Integer; back: TColor);
    /// <summary>
    /// Set the foreground colour used for a particular marker number.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="fore">
    /// The fore parameter
    /// </param>
    procedure MarkerSetForeTranslucent(markerNumber: Integer; fore: TColorAlpha);
    /// <summary>
    /// Set the background colour used for a particular marker number.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="back">
    /// The back parameter
    /// </param>
    procedure MarkerSetBackTranslucent(markerNumber: Integer; back: TColorAlpha);
    /// <summary>
    /// Set the background colour used for a particular marker number when its folding block is selected.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="back">
    /// The back parameter
    /// </param>
    procedure MarkerSetBackSelectedTranslucent(markerNumber: Integer; back: TColorAlpha);
    /// <summary>
    /// Set the width of strokes used in .01 pixels so 50  = 1/2 pixel width.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="hundredths">
    /// Integer value
    /// </param>
    procedure MarkerSetStrokeWidth(markerNumber: Integer; hundredths: Integer);
    /// <summary>
    /// Enable/disable highlight for current folding block (smallest one that contains the caret)
    /// </summary>
    /// <param name="enabled">
    /// Boolean value
    /// </param>
    procedure MarkerEnableHighlight(enabled: Boolean);
    /// <summary>
    /// Add a marker to a line, returning an ID which can be used to find or delete the marker.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarkerAdd(line: Integer; markerNumber: Integer): Integer;
    /// <summary>
    /// Delete a marker from a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    procedure MarkerDelete(line: Integer; markerNumber: Integer);
    /// <summary>
    /// Delete all markers with a particular number from all lines.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    procedure MarkerDeleteAll(markerNumber: Integer);
    /// <summary>
    /// Get a bit mask of all the markers set on a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarkerGet(line: Integer): Integer;
    /// <summary>
    /// Find the next line at or after lineStart that includes a marker in mask.
    /// Return -1 when no more lines.
    /// </summary>
    /// <param name="lineStart">
    /// Line number
    /// </param>
    /// <param name="markerMask">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function MarkerNext(lineStart: Integer; markerMask: Integer): Integer;
    /// <summary>
    /// Find the previous line before lineStart that includes a marker in mask.
    /// </summary>
    /// <param name="lineStart">
    /// Line number
    /// </param>
    /// <param name="markerMask">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function MarkerPrevious(lineStart: Integer; markerMask: Integer): Integer;
    /// <summary>
    /// Define a marker from a pixmap.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="pixmap">
    /// Text string
    /// </param>
    procedure MarkerDefinePixmap(markerNumber: Integer; pixmap: PAnsiChar);
    /// <summary>
    /// Add a set of markers to a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="markerSet">
    /// Integer value
    /// </param>
    procedure MarkerAddSet(line: Integer; markerSet: Integer);
    /// <summary>
    /// Set the alpha used for a marker that is drawn in the text area, not the margin.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="alpha">
    /// The alpha parameter
    /// </param>
    procedure MarkerSetAlpha(markerNumber: Integer; alpha: Integer);
    /// <summary>
    /// Get the layer used for a marker that is drawn in the text area, not the margin.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function MarkerGetLayer(markerNumber: Integer): Integer;
    /// <summary>
    /// Set the layer used for a marker that is drawn in the text area, not the margin.
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="layer">
    /// The layer parameter
    /// </param>
    procedure MarkerSetLayer(markerNumber: Integer; layer: Integer);
    /// <summary>
    /// Set a margin to be either numeric or symbolic.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <param name="marginType">
    /// The marginType parameter
    /// </param>
    procedure SetMarginTypeN(margin: Integer; marginType: Integer);
    /// <summary>
    /// Retrieve the type of a margin.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the margintypen
    /// </returns>
    function GetMarginTypeN(margin: Integer): Integer;
    /// <summary>
    /// Set the width of a margin to a width expressed in pixels.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <param name="pixelWidth">
    /// Integer value
    /// </param>
    procedure SetMarginWidthN(margin: Integer; pixelWidth: Integer);
    /// <summary>
    /// Retrieve the width of a margin in pixels.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMarginWidthN(margin: Integer): Integer;
    /// <summary>
    /// Set a mask that determines which markers are displayed in a margin.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <param name="mask">
    /// Integer value
    /// </param>
    procedure SetMarginMaskN(margin: Integer; mask: Integer);
    /// <summary>
    /// Retrieve the marker mask of a margin.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMarginMaskN(margin: Integer): Integer;
    /// <summary>
    /// Make a margin sensitive or insensitive to mouse clicks.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <param name="sensitive">
    /// Boolean value
    /// </param>
    procedure SetMarginSensitiveN(margin: Integer; sensitive: Boolean);
    /// <summary>
    /// Retrieve the mouse click sensitivity of a margin.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetMarginSensitiveN(margin: Integer): Boolean;
    /// <summary>
    /// Set the cursor shown when the mouse is inside a margin.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <param name="cursor">
    /// The cursor parameter
    /// </param>
    procedure SetMarginCursorN(margin: Integer; cursor: Integer);
    /// <summary>
    /// Retrieve the cursor shown in a margin.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the margincursorn
    /// </returns>
    function GetMarginCursorN(margin: Integer): Integer;
    /// <summary>
    /// Set the background colour of a margin. Only visible for SC_MARGIN_COLOUR.
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure SetMarginBackN(margin: Integer; back: TColor);
    /// <summary>
    /// Retrieve the background colour of a margin
    /// </summary>
    /// <param name="margin">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function GetMarginBackN(margin: Integer): TColor;
    /// <summary>
    /// Allocate a non-standard number of margins.
    /// </summary>
    /// <param name="margins">
    /// Integer value
    /// </param>
    procedure SetMargins(margins: Integer);
    /// <summary>
    /// How many margins are there?.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMargins(): Integer;
    /// <summary>
    /// Clear all the styles and make equivalent to the global default style.
    /// </summary>
    procedure StyleClearAll();
    /// <summary>
    /// Set the foreground colour of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure StyleSetFore(style: Integer; fore: TColor);
    /// <summary>
    /// Set the background colour of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure StyleSetBack(style: Integer; back: TColor);
    /// <summary>
    /// Set a style to be bold or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="bold">
    /// Boolean value
    /// </param>
    procedure StyleSetBold(style: Integer; bold: Boolean);
    /// <summary>
    /// Set a style to be italic or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="italic">
    /// Boolean value
    /// </param>
    procedure StyleSetItalic(style: Integer; italic: Boolean);
    /// <summary>
    /// Set the size of characters of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="sizePoints">
    /// Integer value
    /// </param>
    procedure StyleSetSize(style: Integer; sizePoints: Integer);
    /// <summary>
    /// Set the font of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="fontName">
    /// Text string
    /// </param>
    procedure StyleSetFont(style: Integer; fontName: PAnsiChar);
    /// <summary>
    /// Set a style to have its end of line filled or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="eolFilled">
    /// Boolean value
    /// </param>
    procedure StyleSetEOLFilled(style: Integer; eolFilled: Boolean);
    /// <summary>
    /// Reset the default style to its state at startup
    /// </summary>
    procedure StyleResetDefault();
    /// <summary>
    /// Set a style to be underlined or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="underline">
    /// Boolean value
    /// </param>
    procedure StyleSetUnderline(style: Integer; underline: Boolean);
    /// <summary>
    /// Get the foreground colour of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function StyleGetFore(style: Integer): TColor;
    /// <summary>
    /// Get the background colour of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function StyleGetBack(style: Integer): TColor;
    /// <summary>
    /// Get is a style bold or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetBold(style: Integer): Boolean;
    /// <summary>
    /// Get is a style italic or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetItalic(style: Integer): Boolean;
    /// <summary>
    /// Get the size of characters of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function StyleGetSize(style: Integer): Integer;
    /// <summary>
    /// Get the font of a style.
    /// Returns the length of the fontName
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="fontName">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function StyleGetFont(style: Integer; fontName: PAnsiChar): Integer;
    /// <summary>
    /// Get is a style to have its end of line filled or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetEOLFilled(style: Integer): Boolean;
    /// <summary>
    /// Get is a style underlined or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetUnderline(style: Integer): Boolean;
    /// <summary>
    /// Get is a style mixed case, or to force upper or lower case.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function StyleGetCase(style: Integer): Integer;
    /// <summary>
    /// Get the character get of the font in a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function StyleGetCharacterSet(style: Integer): Integer;
    /// <summary>
    /// Get is a style visible or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetVisible(style: Integer): Boolean;
    /// <summary>
    /// Get is a style changeable or not (read only).
    /// Experimental feature, currently buggy.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetChangeable(style: Integer): Boolean;
    /// <summary>
    /// Get is a style a hotspot or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetHotSpot(style: Integer): Boolean;
    /// <summary>
    /// Set a style to be mixed case, or to force upper or lower case.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="caseVisible">
    /// The caseVisible parameter
    /// </param>
    procedure StyleSetCase(style: Integer; caseVisible: Integer);
    /// <summary>
    /// Set the size of characters of a style. Size is in points multiplied by 100.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="sizeHundredthPoints">
    /// Integer value
    /// </param>
    procedure StyleSetSizeFractional(style: Integer; sizeHundredthPoints: Integer);
    /// <summary>
    /// Get the size of characters of a style in points multiplied by 100
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function StyleGetSizeFractional(style: Integer): Integer;
    /// <summary>
    /// Set the weight of characters of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="weight">
    /// The weight parameter
    /// </param>
    procedure StyleSetWeight(style: Integer; weight: Integer);
    /// <summary>
    /// Get the weight of characters of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function StyleGetWeight(style: Integer): Integer;
    /// <summary>
    /// Set the character set of the font in a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="characterSet">
    /// The characterSet parameter
    /// </param>
    procedure StyleSetCharacterSet(style: Integer; characterSet: Integer);
    /// <summary>
    /// Set a style to be a hotspot or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="hotspot">
    /// Boolean value
    /// </param>
    procedure StyleSetHotSpot(style: Integer; hotspot: Boolean);
    /// <summary>
    /// Indicate that a style may be monospaced over ASCII graphics characters which enables optimizations.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="checkMonospaced">
    /// Boolean value
    /// </param>
    procedure StyleSetCheckMonospaced(style: Integer; checkMonospaced: Boolean);
    /// <summary>
    /// Get whether a style may be monospaced.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function StyleGetCheckMonospaced(style: Integer): Boolean;
    /// <summary>
    /// Set the stretch of characters of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="stretch">
    /// The stretch parameter
    /// </param>
    procedure StyleSetStretch(style: Integer; stretch: Integer);
    /// <summary>
    /// Get the stretch of characters of a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function StyleGetStretch(style: Integer): Integer;
    /// <summary>
    /// Set the invisible representation for a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="representation">
    /// Text string
    /// </param>
    procedure StyleSetInvisibleRepresentation(style: Integer; representation: PAnsiChar);
    /// <summary>
    /// Get the invisible representation for a style.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="representation">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function StyleGetInvisibleRepresentation(style: Integer; representation: PAnsiChar): Integer;
    /// <summary>
    /// Set the colour of an element. Translucency (alpha) may or may not be significant
    /// and this may depend on the platform. The alpha byte should commonly be 0xff for opaque.
    /// </summary>
    /// <param name="element">
    /// The element parameter
    /// </param>
    /// <param name="colourElement">
    /// The colourElement parameter
    /// </param>
    procedure SetElementColour(element: Integer; colourElement: TColorAlpha);
    /// <summary>
    /// Get the colour of an element.
    /// </summary>
    /// <param name="element">
    /// The element parameter
    /// </param>
    /// <returns>
    /// Returns the elementcolour
    /// </returns>
    function GetElementColour(element: Integer): TColorAlpha;
    /// <summary>
    /// Use the default or platform-defined colour for an element.
    /// </summary>
    /// <param name="element">
    /// The element parameter
    /// </param>
    procedure ResetElementColour(element: Integer);
    /// <summary>
    /// Get whether an element has been set by SetElementColour.
    /// When false, a platform-defined or default colour is used.
    /// </summary>
    /// <param name="element">
    /// The element parameter
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetElementIsSet(element: Integer): Boolean;
    /// <summary>
    /// Get whether an element supports translucency.
    /// </summary>
    /// <param name="element">
    /// The element parameter
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetElementAllowsTranslucent(element: Integer): Boolean;
    /// <summary>
    /// Get the colour of an element.
    /// </summary>
    /// <param name="element">
    /// The element parameter
    /// </param>
    /// <returns>
    /// Returns the elementbasecolour
    /// </returns>
    function GetElementBaseColour(element: Integer): TColorAlpha;
    /// <summary>
    /// Set the foreground colour of the main and additional selections and whether to use this setting.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure SetSelFore(useSetting: Boolean; fore: TColor);
    /// <summary>
    /// Set the background colour of the main and additional selections and whether to use this setting.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure SetSelBack(useSetting: Boolean; back: TColor);
    /// <summary>
    /// Get the alpha of the selection.
    /// </summary>
    /// <returns>
    /// Returns the selalpha
    /// </returns>
    function GetSelAlpha(): Integer;
    /// <summary>
    /// Set the alpha of the selection.
    /// </summary>
    /// <param name="alpha">
    /// The alpha parameter
    /// </param>
    procedure SetSelAlpha(alpha: Integer);
    /// <summary>
    /// Is the selection end of line filled?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetSelEOLFilled(): Boolean;
    /// <summary>
    /// Set the selection to have its end of line filled or not.
    /// </summary>
    /// <param name="filled">
    /// Boolean value
    /// </param>
    procedure SetSelEOLFilled(filled: Boolean);
    /// <summary>
    /// Get the layer for drawing selections
    /// </summary>
    /// <returns>
    /// Returns the selectionlayer
    /// </returns>
    function GetSelectionLayer(): Integer;
    /// <summary>
    /// Set the layer for drawing selections: either opaquely on base layer or translucently over text
    /// </summary>
    /// <param name="layer">
    /// The layer parameter
    /// </param>
    procedure SetSelectionLayer(layer: Integer);
    /// <summary>
    /// Get the layer of the background of the line containing the caret.
    /// </summary>
    /// <returns>
    /// Returns the caretlinelayer
    /// </returns>
    function GetCaretLineLayer(): Integer;
    /// <summary>
    /// Set the layer of the background of the line containing the caret.
    /// </summary>
    /// <param name="layer">
    /// The layer parameter
    /// </param>
    procedure SetCaretLineLayer(layer: Integer);
    /// <summary>
    /// Get only highlighting subline instead of whole line.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetCaretLineHighlightSubLine(): Boolean;
    /// <summary>
    /// Set only highlighting subline instead of whole line.
    /// </summary>
    /// <param name="subLine">
    /// Boolean value
    /// </param>
    procedure SetCaretLineHighlightSubLine(subLine: Boolean);
    /// <summary>
    /// Set the foreground colour of the caret.
    /// </summary>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure SetCaretFore(fore: TColor);
    /// <summary>
    /// When key+modifier combination keyDefinition is pressed perform sciCommand.
    /// </summary>
    /// <param name="keyDefinition">
    /// The keyDefinition parameter
    /// </param>
    /// <param name="sciCommand">
    /// Integer value
    /// </param>
    procedure AssignCmdKey(keyDefinition: Integer; sciCommand: Integer);
    /// <summary>
    /// When key+modifier combination keyDefinition is pressed do nothing.
    /// </summary>
    /// <param name="keyDefinition">
    /// The keyDefinition parameter
    /// </param>
    procedure ClearCmdKey(keyDefinition: Integer);
    /// <summary>
    /// Drop all key mappings.
    /// </summary>
    procedure ClearAllCmdKeys();
    /// <summary>
    /// Set the styles for a segment of the document.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="styles">
    /// Text string
    /// </param>
    procedure SetStylingEx(length: Integer; styles: PAnsiChar);
    /// <summary>
    /// Set a style to be visible or not.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="visible">
    /// Boolean value
    /// </param>
    procedure StyleSetVisible(style: Integer; visible: Boolean);
    /// <summary>
    /// Get the time in milliseconds that the caret is on and off.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetCaretPeriod(): Integer;
    /// <summary>
    /// Get the time in milliseconds that the caret is on and off. 0 = steady on.
    /// </summary>
    /// <param name="periodMilliseconds">
    /// Integer value
    /// </param>
    procedure SetCaretPeriod(periodMilliseconds: Integer);
    /// <summary>
    /// Set the set of characters making up words for when moving or selecting by word.
    /// First sets defaults like SetCharsDefault.
    /// </summary>
    /// <param name="characters">
    /// Text string
    /// </param>
    procedure SetWordChars(characters: PAnsiChar);
    /// <summary>
    /// Get the set of characters making up words for when moving or selecting by word.
    /// Returns the number of characters
    /// </summary>
    /// <param name="characters">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetWordChars(characters: PAnsiChar): Integer;
    /// <summary>
    /// Set the number of characters to have directly indexed categories
    /// </summary>
    /// <param name="countCharacters">
    /// Integer value
    /// </param>
    procedure SetCharacterCategoryOptimization(countCharacters: Integer);
    /// <summary>
    /// Get the number of characters to have directly indexed categories
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetCharacterCategoryOptimization(): Integer;
    /// <summary>
    /// Start a sequence of actions that is undone and redone as a unit.
    /// May be nested.
    /// </summary>
    procedure BeginUndoAction();
    /// <summary>
    /// End a sequence of actions that is undone and redone as a unit.
    /// </summary>
    procedure EndUndoAction();
    /// <summary>
    /// Is an undo sequence active?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoSequence(): Integer;
    /// <summary>
    /// How many undo actions are in the history?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoActions(): Integer;
    /// <summary>
    /// Set action as the save point
    /// </summary>
    /// <param name="action">
    /// Integer value
    /// </param>
    procedure SetUndoSavePoint(action: Integer);
    /// <summary>
    /// Which action is the save point?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoSavePoint(): Integer;
    /// <summary>
    /// Set action as the detach point
    /// </summary>
    /// <param name="action">
    /// Integer value
    /// </param>
    procedure SetUndoDetach(action: Integer);
    /// <summary>
    /// Which action is the detach point?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoDetach(): Integer;
    /// <summary>
    /// Set action as the tentative point
    /// </summary>
    /// <param name="action">
    /// Integer value
    /// </param>
    procedure SetUndoTentative(action: Integer);
    /// <summary>
    /// Which action is the tentative point?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoTentative(): Integer;
    /// <summary>
    /// Set action as the current point
    /// </summary>
    /// <param name="action">
    /// Integer value
    /// </param>
    procedure SetUndoCurrent(action: Integer);
    /// <summary>
    /// Which action is the current point?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoCurrent(): Integer;
    /// <summary>
    /// Push one action onto undo history with no text
    /// </summary>
    /// <param name="type">
    /// Integer value
    /// </param>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    procedure PushUndoActionType(type: Integer; pos: Integer);
    /// <summary>
    /// Set the text and length of the most recently pushed action
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure ChangeLastUndoActionText(length: Integer; text: PAnsiChar);
    /// <summary>
    /// What is the type of an action?
    /// </summary>
    /// <param name="action">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoActionType(action: Integer): Integer;
    /// <summary>
    /// What is the position of an action?
    /// </summary>
    /// <param name="action">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetUndoActionPosition(action: Integer): Integer;
    /// <summary>
    /// What is the text of an action?
    /// </summary>
    /// <param name="action">
    /// Integer value
    /// </param>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetUndoActionText(action: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Set an indicator to plain, squiggle or TT.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="indicatorStyle">
    /// The indicatorStyle parameter
    /// </param>
    procedure IndicSetStyle(indicator: Integer; indicatorStyle: Integer);
    /// <summary>
    /// Retrieve the style of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function IndicGetStyle(indicator: Integer): Integer;
    /// <summary>
    /// Set the foreground colour of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure IndicSetFore(indicator: Integer; fore: TColor);
    /// <summary>
    /// Retrieve the foreground colour of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function IndicGetFore(indicator: Integer): TColor;
    /// <summary>
    /// Set an indicator to draw under text or over(default).
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="under">
    /// Boolean value
    /// </param>
    procedure IndicSetUnder(indicator: Integer; under: Boolean);
    /// <summary>
    /// Retrieve whether indicator drawn under or over text.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function IndicGetUnder(indicator: Integer): Boolean;
    /// <summary>
    /// Set a hover indicator to plain, squiggle or TT.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="indicatorStyle">
    /// The indicatorStyle parameter
    /// </param>
    procedure IndicSetHoverStyle(indicator: Integer; indicatorStyle: Integer);
    /// <summary>
    /// Retrieve the hover style of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function IndicGetHoverStyle(indicator: Integer): Integer;
    /// <summary>
    /// Set the foreground hover colour of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure IndicSetHoverFore(indicator: Integer; fore: TColor);
    /// <summary>
    /// Retrieve the foreground hover colour of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function IndicGetHoverFore(indicator: Integer): TColor;
    /// <summary>
    /// Set the attributes of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="flags">
    /// The flags parameter
    /// </param>
    procedure IndicSetFlags(indicator: Integer; flags: Integer);
    /// <summary>
    /// Retrieve the attributes of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function IndicGetFlags(indicator: Integer): Integer;
    /// <summary>
    /// Set the stroke width of an indicator in hundredths of a pixel.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="hundredths">
    /// Integer value
    /// </param>
    procedure IndicSetStrokeWidth(indicator: Integer; hundredths: Integer);
    /// <summary>
    /// Retrieve the stroke width of an indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function IndicGetStrokeWidth(indicator: Integer): Integer;
    /// <summary>
    /// Set the foreground colour of all whitespace and whether to use this setting.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure SetWhitespaceFore(useSetting: Boolean; fore: TColor);
    /// <summary>
    /// Set the background colour of all whitespace and whether to use this setting.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure SetWhitespaceBack(useSetting: Boolean; back: TColor);
    /// <summary>
    /// Set the size of the dots used to mark space characters.
    /// </summary>
    /// <param name="size">
    /// Integer value
    /// </param>
    procedure SetWhitespaceSize(size: Integer);
    /// <summary>
    /// Get the size of the dots used to mark space characters.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetWhitespaceSize(): Integer;
    /// <summary>
    /// Used to hold extra styling information for each line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="state">
    /// Integer value
    /// </param>
    procedure SetLineState(line: Integer; state: Integer);
    /// <summary>
    /// Retrieve the extra styling information for a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetLineState(line: Integer): Integer;
    /// <summary>
    /// Retrieve the last line number that has line state.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMaxLineState(): Integer;
    /// <summary>
    /// Is the background of the line containing the caret in a different colour?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetCaretLineVisible(): Boolean;
    /// <summary>
    /// Display the background of the line containing the caret in a different colour.
    /// </summary>
    /// <param name="show">
    /// Boolean value
    /// </param>
    procedure SetCaretLineVisible(show: Boolean);
    /// <summary>
    /// Get the colour of the background of the line containing the caret.
    /// </summary>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function GetCaretLineBack(): TColor;
    /// <summary>
    /// Set the colour of the background of the line containing the caret.
    /// </summary>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure SetCaretLineBack(back: TColor);
    /// <summary>
    /// Retrieve the caret line frame width.
    /// Width = 0 means this option is disabled.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetCaretLineFrame(): Integer;
    /// <summary>
    /// Display the caret line framed.
    /// Set width != 0 to enable this option and width = 0 to disable it.
    /// </summary>
    /// <param name="width">
    /// Integer value
    /// </param>
    procedure SetCaretLineFrame(width: Integer);
    /// <summary>
    /// Set a style to be changeable or not (read only).
    /// Experimental feature, currently buggy.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="changeable">
    /// Boolean value
    /// </param>
    procedure StyleSetChangeable(style: Integer; changeable: Boolean);
    /// <summary>
    /// Display a auto-completion list.
    /// The lengthEntered parameter indicates how many characters before
    /// the caret should be used to provide context.
    /// </summary>
    /// <param name="lengthEntered">
    /// Position in the document
    /// </param>
    /// <param name="itemList">
    /// Text string
    /// </param>
    procedure AutoCShow(lengthEntered: Integer; itemList: PAnsiChar);
    /// <summary>
    /// Remove the auto-completion list from the screen.
    /// </summary>
    procedure AutoCCancel();
    /// <summary>
    /// Is there an auto-completion list visible?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function AutoCActive(): Boolean;
    /// <summary>
    /// Retrieve the position of the caret when the auto-completion list was displayed.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function AutoCPosStart(): Integer;
    /// <summary>
    /// User has selected an item so remove the list and insert the selection.
    /// </summary>
    procedure AutoCComplete();
    /// <summary>
    /// Define a set of character that when typed cancel the auto-completion list.
    /// </summary>
    /// <param name="characterSet">
    /// Text string
    /// </param>
    procedure AutoCStops(characterSet: PAnsiChar);
    /// <summary>
    /// Change the separator character in the string setting up an auto-completion list.
    /// Default is space but can be changed if items contain space.
    /// </summary>
    /// <param name="separatorCharacter">
    /// Integer value
    /// </param>
    procedure AutoCSetSeparator(separatorCharacter: Integer);
    /// <summary>
    /// Retrieve the auto-completion list separator character.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AutoCGetSeparator(): Integer;
    /// <summary>
    /// Select the item in the auto-completion list that starts with a string.
    /// </summary>
    /// <param name="select">
    /// Text string
    /// </param>
    procedure AutoCSelect(select: PAnsiChar);
    /// <summary>
    /// Should the auto-completion list be cancelled if the user backspaces to a
    /// position before where the box was created.
    /// </summary>
    /// <param name="cancel">
    /// Boolean value
    /// </param>
    procedure AutoCSetCancelAtStart(cancel: Boolean);
    /// <summary>
    /// Retrieve whether auto-completion cancelled by backspacing before start.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function AutoCGetCancelAtStart(): Boolean;
    /// <summary>
    /// Define a set of characters that when typed will cause the autocompletion to
    /// choose the selected item.
    /// </summary>
    /// <param name="characterSet">
    /// Text string
    /// </param>
    procedure AutoCSetFillUps(characterSet: PAnsiChar);
    /// <summary>
    /// Should a single item auto-completion list automatically choose the item.
    /// </summary>
    /// <param name="chooseSingle">
    /// Boolean value
    /// </param>
    procedure AutoCSetChooseSingle(chooseSingle: Boolean);
    /// <summary>
    /// Retrieve whether a single item auto-completion list automatically choose the item.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function AutoCGetChooseSingle(): Boolean;
    /// <summary>
    /// Set whether case is significant when performing auto-completion searches.
    /// </summary>
    /// <param name="ignoreCase">
    /// Boolean value
    /// </param>
    procedure AutoCSetIgnoreCase(ignoreCase: Boolean);
    /// <summary>
    /// Retrieve state of ignore case flag.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function AutoCGetIgnoreCase(): Boolean;
    /// <summary>
    /// Display a list of strings and send notification when user chooses one.
    /// </summary>
    /// <param name="listType">
    /// Integer value
    /// </param>
    /// <param name="itemList">
    /// Text string
    /// </param>
    procedure UserListShow(listType: Integer; itemList: PAnsiChar);
    /// <summary>
    /// Set whether or not autocompletion is hidden automatically when nothing matches.
    /// </summary>
    /// <param name="autoHide">
    /// Boolean value
    /// </param>
    procedure AutoCSetAutoHide(autoHide: Boolean);
    /// <summary>
    /// Retrieve whether or not autocompletion is hidden automatically when nothing matches.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function AutoCGetAutoHide(): Boolean;
    /// <summary>
    /// Set autocompletion options.
    /// </summary>
    /// <param name="options">
    /// The options parameter
    /// </param>
    procedure AutoCSetOptions(options: Integer);
    /// <summary>
    /// Retrieve autocompletion options.
    /// </summary>
    /// <returns>
    /// Returns the value
    /// </returns>
    function AutoCGetOptions(): Integer;
    /// <summary>
    /// Set whether or not autocompletion deletes any word characters
    /// after the inserted text upon completion.
    /// </summary>
    /// <param name="dropRestOfWord">
    /// Boolean value
    /// </param>
    procedure AutoCSetDropRestOfWord(dropRestOfWord: Boolean);
    /// <summary>
    /// Retrieve whether or not autocompletion deletes any word characters
    /// after the inserted text upon completion.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function AutoCGetDropRestOfWord(): Boolean;
    /// <summary>
    /// Register an XPM image for use in autocompletion lists.
    /// </summary>
    /// <param name="type">
    /// Integer value
    /// </param>
    /// <param name="xpmData">
    /// Text string
    /// </param>
    procedure RegisterImage(type: Integer; xpmData: PAnsiChar);
    /// <summary>
    /// Clear all the registered XPM images.
    /// </summary>
    procedure ClearRegisteredImages();
    /// <summary>
    /// Retrieve the auto-completion list type-separator character.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AutoCGetTypeSeparator(): Integer;
    /// <summary>
    /// Change the type-separator character in the string setting up an auto-completion list.
    /// Default is '?' but can be changed if items contain '?'.
    /// </summary>
    /// <param name="separatorCharacter">
    /// Integer value
    /// </param>
    procedure AutoCSetTypeSeparator(separatorCharacter: Integer);
    /// <summary>
    /// Set the maximum width, in characters, of auto-completion and user lists.
    /// Set to 0 to autosize to fit longest item, which is the default.
    /// </summary>
    /// <param name="characterCount">
    /// Integer value
    /// </param>
    procedure AutoCSetMaxWidth(characterCount: Integer);
    /// <summary>
    /// Get the maximum width, in characters, of auto-completion and user lists.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AutoCGetMaxWidth(): Integer;
    /// <summary>
    /// Set the maximum height, in rows, of auto-completion and user lists.
    /// The default is 5 rows.
    /// </summary>
    /// <param name="rowCount">
    /// Integer value
    /// </param>
    procedure AutoCSetMaxHeight(rowCount: Integer);
    /// <summary>
    /// Set the maximum height, in rows, of auto-completion and user lists.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AutoCGetMaxHeight(): Integer;
    /// <summary>
    /// Set the style number used for auto-completion and user lists fonts.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure AutoCSetStyle(style: Integer);
    /// <summary>
    /// Get the style number used for auto-completion and user lists fonts.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AutoCGetStyle(): Integer;
    /// <summary>
    /// Set the number of spaces used for one level of indentation.
    /// </summary>
    /// <param name="indentSize">
    /// Integer value
    /// </param>
    procedure SetIndent(indentSize: Integer);
    /// <summary>
    /// Retrieve indentation size.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetIndent(): Integer;
    /// <summary>
    /// Indentation will only use space characters if useTabs is false, otherwise
    /// it will use a combination of tabs and spaces.
    /// </summary>
    /// <param name="useTabs">
    /// Boolean value
    /// </param>
    procedure SetUseTabs(useTabs: Boolean);
    /// <summary>
    /// Retrieve whether tabs will be used in indentation.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetUseTabs(): Boolean;
    /// <summary>
    /// Change the indentation of a line to a number of columns.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="indentation">
    /// Integer value
    /// </param>
    procedure SetLineIndentation(line: Integer; indentation: Integer);
    /// <summary>
    /// Retrieve the number of columns that a line is indented.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetLineIndentation(line: Integer): Integer;
    /// <summary>
    /// Retrieve the position before the first non indentation character on a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetLineIndentPosition(line: Integer): Integer;
    /// <summary>
    /// Retrieve the column number of a position, taking tab width into account.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetColumn(pos: Integer): Integer;
    /// <summary>
    /// Count characters between two positions.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function CountCharacters(start: Integer; end: Integer): Integer;
    /// <summary>
    /// Count code units between two positions.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function CountCodeUnits(start: Integer; end: Integer): Integer;
    /// <summary>
    /// Show or hide the horizontal scroll bar.
    /// </summary>
    /// <param name="visible">
    /// Boolean value
    /// </param>
    procedure SetHScrollBar(visible: Boolean);
    /// <summary>
    /// Is the horizontal scroll bar visible?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetHScrollBar(): Boolean;
    /// <summary>
    /// Show or hide indentation guides.
    /// </summary>
    /// <param name="indentView">
    /// The indentView parameter
    /// </param>
    procedure SetIndentationGuides(indentView: Integer);
    /// <summary>
    /// Are the indentation guides visible?
    /// </summary>
    /// <returns>
    /// Returns the indentationguides
    /// </returns>
    function GetIndentationGuides(): Integer;
    /// <summary>
    /// Set the highlighted indentation guide column.
    /// 0 = no highlighted guide.
    /// </summary>
    /// <param name="column">
    /// Position in the document
    /// </param>
    procedure SetHighlightGuide(column: Integer);
    /// <summary>
    /// Get the highlighted indentation guide column.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetHighlightGuide(): Integer;
    /// <summary>
    /// Get the position after the last visible characters on a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetLineEndPosition(line: Integer): Integer;
    /// <summary>
    /// Get the code page used to interpret the bytes of the document as characters.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetCodePage(): Integer;
    /// <summary>
    /// Get the foreground colour of the caret.
    /// </summary>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function GetCaretFore(): TColor;
    /// <summary>
    /// In read-only mode?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetReadOnly(): Boolean;
    /// <summary>
    /// Sets the position of the caret.
    /// </summary>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure SetCurrentPos(caret: Integer);
    /// <summary>
    /// Sets the position that starts the selection - this becomes the anchor.
    /// </summary>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    procedure SetSelectionStart(anchor: Integer);
    /// <summary>
    /// Returns the position at the start of the selection.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionStart(): Integer;
    /// <summary>
    /// Sets the position that ends the selection - this becomes the caret.
    /// </summary>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure SetSelectionEnd(caret: Integer);
    /// <summary>
    /// Returns the position at the end of the selection.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionEnd(): Integer;
    /// <summary>
    /// Set caret to a position, while removing any existing selection.
    /// </summary>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure SetEmptySelection(caret: Integer);
    /// <summary>
    /// Sets the print magnification added to the point size of each style for printing.
    /// </summary>
    /// <param name="magnification">
    /// Integer value
    /// </param>
    procedure SetPrintMagnification(magnification: Integer);
    /// <summary>
    /// Returns the print magnification.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetPrintMagnification(): Integer;
    /// <summary>
    /// Modify colours when printing for clearer printed text.
    /// </summary>
    /// <param name="mode">
    /// The mode parameter
    /// </param>
    procedure SetPrintColourMode(mode: Integer);
    /// <summary>
    /// Returns the print colour mode.
    /// </summary>
    /// <returns>
    /// Returns the printcolourmode
    /// </returns>
    function GetPrintColourMode(): Integer;
    /// <summary>
    /// Find some text in the document.
    /// </summary>
    /// <param name="searchFlags">
    /// The searchFlags parameter
    /// </param>
    /// <param name="ft">
    /// The ft parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function FindText(searchFlags: Integer; ft: PFindText): Integer;
    /// <summary>
    /// Find some text in the document.
    /// </summary>
    /// <param name="searchFlags">
    /// The searchFlags parameter
    /// </param>
    /// <param name="ft">
    /// The ft parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function FindTextFull(searchFlags: Integer; ft: PFindTextFull): Integer;
    /// <summary>
    /// Draw the document into a display context such as a printer.
    /// </summary>
    /// <param name="draw">
    /// Boolean value
    /// </param>
    /// <param name="fr">
    /// The fr parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function FormatRange(draw: Boolean; fr: PFormatRange): Integer;
    /// <summary>
    /// Draw the document into a display context such as a printer.
    /// </summary>
    /// <param name="draw">
    /// Boolean value
    /// </param>
    /// <param name="fr">
    /// The fr parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function FormatRangeFull(draw: Boolean; fr: PFormatRangeFull): Integer;
    /// <summary>
    /// Enable or disable change history.
    /// </summary>
    /// <param name="changeHistory">
    /// The changeHistory parameter
    /// </param>
    procedure SetChangeHistory(changeHistory: Integer);
    /// <summary>
    /// Report change history status.
    /// </summary>
    /// <returns>
    /// Returns the changehistory
    /// </returns>
    function GetChangeHistory(): Integer;
    /// <summary>
    /// Enable or disable undo selection history.
    /// </summary>
    /// <param name="undoSelectionHistory">
    /// The undoSelectionHistory parameter
    /// </param>
    procedure SetUndoSelectionHistory(undoSelectionHistory: Integer);
    /// <summary>
    /// Report undo selection history status.
    /// </summary>
    /// <returns>
    /// Returns the undoselectionhistory
    /// </returns>
    function GetUndoSelectionHistory(): Integer;
    /// <summary>
    /// Set selection from serialized form.
    /// </summary>
    /// <param name="selectionString">
    /// Text string
    /// </param>
    procedure SetSelectionSerialized(selectionString: PAnsiChar);
    /// <summary>
    /// Retrieve serialized form of selection.
    /// </summary>
    /// <param name="selectionString">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionSerialized(selectionString: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve the display line at the top of the display.
    /// </summary>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function GetFirstVisibleLine(): Integer;
    /// <summary>
    /// Retrieve the contents of a line.
    /// Returns the length of the line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetLine(line: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Returns the number of lines in the document. There is always at least one.
    /// </summary>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function GetLineCount(): Integer;
    /// <summary>
    /// Enlarge the number of lines allocated.
    /// </summary>
    /// <param name="lines">
    /// Line number
    /// </param>
    procedure AllocateLines(lines: Integer);
    /// <summary>
    /// Sets the size in pixels of the left margin.
    /// </summary>
    /// <param name="pixelWidth">
    /// Integer value
    /// </param>
    procedure SetMarginLeft(pixelWidth: Integer);
    /// <summary>
    /// Returns the size in pixels of the left margin.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMarginLeft(): Integer;
    /// <summary>
    /// Sets the size in pixels of the right margin.
    /// </summary>
    /// <param name="pixelWidth">
    /// Integer value
    /// </param>
    procedure SetMarginRight(pixelWidth: Integer);
    /// <summary>
    /// Returns the size in pixels of the right margin.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMarginRight(): Integer;
    /// <summary>
    /// Is the document different from when it was last saved?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetModify(): Boolean;
    /// <summary>
    /// Select a range of text.
    /// </summary>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure SetSel(anchor: Integer; caret: Integer);
    /// <summary>
    /// Retrieve the selected text.
    /// Return the length of the text.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelText(text: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve a range of text.
    /// Return the length of the text.
    /// </summary>
    /// <param name="tr">
    /// The tr parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTextRange(tr: PTextRange): Integer;
    /// <summary>
    /// Retrieve a range of text that can be past 2GB.
    /// Return the length of the text.
    /// </summary>
    /// <param name="tr">
    /// The tr parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTextRangeFull(tr: PTextRangeFull): Integer;
    /// <summary>
    /// Draw the selection either highlighted or in normal (non-highlighted) style.
    /// </summary>
    /// <param name="hide">
    /// Boolean value
    /// </param>
    procedure HideSelection(hide: Boolean);
    function GetSelectionHidden(): Boolean;
    /// <summary>
    /// Retrieve the x value of the point in the window where a position is displayed.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function PointXFromPosition(pos: Integer): Integer;
    /// <summary>
    /// Retrieve the y value of the point in the window where a position is displayed.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function PointYFromPosition(pos: Integer): Integer;
    /// <summary>
    /// Retrieve the line containing a position.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function LineFromPosition(pos: Integer): Integer;
    /// <summary>
    /// Retrieve the position at the start of a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function PositionFromLine(line: Integer): Integer;
    /// <summary>
    /// Scroll horizontally and vertically.
    /// </summary>
    /// <param name="columns">
    /// Position in the document
    /// </param>
    /// <param name="lines">
    /// Line number
    /// </param>
    procedure LineScroll(columns: Integer; lines: Integer);
    /// <summary>
    /// Ensure the caret is visible.
    /// </summary>
    procedure ScrollCaret();
    /// <summary>
    /// Scroll the argument positions and the range between them into view giving
    /// priority to the primary position then the secondary position.
    /// This may be used to make a search match visible.
    /// </summary>
    /// <param name="secondary">
    /// Position in the document
    /// </param>
    /// <param name="primary">
    /// Position in the document
    /// </param>
    procedure ScrollRange(secondary: Integer; primary: Integer);
    /// <summary>
    /// Replace the selected text with the argument text.
    /// </summary>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure ReplaceSel(text: PAnsiChar);
    /// <summary>
    /// Set to read only or read write.
    /// </summary>
    /// <param name="readOnly">
    /// Boolean value
    /// </param>
    procedure SetReadOnly(readOnly: Boolean);
    /// <summary>
    /// Null operation.
    /// </summary>
    procedure Null();
    /// <summary>
    /// Will a paste succeed?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function CanPaste(): Boolean;
    /// <summary>
    /// Are there any undoable actions in the undo history?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function CanUndo(): Boolean;
    /// <summary>
    /// Delete the undo history.
    /// </summary>
    procedure EmptyUndoBuffer();
    /// <summary>
    /// Undo one action in the undo history.
    /// </summary>
    procedure Undo();
    /// <summary>
    /// Cut the selection to the clipboard.
    /// </summary>
    procedure Cut();
    /// <summary>
    /// Copy the selection to the clipboard.
    /// </summary>
    procedure Copy();
    /// <summary>
    /// Paste the contents of the clipboard into the document replacing the selection.
    /// </summary>
    procedure Paste();
    /// <summary>
    /// Clear the selection.
    /// </summary>
    procedure Clear();
    /// <summary>
    /// Replace the contents of the document with the argument text.
    /// </summary>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure SetText(text: PAnsiChar);
    /// <summary>
    /// Retrieve all the text in the document.
    /// Returns number of characters retrieved.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetText(length: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve the number of characters in the document.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTextLength(): Integer;
    /// <summary>
    /// Retrieve a pointer to a function that processes messages for this Scintilla.
    /// </summary>
    /// <returns>
    /// Returns the directfunction
    /// </returns>
    function GetDirectFunction(): Pointer;
    /// <summary>
    /// Retrieve a pointer to a function that processes messages for this Scintilla and returns status.
    /// </summary>
    /// <returns>
    /// Returns the directstatusfunction
    /// </returns>
    function GetDirectStatusFunction(): Pointer;
    /// <summary>
    /// Retrieve a pointer value to use as the first argument when calling
    /// the function returned by GetDirectFunction.
    /// </summary>
    /// <returns>
    /// Returns the directpointer
    /// </returns>
    function GetDirectPointer(): Pointer;
    /// <summary>
    /// Set to overtype (true) or insert mode.
    /// </summary>
    /// <param name="overType">
    /// Boolean value
    /// </param>
    procedure SetOvertype(overType: Boolean);
    /// <summary>
    /// Returns true if overtype mode is active otherwise false is returned.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetOvertype(): Boolean;
    /// <summary>
    /// Set the width of the insert mode caret.
    /// </summary>
    /// <param name="pixelWidth">
    /// Integer value
    /// </param>
    procedure SetCaretWidth(pixelWidth: Integer);
    /// <summary>
    /// Returns the width of the insert mode caret.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetCaretWidth(): Integer;
    /// <summary>
    /// Sets the position that starts the target which is used for updating the
    /// document without affecting the scroll position.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    procedure SetTargetStart(start: Integer);
    /// <summary>
    /// Get the position that starts the target.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTargetStart(): Integer;
    /// <summary>
    /// Sets the virtual space of the target start
    /// </summary>
    /// <param name="space">
    /// Position in the document
    /// </param>
    procedure SetTargetStartVirtualSpace(space: Integer);
    /// <summary>
    /// Get the virtual space of the target start
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTargetStartVirtualSpace(): Integer;
    /// <summary>
    /// Sets the position that ends the target which is used for updating the
    /// document without affecting the scroll position.
    /// </summary>
    /// <param name="end">
    /// Position in the document
    /// </param>
    procedure SetTargetEnd(end: Integer);
    /// <summary>
    /// Get the position that ends the target.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTargetEnd(): Integer;
    /// <summary>
    /// Sets the virtual space of the target end
    /// </summary>
    /// <param name="space">
    /// Position in the document
    /// </param>
    procedure SetTargetEndVirtualSpace(space: Integer);
    /// <summary>
    /// Get the virtual space of the target end
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTargetEndVirtualSpace(): Integer;
    /// <summary>
    /// Sets both the start and end of the target in one call.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    procedure SetTargetRange(start: Integer; end: Integer);
    /// <summary>
    /// Retrieve the text in the target.
    /// </summary>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetTargetText(text: PAnsiChar): Integer;
    /// <summary>
    /// Make the target range start and end be the same as the selection range start and end.
    /// </summary>
    procedure TargetFromSelection();
    /// <summary>
    /// Sets the target to the whole document.
    /// </summary>
    procedure TargetWholeDocument();
    /// <summary>
    /// Replace the target text with the argument text.
    /// Text is counted so it can contain NULs.
    /// Returns the length of the replacement text.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function ReplaceTarget(length: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Replace the target text with the argument text after \d processing.
    /// Text is counted so it can contain NULs.
    /// Looks for \d where d is between 1 and 9 and replaces these with the strings
    /// matched in the last search operation which were surrounded by \( and \).
    /// Returns the length of the replacement text including any change
    /// caused by processing the \d patterns.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function ReplaceTargetRE(length: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Replace the target text with the argument text but ignore prefix and suffix that
    /// are the same as current.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function ReplaceTargetMinimal(length: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Search for a counted string in the target and set the target to the found
    /// range. Text is counted so it can contain NULs.
    /// Returns start of found range or -1 for failure in which case target is not moved.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function SearchInTarget(length: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Set the search flags used by SearchInTarget.
    /// </summary>
    /// <param name="searchFlags">
    /// The searchFlags parameter
    /// </param>
    procedure SetSearchFlags(searchFlags: Integer);
    /// <summary>
    /// Get the search flags used by SearchInTarget.
    /// </summary>
    /// <returns>
    /// Returns the searchflags
    /// </returns>
    function GetSearchFlags(): Integer;
    /// <summary>
    /// Show a call tip containing a definition near position pos.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="definition">
    /// Text string
    /// </param>
    procedure CallTipShow(pos: Integer; definition: PAnsiChar);
    /// <summary>
    /// Remove the call tip from the screen.
    /// </summary>
    procedure CallTipCancel();
    /// <summary>
    /// Is there an active call tip?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function CallTipActive(): Boolean;
    /// <summary>
    /// Retrieve the position where the caret was before displaying the call tip.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function CallTipPosStart(): Integer;
    /// <summary>
    /// Set the start position in order to change when backspacing removes the calltip.
    /// </summary>
    /// <param name="posStart">
    /// Position in the document
    /// </param>
    procedure CallTipSetPosStart(posStart: Integer);
    /// <summary>
    /// Highlight a segment of the definition.
    /// </summary>
    /// <param name="highlightStart">
    /// Position in the document
    /// </param>
    /// <param name="highlightEnd">
    /// Position in the document
    /// </param>
    procedure CallTipSetHlt(highlightStart: Integer; highlightEnd: Integer);
    /// <summary>
    /// Set the background colour for the call tip.
    /// </summary>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure CallTipSetBack(back: TColor);
    /// <summary>
    /// Set the foreground colour for the call tip.
    /// </summary>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure CallTipSetFore(fore: TColor);
    /// <summary>
    /// Set the foreground colour for the highlighted part of the call tip.
    /// </summary>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure CallTipSetForeHlt(fore: TColor);
    /// <summary>
    /// Enable use of STYLE_CALLTIP and set call tip tab size in pixels.
    /// </summary>
    /// <param name="tabSize">
    /// Integer value
    /// </param>
    procedure CallTipUseStyle(tabSize: Integer);
    /// <summary>
    /// Set position of calltip, above or below text.
    /// </summary>
    /// <param name="above">
    /// Boolean value
    /// </param>
    procedure CallTipSetPosition(above: Boolean);
    /// <summary>
    /// Find the display line of a document line taking hidden lines into account.
    /// </summary>
    /// <param name="docLine">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function VisibleFromDocLine(docLine: Integer): Integer;
    /// <summary>
    /// Find the document line of a display line taking hidden lines into account.
    /// </summary>
    /// <param name="displayLine">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function DocLineFromVisible(displayLine: Integer): Integer;
    /// <summary>
    /// The number of display lines needed to wrap a document line
    /// </summary>
    /// <param name="docLine">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function WrapCount(docLine: Integer): Integer;
    /// <summary>
    /// Set the fold level of a line.
    /// This encodes an integer level along with flags indicating whether the
    /// line is a header and whether it is effectively white space.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="level">
    /// The level parameter
    /// </param>
    procedure SetFoldLevel(line: Integer; level: Integer);
    /// <summary>
    /// Retrieve the fold level of a line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the foldlevel
    /// </returns>
    function GetFoldLevel(line: Integer): Integer;
    /// <summary>
    /// Find the last child line of a header line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="level">
    /// The level parameter
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function GetLastChild(line: Integer; level: Integer): Integer;
    /// <summary>
    /// Find the parent line of a child line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function GetFoldParent(line: Integer): Integer;
    /// <summary>
    /// Make a range of lines visible.
    /// </summary>
    /// <param name="lineStart">
    /// Line number
    /// </param>
    /// <param name="lineEnd">
    /// Line number
    /// </param>
    procedure ShowLines(lineStart: Integer; lineEnd: Integer);
    /// <summary>
    /// Make a range of lines invisible.
    /// </summary>
    /// <param name="lineStart">
    /// Line number
    /// </param>
    /// <param name="lineEnd">
    /// Line number
    /// </param>
    procedure HideLines(lineStart: Integer; lineEnd: Integer);
    /// <summary>
    /// Is a line visible?
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetLineVisible(line: Integer): Boolean;
    /// <summary>
    /// Are all lines visible?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetAllLinesVisible(): Boolean;
    /// <summary>
    /// Show the children of a header line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="expanded">
    /// Boolean value
    /// </param>
    procedure SetFoldExpanded(line: Integer; expanded: Boolean);
    /// <summary>
    /// Is a header line expanded?
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetFoldExpanded(line: Integer): Boolean;
    /// <summary>
    /// Switch a header line between expanded and contracted.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    procedure ToggleFold(line: Integer);
    /// <summary>
    /// Switch a header line between expanded and contracted and show some text after the line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure ToggleFoldShowText(line: Integer; text: PAnsiChar);
    /// <summary>
    /// Set the style of fold display text.
    /// </summary>
    /// <param name="style">
    /// The style parameter
    /// </param>
    procedure FoldDisplayTextSetStyle(style: Integer);
    /// <summary>
    /// Get the style of fold display text.
    /// </summary>
    /// <returns>
    /// Returns the value
    /// </returns>
    function FoldDisplayTextGetStyle(): Integer;
    /// <summary>
    /// Set the default fold display text.
    /// </summary>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure SetDefaultFoldDisplayText(text: PAnsiChar);
    /// <summary>
    /// Get the default fold display text.
    /// </summary>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetDefaultFoldDisplayText(text: PAnsiChar): Integer;
    /// <summary>
    /// Expand or contract a fold header.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="action">
    /// The action parameter
    /// </param>
    procedure FoldLine(line: Integer; action: Integer);
    /// <summary>
    /// Expand or contract a fold header and its children.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="action">
    /// The action parameter
    /// </param>
    procedure FoldChildren(line: Integer; action: Integer);
    /// <summary>
    /// Expand a fold header and all children. Use the level argument instead of the line's current level.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="level">
    /// The level parameter
    /// </param>
    procedure ExpandChildren(line: Integer; level: Integer);
    /// <summary>
    /// Expand or contract all fold headers.
    /// </summary>
    /// <param name="action">
    /// The action parameter
    /// </param>
    procedure FoldAll(action: Integer);
    /// <summary>
    /// Ensure a particular line is visible by expanding any header line hiding it.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    procedure EnsureVisible(line: Integer);
    /// <summary>
    /// Set automatic folding behaviours.
    /// </summary>
    /// <param name="automaticFold">
    /// The automaticFold parameter
    /// </param>
    procedure SetAutomaticFold(automaticFold: Integer);
    /// <summary>
    /// Get automatic folding behaviours.
    /// </summary>
    /// <returns>
    /// Returns the automaticfold
    /// </returns>
    function GetAutomaticFold(): Integer;
    /// <summary>
    /// Set some style options for folding.
    /// </summary>
    /// <param name="flags">
    /// The flags parameter
    /// </param>
    procedure SetFoldFlags(flags: Integer);
    /// <summary>
    /// Ensure a particular line is visible by expanding any header line hiding it.
    /// Use the currently set visibility policy to determine which range to display.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    procedure EnsureVisibleEnforcePolicy(line: Integer);
    /// <summary>
    /// Sets whether a tab pressed when caret is within indentation indents.
    /// </summary>
    /// <param name="tabIndents">
    /// Boolean value
    /// </param>
    procedure SetTabIndents(tabIndents: Boolean);
    /// <summary>
    /// Does a tab pressed when caret is within indentation indent?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetTabIndents(): Boolean;
    /// <summary>
    /// Sets whether a backspace pressed when caret is within indentation unindents.
    /// </summary>
    /// <param name="bsUnIndents">
    /// Boolean value
    /// </param>
    procedure SetBackSpaceUnIndents(bsUnIndents: Boolean);
    /// <summary>
    /// Does a backspace pressed when caret is within indentation unindent?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetBackSpaceUnIndents(): Boolean;
    /// <summary>
    /// Sets the time the mouse must sit still to generate a mouse dwell event.
    /// </summary>
    /// <param name="periodMilliseconds">
    /// Integer value
    /// </param>
    procedure SetMouseDwellTime(periodMilliseconds: Integer);
    /// <summary>
    /// Retrieve the time the mouse must sit still to generate a mouse dwell event.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMouseDwellTime(): Integer;
    /// <summary>
    /// Get position of start of word.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="onlyWordCharacters">
    /// Boolean value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function WordStartPosition(pos: Integer; onlyWordCharacters: Boolean): Integer;
    /// <summary>
    /// Get position of end of word.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="onlyWordCharacters">
    /// Boolean value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function WordEndPosition(pos: Integer; onlyWordCharacters: Boolean): Integer;
    /// <summary>
    /// Is the range start..end considered a word?
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function IsRangeWord(start: Integer; end: Integer): Boolean;
    /// <summary>
    /// Sets limits to idle styling.
    /// </summary>
    /// <param name="idleStyling">
    /// The idleStyling parameter
    /// </param>
    procedure SetIdleStyling(idleStyling: Integer);
    /// <summary>
    /// Retrieve the limits to idle styling.
    /// </summary>
    /// <returns>
    /// Returns the idlestyling
    /// </returns>
    function GetIdleStyling(): Integer;
    /// <summary>
    /// Sets whether text is word wrapped.
    /// </summary>
    /// <param name="wrapMode">
    /// The wrapMode parameter
    /// </param>
    procedure SetWrapMode(wrapMode: Integer);
    /// <summary>
    /// Retrieve whether text is word wrapped.
    /// </summary>
    /// <returns>
    /// Returns the wrapmode
    /// </returns>
    function GetWrapMode(): Integer;
    /// <summary>
    /// Set the display mode of visual flags for wrapped lines.
    /// </summary>
    /// <param name="wrapVisualFlags">
    /// The wrapVisualFlags parameter
    /// </param>
    procedure SetWrapVisualFlags(wrapVisualFlags: Integer);
    /// <summary>
    /// Retrive the display mode of visual flags for wrapped lines.
    /// </summary>
    /// <returns>
    /// Returns the wrapvisualflags
    /// </returns>
    function GetWrapVisualFlags(): Integer;
    /// <summary>
    /// Set the location of visual flags for wrapped lines.
    /// </summary>
    /// <param name="wrapVisualFlagsLocation">
    /// The wrapVisualFlagsLocation parameter
    /// </param>
    procedure SetWrapVisualFlagsLocation(wrapVisualFlagsLocation: Integer);
    /// <summary>
    /// Retrive the location of visual flags for wrapped lines.
    /// </summary>
    /// <returns>
    /// Returns the wrapvisualflagslocation
    /// </returns>
    function GetWrapVisualFlagsLocation(): Integer;
    /// <summary>
    /// Set the start indent for wrapped lines.
    /// </summary>
    /// <param name="indent">
    /// Integer value
    /// </param>
    procedure SetWrapStartIndent(indent: Integer);
    /// <summary>
    /// Retrive the start indent for wrapped lines.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetWrapStartIndent(): Integer;
    /// <summary>
    /// Sets how wrapped sublines are placed. Default is fixed.
    /// </summary>
    /// <param name="wrapIndentMode">
    /// The wrapIndentMode parameter
    /// </param>
    procedure SetWrapIndentMode(wrapIndentMode: Integer);
    /// <summary>
    /// Retrieve how wrapped sublines are placed. Default is fixed.
    /// </summary>
    /// <returns>
    /// Returns the wrapindentmode
    /// </returns>
    function GetWrapIndentMode(): Integer;
    /// <summary>
    /// Sets the degree of caching of layout information.
    /// </summary>
    /// <param name="cacheMode">
    /// The cacheMode parameter
    /// </param>
    procedure SetLayoutCache(cacheMode: Integer);
    /// <summary>
    /// Retrieve the degree of caching of layout information.
    /// </summary>
    /// <returns>
    /// Returns the layoutcache
    /// </returns>
    function GetLayoutCache(): Integer;
    /// <summary>
    /// Sets the document width assumed for scrolling.
    /// </summary>
    /// <param name="pixelWidth">
    /// Integer value
    /// </param>
    procedure SetScrollWidth(pixelWidth: Integer);
    /// <summary>
    /// Retrieve the document width assumed for scrolling.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetScrollWidth(): Integer;
    /// <summary>
    /// Sets whether the maximum width line displayed is used to set scroll width.
    /// </summary>
    /// <param name="tracking">
    /// Boolean value
    /// </param>
    procedure SetScrollWidthTracking(tracking: Boolean);
    /// <summary>
    /// Retrieve whether the scroll width tracks wide lines.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetScrollWidthTracking(): Boolean;
    /// <summary>
    /// Measure the pixel width of some text in a particular style.
    /// NUL terminated text argument.
    /// Does not handle tab or control characters.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function TextWidth(style: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Sets the scroll range so that maximum scroll position has
    /// the last line at the bottom of the view (default).
    /// Setting this to false allows scrolling one page below the last line.
    /// </summary>
    /// <param name="endAtLastLine">
    /// Boolean value
    /// </param>
    procedure SetEndAtLastLine(endAtLastLine: Boolean);
    /// <summary>
    /// Retrieve whether the maximum scroll position has the last
    /// line at the bottom of the view.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetEndAtLastLine(): Boolean;
    /// <summary>
    /// Retrieve the height of a particular line of text in pixels.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function TextHeight(line: Integer): Integer;
    /// <summary>
    /// Show or hide the vertical scroll bar.
    /// </summary>
    /// <param name="visible">
    /// Boolean value
    /// </param>
    procedure SetVScrollBar(visible: Boolean);
    /// <summary>
    /// Is the vertical scroll bar visible?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetVScrollBar(): Boolean;
    /// <summary>
    /// Append a string to the end of the document without changing the selection.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure AppendText(length: Integer; text: PAnsiChar);
    /// <summary>
    /// How many phases is drawing done in?
    /// </summary>
    /// <returns>
    /// Returns the phasesdraw
    /// </returns>
    function GetPhasesDraw(): Integer;
    /// <summary>
    /// In one phase draw, text is drawn in a series of rectangular blocks with no overlap.
    /// In two phase draw, text is drawn in a series of lines allowing runs to overlap horizontally.
    /// In multiple phase draw, each element is drawn over the whole drawing area, allowing text
    /// to overlap from one line to the next.
    /// </summary>
    /// <param name="phases">
    /// The phases parameter
    /// </param>
    procedure SetPhasesDraw(phases: Integer);
    /// <summary>
    /// Choose the quality level for text from the FontQuality enumeration.
    /// </summary>
    /// <param name="fontQuality">
    /// The fontQuality parameter
    /// </param>
    procedure SetFontQuality(fontQuality: Integer);
    /// <summary>
    /// Retrieve the quality level for text.
    /// </summary>
    /// <returns>
    /// Returns the fontquality
    /// </returns>
    function GetFontQuality(): Integer;
    /// <summary>
    /// Scroll so that a display line is at the top of the display.
    /// </summary>
    /// <param name="displayLine">
    /// Line number
    /// </param>
    procedure SetFirstVisibleLine(displayLine: Integer);
    /// <summary>
    /// Change the effect of pasting when there are multiple selections.
    /// </summary>
    /// <param name="multiPaste">
    /// The multiPaste parameter
    /// </param>
    procedure SetMultiPaste(multiPaste: Integer);
    /// <summary>
    /// Retrieve the effect of pasting when there are multiple selections.
    /// </summary>
    /// <returns>
    /// Returns the multipaste
    /// </returns>
    function GetMultiPaste(): Integer;
    /// <summary>
    /// Retrieve the value of a tag from a regular expression search.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="tagNumber">
    /// Integer value
    /// </param>
    /// <param name="tagValue">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetTag(tagNumber: Integer; tagValue: PAnsiChar): Integer;
    /// <summary>
    /// Join the lines in the target.
    /// </summary>
    procedure LinesJoin();
    /// <summary>
    /// Split the lines in the target into lines that are less wide than pixelWidth
    /// where possible.
    /// </summary>
    /// <param name="pixelWidth">
    /// Integer value
    /// </param>
    procedure LinesSplit(pixelWidth: Integer);
    /// <summary>
    /// Set one of the colours used as a chequerboard pattern in the fold margin
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure SetFoldMarginColour(useSetting: Boolean; back: TColor);
    /// <summary>
    /// Set the other colour used as a chequerboard pattern in the fold margin
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure SetFoldMarginHiColour(useSetting: Boolean; fore: TColor);
    /// <summary>
    /// Enable or disable accessibility.
    /// </summary>
    /// <param name="accessibility">
    /// The accessibility parameter
    /// </param>
    procedure SetAccessibility(accessibility: Integer);
    /// <summary>
    /// Report accessibility status.
    /// </summary>
    /// <returns>
    /// Returns the accessibility
    /// </returns>
    function GetAccessibility(): Integer;
    /// <summary>
    /// Move caret down one line.
    /// </summary>
    procedure LineDown();
    /// <summary>
    /// Move caret down one line extending selection to new caret position.
    /// </summary>
    procedure LineDownExtend();
    /// <summary>
    /// Move caret up one line.
    /// </summary>
    procedure LineUp();
    /// <summary>
    /// Move caret up one line extending selection to new caret position.
    /// </summary>
    procedure LineUpExtend();
    /// <summary>
    /// Move caret left one character.
    /// </summary>
    procedure CharLeft();
    /// <summary>
    /// Move caret left one character extending selection to new caret position.
    /// </summary>
    procedure CharLeftExtend();
    /// <summary>
    /// Move caret right one character.
    /// </summary>
    procedure CharRight();
    /// <summary>
    /// Move caret right one character extending selection to new caret position.
    /// </summary>
    procedure CharRightExtend();
    /// <summary>
    /// Move caret left one word.
    /// </summary>
    procedure WordLeft();
    /// <summary>
    /// Move caret left one word extending selection to new caret position.
    /// </summary>
    procedure WordLeftExtend();
    /// <summary>
    /// Move caret right one word.
    /// </summary>
    procedure WordRight();
    /// <summary>
    /// Move caret right one word extending selection to new caret position.
    /// </summary>
    procedure WordRightExtend();
    /// <summary>
    /// Move caret to first position on line.
    /// </summary>
    procedure Home();
    /// <summary>
    /// Move caret to first position on line extending selection to new caret position.
    /// </summary>
    procedure HomeExtend();
    /// <summary>
    /// Move caret to last position on line.
    /// </summary>
    procedure LineEnd();
    /// <summary>
    /// Move caret to last position on line extending selection to new caret position.
    /// </summary>
    procedure LineEndExtend();
    /// <summary>
    /// Move caret to first position in document.
    /// </summary>
    procedure DocumentStart();
    /// <summary>
    /// Move caret to first position in document extending selection to new caret position.
    /// </summary>
    procedure DocumentStartExtend();
    /// <summary>
    /// Move caret to last position in document.
    /// </summary>
    procedure DocumentEnd();
    /// <summary>
    /// Move caret to last position in document extending selection to new caret position.
    /// </summary>
    procedure DocumentEndExtend();
    /// <summary>
    /// Move caret one page up.
    /// </summary>
    procedure PageUp();
    /// <summary>
    /// Move caret one page up extending selection to new caret position.
    /// </summary>
    procedure PageUpExtend();
    /// <summary>
    /// Move caret one page down.
    /// </summary>
    procedure PageDown();
    /// <summary>
    /// Move caret one page down extending selection to new caret position.
    /// </summary>
    procedure PageDownExtend();
    /// <summary>
    /// Switch from insert to overtype mode or the reverse.
    /// </summary>
    procedure EditToggleOvertype();
    /// <summary>
    /// Cancel any modes such as call tip or auto-completion list display.
    /// </summary>
    procedure Cancel();
    /// <summary>
    /// Delete the selection or if no selection, the character before the caret.
    /// </summary>
    procedure DeleteBack();
    /// <summary>
    /// If selection is empty or all on one line replace the selection with a tab character.
    /// If more than one line selected, indent the lines.
    /// </summary>
    procedure Tab();
    /// <summary>
    /// Indent the current and selected lines.
    /// </summary>
    procedure LineIndent();
    /// <summary>
    /// If selection is empty or all on one line dedent the line if caret is at start, else move caret.
    /// If more than one line selected, dedent the lines.
    /// </summary>
    procedure BackTab();
    /// <summary>
    /// Dedent the current and selected lines.
    /// </summary>
    procedure LineDedent();
    /// <summary>
    /// Insert a new line, may use a CRLF, CR or LF depending on EOL mode.
    /// </summary>
    procedure NewLine();
    /// <summary>
    /// Insert a Form Feed character.
    /// </summary>
    procedure FormFeed();
    /// <summary>
    /// Move caret to before first visible character on line.
    /// If already there move to first character on line.
    /// </summary>
    procedure VCHome();
    /// <summary>
    /// Like VCHome but extending selection to new caret position.
    /// </summary>
    procedure VCHomeExtend();
    /// <summary>
    /// Magnify the displayed text by increasing the sizes by 1 point.
    /// </summary>
    procedure ZoomIn();
    /// <summary>
    /// Make the displayed text smaller by decreasing the sizes by 1 point.
    /// </summary>
    procedure ZoomOut();
    /// <summary>
    /// Delete the word to the left of the caret.
    /// </summary>
    procedure DelWordLeft();
    /// <summary>
    /// Delete the word to the right of the caret.
    /// </summary>
    procedure DelWordRight();
    /// <summary>
    /// Delete the word to the right of the caret, but not the trailing non-word characters.
    /// </summary>
    procedure DelWordRightEnd();
    /// <summary>
    /// Cut the line containing the caret.
    /// </summary>
    procedure LineCut();
    /// <summary>
    /// Delete the line containing the caret.
    /// </summary>
    procedure LineDelete();
    /// <summary>
    /// Switch the current line with the previous.
    /// </summary>
    procedure LineTranspose();
    /// <summary>
    /// Reverse order of selected lines.
    /// </summary>
    procedure LineReverse();
    /// <summary>
    /// Duplicate the current line.
    /// </summary>
    procedure LineDuplicate();
    /// <summary>
    /// Transform the selection to lower case.
    /// </summary>
    procedure LowerCase();
    /// <summary>
    /// Transform the selection to upper case.
    /// </summary>
    procedure UpperCase();
    /// <summary>
    /// Scroll the document down, keeping the caret visible.
    /// </summary>
    procedure LineScrollDown();
    /// <summary>
    /// Scroll the document up, keeping the caret visible.
    /// </summary>
    procedure LineScrollUp();
    /// <summary>
    /// Delete the selection or if no selection, the character before the caret.
    /// Will not delete the character before at the start of a line.
    /// </summary>
    procedure DeleteBackNotLine();
    /// <summary>
    /// Move caret to first position on display line.
    /// </summary>
    procedure HomeDisplay();
    /// <summary>
    /// Move caret to first position on display line extending selection to
    /// new caret position.
    /// </summary>
    procedure HomeDisplayExtend();
    /// <summary>
    /// Move caret to last position on display line.
    /// </summary>
    procedure LineEndDisplay();
    /// <summary>
    /// Move caret to last position on display line extending selection to new
    /// caret position.
    /// </summary>
    procedure LineEndDisplayExtend();
    /// <summary>
    /// Like Home but when word-wrap is enabled goes first to start of display line
    /// HomeDisplay, then to start of document line Home.
    /// </summary>
    procedure HomeWrap();
    /// <summary>
    /// Like HomeExtend but when word-wrap is enabled extends first to start of display line
    /// HomeDisplayExtend, then to start of document line HomeExtend.
    /// </summary>
    procedure HomeWrapExtend();
    /// <summary>
    /// Like LineEnd but when word-wrap is enabled goes first to end of display line
    /// LineEndDisplay, then to start of document line LineEnd.
    /// </summary>
    procedure LineEndWrap();
    /// <summary>
    /// Like LineEndExtend but when word-wrap is enabled extends first to end of display line
    /// LineEndDisplayExtend, then to start of document line LineEndExtend.
    /// </summary>
    procedure LineEndWrapExtend();
    /// <summary>
    /// Like VCHome but when word-wrap is enabled goes first to start of display line
    /// VCHomeDisplay, then behaves like VCHome.
    /// </summary>
    procedure VCHomeWrap();
    /// <summary>
    /// Like VCHomeExtend but when word-wrap is enabled extends first to start of display line
    /// VCHomeDisplayExtend, then behaves like VCHomeExtend.
    /// </summary>
    procedure VCHomeWrapExtend();
    /// <summary>
    /// Copy the line containing the caret.
    /// </summary>
    procedure LineCopy();
    /// <summary>
    /// Move the caret inside current view if it's not there already.
    /// </summary>
    procedure MoveCaretInsideView();
    /// <summary>
    /// How many characters are on a line, including end of line characters?
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function LineLength(line: Integer): Integer;
    /// <summary>
    /// Highlight the characters at two positions.
    /// </summary>
    /// <param name="posA">
    /// Position in the document
    /// </param>
    /// <param name="posB">
    /// Position in the document
    /// </param>
    procedure BraceHighlight(posA: Integer; posB: Integer);
    /// <summary>
    /// Use specified indicator to highlight matching braces instead of changing their style.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    procedure BraceHighlightIndicator(useSetting: Boolean; indicator: Integer);
    /// <summary>
    /// Highlight the character at a position indicating there is no matching brace.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    procedure BraceBadLight(pos: Integer);
    /// <summary>
    /// Use specified indicator to highlight non matching brace instead of changing its style.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    procedure BraceBadLightIndicator(useSetting: Boolean; indicator: Integer);
    /// <summary>
    /// Find the position of a matching brace or INVALID_POSITION if no match.
    /// The maxReStyle must be 0 for now. It may be defined in a future release.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="maxReStyle">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function BraceMatch(pos: Integer; maxReStyle: Integer): Integer;
    /// <summary>
    /// Similar to BraceMatch, but matching starts at the explicit start position.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="startPos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function BraceMatchNext(pos: Integer; startPos: Integer): Integer;
    /// <summary>
    /// Are the end of line characters visible?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetViewEOL(): Boolean;
    /// <summary>
    /// Make the end of line characters visible or invisible.
    /// </summary>
    /// <param name="visible">
    /// Boolean value
    /// </param>
    procedure SetViewEOL(visible: Boolean);
    /// <summary>
    /// Retrieve a pointer to the document object.
    /// </summary>
    /// <returns>
    /// Returns the docpointer
    /// </returns>
    function GetDocPointer(): Pointer;
    /// <summary>
    /// Change the document object used.
    /// </summary>
    /// <param name="doc">
    /// The doc parameter
    /// </param>
    procedure SetDocPointer(doc: Pointer);
    /// <summary>
    /// Set which document modification events are sent to the container.
    /// </summary>
    /// <param name="eventMask">
    /// The eventMask parameter
    /// </param>
    procedure SetModEventMask(eventMask: Integer);
    /// <summary>
    /// Retrieve the column number which text should be kept within.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetEdgeColumn(): Integer;
    /// <summary>
    /// Set the column number of the edge.
    /// If text goes past the edge then it is highlighted.
    /// </summary>
    /// <param name="column">
    /// Position in the document
    /// </param>
    procedure SetEdgeColumn(column: Integer);
    /// <summary>
    /// Retrieve the edge highlight mode.
    /// </summary>
    /// <returns>
    /// Returns the edgemode
    /// </returns>
    function GetEdgeMode(): Integer;
    /// <summary>
    /// The edge may be displayed by a line (EDGE_LINE/EDGE_MULTILINE) or by highlighting text that
    /// goes beyond it (EDGE_BACKGROUND) or not displayed at all (EDGE_NONE).
    /// </summary>
    /// <param name="edgeMode">
    /// The edgeMode parameter
    /// </param>
    procedure SetEdgeMode(edgeMode: Integer);
    /// <summary>
    /// Retrieve the colour used in edge indication.
    /// </summary>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function GetEdgeColour(): TColor;
    /// <summary>
    /// Change the colour used in edge indication.
    /// </summary>
    /// <param name="edgeColour">
    /// Color value
    /// </param>
    procedure SetEdgeColour(edgeColour: TColor);
    /// <summary>
    /// Add a new vertical edge to the view.
    /// </summary>
    /// <param name="column">
    /// Position in the document
    /// </param>
    /// <param name="edgeColour">
    /// Color value
    /// </param>
    procedure MultiEdgeAddLine(column: Integer; edgeColour: TColor);
    /// <summary>
    /// Clear all vertical edges.
    /// </summary>
    procedure MultiEdgeClearAll();
    /// <summary>
    /// Get multi edge positions.
    /// </summary>
    /// <param name="which">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetMultiEdgeColumn(which: Integer): Integer;
    /// <summary>
    /// Sets the current caret position to be the search anchor.
    /// </summary>
    procedure SearchAnchor();
    /// <summary>
    /// Find some text starting at the search anchor.
    /// Does not ensure the selection is visible.
    /// </summary>
    /// <param name="searchFlags">
    /// The searchFlags parameter
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function SearchNext(searchFlags: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Find some text starting at the search anchor and moving backwards.
    /// Does not ensure the selection is visible.
    /// </summary>
    /// <param name="searchFlags">
    /// The searchFlags parameter
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function SearchPrev(searchFlags: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Retrieves the number of lines completely visible.
    /// </summary>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function LinesOnScreen(): Integer;
    /// <summary>
    /// Set whether a pop up menu is displayed automatically when the user presses
    /// the wrong mouse button on certain areas.
    /// </summary>
    /// <param name="popUpMode">
    /// The popUpMode parameter
    /// </param>
    procedure UsePopUp(popUpMode: Integer);
    /// <summary>
    /// Is the selection rectangular? The alternative is the more common stream selection.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function SelectionIsRectangle(): Boolean;
    /// <summary>
    /// Set the zoom level. This number of points is added to the size of all fonts.
    /// It may be positive to magnify or negative to reduce.
    /// </summary>
    /// <param name="zoomInPoints">
    /// Integer value
    /// </param>
    procedure SetZoom(zoomInPoints: Integer);
    /// <summary>
    /// Retrieve the zoom level.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetZoom(): Integer;
    /// <summary>
    /// Create a new document object.
    /// Starts with reference count of 1 and not selected into editor.
    /// </summary>
    /// <param name="bytes">
    /// Position in the document
    /// </param>
    /// <param name="documentOptions">
    /// The documentOptions parameter
    /// </param>
    /// <returns>
    /// Returns the result
    /// </returns>
    function CreateDocument(bytes: Integer; documentOptions: Integer): Pointer;
    /// <summary>
    /// Extend life of document.
    /// </summary>
    /// <param name="doc">
    /// The doc parameter
    /// </param>
    procedure AddRefDocument(doc: Pointer);
    /// <summary>
    /// Release a reference to the document, deleting document if it fades to black.
    /// </summary>
    /// <param name="doc">
    /// The doc parameter
    /// </param>
    procedure ReleaseDocument(doc: Pointer);
    /// <summary>
    /// Get which document options are set.
    /// </summary>
    /// <returns>
    /// Returns the documentoptions
    /// </returns>
    function GetDocumentOptions(): Integer;
    /// <summary>
    /// Get which document modification events are sent to the container.
    /// </summary>
    /// <returns>
    /// Returns the modeventmask
    /// </returns>
    function GetModEventMask(): Integer;
    /// <summary>
    /// Set whether command events are sent to the container.
    /// </summary>
    /// <param name="commandEvents">
    /// Boolean value
    /// </param>
    procedure SetCommandEvents(commandEvents: Boolean);
    /// <summary>
    /// Get whether command events are sent to the container.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetCommandEvents(): Boolean;
    /// <summary>
    /// Change internal focus flag.
    /// </summary>
    /// <param name="focus">
    /// Boolean value
    /// </param>
    procedure SetFocus(focus: Boolean);
    /// <summary>
    /// Get internal focus flag.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetFocus(): Boolean;
    /// <summary>
    /// Change error status - 0 = OK.
    /// </summary>
    /// <param name="status">
    /// The status parameter
    /// </param>
    procedure SetStatus(status: Integer);
    /// <summary>
    /// Get error status.
    /// </summary>
    /// <returns>
    /// Returns the status
    /// </returns>
    function GetStatus(): Integer;
    /// <summary>
    /// Set whether the mouse is captured when its button is pressed.
    /// </summary>
    /// <param name="captures">
    /// Boolean value
    /// </param>
    procedure SetMouseDownCaptures(captures: Boolean);
    /// <summary>
    /// Get whether mouse gets captured.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetMouseDownCaptures(): Boolean;
    /// <summary>
    /// Set whether the mouse wheel can be active outside the window.
    /// </summary>
    /// <param name="captures">
    /// Boolean value
    /// </param>
    procedure SetMouseWheelCaptures(captures: Boolean);
    /// <summary>
    /// Get whether mouse wheel can be active outside the window.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetMouseWheelCaptures(): Boolean;
    /// <summary>
    /// Sets the cursor to one of the SC_CURSOR* values.
    /// </summary>
    /// <param name="cursorType">
    /// The cursorType parameter
    /// </param>
    procedure SetCursor(cursorType: Integer);
    /// <summary>
    /// Get cursor type.
    /// </summary>
    /// <returns>
    /// Returns the cursor
    /// </returns>
    function GetCursor(): Integer;
    /// <summary>
    /// Change the way control characters are displayed:
    /// If symbol is < 32, keep the drawn way, else, use the given character.
    /// </summary>
    /// <param name="symbol">
    /// Integer value
    /// </param>
    procedure SetControlCharSymbol(symbol: Integer);
    /// <summary>
    /// Get the way control characters are displayed.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetControlCharSymbol(): Integer;
    /// <summary>
    /// Move to the previous change in capitalisation.
    /// </summary>
    procedure WordPartLeft();
    /// <summary>
    /// Move to the previous change in capitalisation extending selection
    /// to new caret position.
    /// </summary>
    procedure WordPartLeftExtend();
    /// <summary>
    /// Move to the change next in capitalisation.
    /// </summary>
    procedure WordPartRight();
    /// <summary>
    /// Move to the next change in capitalisation extending selection
    /// to new caret position.
    /// </summary>
    procedure WordPartRightExtend();
    /// <summary>
    /// Set the way the display area is determined when a particular line
    /// is to be moved to by Find, FindNext, GotoLine, etc.
    /// </summary>
    /// <param name="visiblePolicy">
    /// The visiblePolicy parameter
    /// </param>
    /// <param name="visibleSlop">
    /// Integer value
    /// </param>
    procedure SetVisiblePolicy(visiblePolicy: Integer; visibleSlop: Integer);
    /// <summary>
    /// Delete back from the current position to the start of the line.
    /// </summary>
    procedure DelLineLeft();
    /// <summary>
    /// Delete forwards from the current position to the end of the line.
    /// </summary>
    procedure DelLineRight();
    /// <summary>
    /// Set the xOffset (ie, horizontal scroll position).
    /// </summary>
    /// <param name="xOffset">
    /// Integer value
    /// </param>
    procedure SetXOffset(xOffset: Integer);
    /// <summary>
    /// Get the xOffset (ie, horizontal scroll position).
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetXOffset(): Integer;
    /// <summary>
    /// Set the last x chosen value to be the caret x position.
    /// </summary>
    procedure ChooseCaretX();
    /// <summary>
    /// Set the focus to this Scintilla widget.
    /// </summary>
    procedure GrabFocus();
    /// <summary>
    /// Set the way the caret is kept visible when going sideways.
    /// The exclusion zone is given in pixels.
    /// </summary>
    /// <param name="caretPolicy">
    /// The caretPolicy parameter
    /// </param>
    /// <param name="caretSlop">
    /// Integer value
    /// </param>
    procedure SetXCaretPolicy(caretPolicy: Integer; caretSlop: Integer);
    /// <summary>
    /// Set the way the line the caret is on is kept visible.
    /// The exclusion zone is given in lines.
    /// </summary>
    /// <param name="caretPolicy">
    /// The caretPolicy parameter
    /// </param>
    /// <param name="caretSlop">
    /// Integer value
    /// </param>
    procedure SetYCaretPolicy(caretPolicy: Integer; caretSlop: Integer);
    /// <summary>
    /// Set printing to line wrapped (SC_WRAP_WORD) or not line wrapped (SC_WRAP_NONE).
    /// </summary>
    /// <param name="wrapMode">
    /// The wrapMode parameter
    /// </param>
    procedure SetPrintWrapMode(wrapMode: Integer);
    /// <summary>
    /// Is printing line wrapped?
    /// </summary>
    /// <returns>
    /// Returns the printwrapmode
    /// </returns>
    function GetPrintWrapMode(): Integer;
    /// <summary>
    /// Set a fore colour for active hotspots.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure SetHotspotActiveFore(useSetting: Boolean; fore: TColor);
    /// <summary>
    /// Get the fore colour for active hotspots.
    /// </summary>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function GetHotspotActiveFore(): TColor;
    /// <summary>
    /// Set a back colour for active hotspots.
    /// </summary>
    /// <param name="useSetting">
    /// Boolean value
    /// </param>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure SetHotspotActiveBack(useSetting: Boolean; back: TColor);
    /// <summary>
    /// Get the back colour for active hotspots.
    /// </summary>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function GetHotspotActiveBack(): TColor;
    /// <summary>
    /// Enable / Disable underlining active hotspots.
    /// </summary>
    /// <param name="underline">
    /// Boolean value
    /// </param>
    procedure SetHotspotActiveUnderline(underline: Boolean);
    /// <summary>
    /// Get whether underlining for active hotspots.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetHotspotActiveUnderline(): Boolean;
    /// <summary>
    /// Limit hotspots to single line so hotspots on two lines don't merge.
    /// </summary>
    /// <param name="singleLine">
    /// Boolean value
    /// </param>
    procedure SetHotspotSingleLine(singleLine: Boolean);
    /// <summary>
    /// Get the HotspotSingleLine property
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetHotspotSingleLine(): Boolean;
    /// <summary>
    /// Move caret down one paragraph (delimited by empty lines).
    /// </summary>
    procedure ParaDown();
    /// <summary>
    /// Extend selection down one paragraph (delimited by empty lines).
    /// </summary>
    procedure ParaDownExtend();
    /// <summary>
    /// Move caret up one paragraph (delimited by empty lines).
    /// </summary>
    procedure ParaUp();
    /// <summary>
    /// Extend selection up one paragraph (delimited by empty lines).
    /// </summary>
    procedure ParaUpExtend();
    /// <summary>
    /// Given a valid document position, return the previous position taking code
    /// page into account. Returns 0 if passed 0.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function PositionBefore(pos: Integer): Integer;
    /// <summary>
    /// Given a valid document position, return the next position taking code
    /// page into account. Maximum value returned is the last position in the document.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function PositionAfter(pos: Integer): Integer;
    /// <summary>
    /// Given a valid document position, return a position that differs in a number
    /// of characters. Returned value is always between 0 and last position in document.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="relative">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function PositionRelative(pos: Integer; relative: Integer): Integer;
    /// <summary>
    /// Given a valid document position, return a position that differs in a number
    /// of UTF-16 code units. Returned value is always between 0 and last position in document.
    /// The result may point half way (2 bytes) inside a non-BMP character.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="relative">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function PositionRelativeCodeUnits(pos: Integer; relative: Integer): Integer;
    /// <summary>
    /// Copy a range of text to the clipboard. Positions are clipped into the document.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    procedure CopyRange(start: Integer; end: Integer);
    /// <summary>
    /// Copy argument text to the clipboard.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure CopyText(length: Integer; text: PAnsiChar);
    /// <summary>
    /// Set the selection mode to stream (SC_SEL_STREAM) or rectangular (SC_SEL_RECTANGLE/SC_SEL_THIN) or
    /// by lines (SC_SEL_LINES).
    /// </summary>
    /// <param name="selectionMode">
    /// The selectionMode parameter
    /// </param>
    procedure SetSelectionMode(selectionMode: Integer);
    /// <summary>
    /// Set the selection mode to stream (SC_SEL_STREAM) or rectangular (SC_SEL_RECTANGLE/SC_SEL_THIN) or
    /// by lines (SC_SEL_LINES) without changing MoveExtendsSelection.
    /// </summary>
    /// <param name="selectionMode">
    /// The selectionMode parameter
    /// </param>
    procedure ChangeSelectionMode(selectionMode: Integer);
    /// <summary>
    /// Get the mode of the current selection.
    /// </summary>
    /// <returns>
    /// Returns the selectionmode
    /// </returns>
    function GetSelectionMode(): Integer;
    /// <summary>
    /// Set whether or not regular caret moves will extend or reduce the selection.
    /// </summary>
    /// <param name="moveExtendsSelection">
    /// Boolean value
    /// </param>
    procedure SetMoveExtendsSelection(moveExtendsSelection: Boolean);
    /// <summary>
    /// Get whether or not regular caret moves will extend or reduce the selection.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetMoveExtendsSelection(): Boolean;
    /// <summary>
    /// Retrieve the position of the start of the selection at the given line (INVALID_POSITION if no selection on this line).
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetLineSelStartPosition(line: Integer): Integer;
    /// <summary>
    /// Retrieve the position of the end of the selection at the given line (INVALID_POSITION if no selection on this line).
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetLineSelEndPosition(line: Integer): Integer;
    /// <summary>
    /// Move caret down one line, extending rectangular selection to new caret position.
    /// </summary>
    procedure LineDownRectExtend();
    /// <summary>
    /// Move caret up one line, extending rectangular selection to new caret position.
    /// </summary>
    procedure LineUpRectExtend();
    /// <summary>
    /// Move caret left one character, extending rectangular selection to new caret position.
    /// </summary>
    procedure CharLeftRectExtend();
    /// <summary>
    /// Move caret right one character, extending rectangular selection to new caret position.
    /// </summary>
    procedure CharRightRectExtend();
    /// <summary>
    /// Move caret to first position on line, extending rectangular selection to new caret position.
    /// </summary>
    procedure HomeRectExtend();
    /// <summary>
    /// Move caret to before first visible character on line.
    /// If already there move to first character on line.
    /// In either case, extend rectangular selection to new caret position.
    /// </summary>
    procedure VCHomeRectExtend();
    /// <summary>
    /// Move caret to last position on line, extending rectangular selection to new caret position.
    /// </summary>
    procedure LineEndRectExtend();
    /// <summary>
    /// Move caret one page up, extending rectangular selection to new caret position.
    /// </summary>
    procedure PageUpRectExtend();
    /// <summary>
    /// Move caret one page down, extending rectangular selection to new caret position.
    /// </summary>
    procedure PageDownRectExtend();
    /// <summary>
    /// Move caret to top of page, or one page up if already at top of page.
    /// </summary>
    procedure StutteredPageUp();
    /// <summary>
    /// Move caret to top of page, or one page up if already at top of page, extending selection to new caret position.
    /// </summary>
    procedure StutteredPageUpExtend();
    /// <summary>
    /// Move caret to bottom of page, or one page down if already at bottom of page.
    /// </summary>
    procedure StutteredPageDown();
    /// <summary>
    /// Move caret to bottom of page, or one page down if already at bottom of page, extending selection to new caret position.
    /// </summary>
    procedure StutteredPageDownExtend();
    /// <summary>
    /// Move caret left one word, position cursor at end of word.
    /// </summary>
    procedure WordLeftEnd();
    /// <summary>
    /// Move caret left one word, position cursor at end of word, extending selection to new caret position.
    /// </summary>
    procedure WordLeftEndExtend();
    /// <summary>
    /// Move caret right one word, position cursor at end of word.
    /// </summary>
    procedure WordRightEnd();
    /// <summary>
    /// Move caret right one word, position cursor at end of word, extending selection to new caret position.
    /// </summary>
    procedure WordRightEndExtend();
    /// <summary>
    /// Set the set of characters making up whitespace for when moving or selecting by word.
    /// Should be called after SetWordChars.
    /// </summary>
    /// <param name="characters">
    /// Text string
    /// </param>
    procedure SetWhitespaceChars(characters: PAnsiChar);
    /// <summary>
    /// Get the set of characters making up whitespace for when moving or selecting by word.
    /// </summary>
    /// <param name="characters">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetWhitespaceChars(characters: PAnsiChar): Integer;
    /// <summary>
    /// Set the set of characters making up punctuation characters
    /// Should be called after SetWordChars.
    /// </summary>
    /// <param name="characters">
    /// Text string
    /// </param>
    procedure SetPunctuationChars(characters: PAnsiChar);
    /// <summary>
    /// Get the set of characters making up punctuation characters
    /// </summary>
    /// <param name="characters">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetPunctuationChars(characters: PAnsiChar): Integer;
    /// <summary>
    /// Reset the set of characters for whitespace and word characters to the defaults.
    /// </summary>
    procedure SetCharsDefault();
    /// <summary>
    /// Get currently selected item position in the auto-completion list
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AutoCGetCurrent(): Integer;
    /// <summary>
    /// Get currently selected item text in the auto-completion list
    /// Returns the length of the item text
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AutoCGetCurrentText(text: PAnsiChar): Integer;
    /// <summary>
    /// Set auto-completion case insensitive behaviour to either prefer case-sensitive matches or have no preference.
    /// </summary>
    /// <param name="behaviour">
    /// The behaviour parameter
    /// </param>
    procedure AutoCSetCaseInsensitiveBehaviour(behaviour: Integer);
    /// <summary>
    /// Get auto-completion case insensitive behaviour.
    /// </summary>
    /// <returns>
    /// Returns the value
    /// </returns>
    function AutoCGetCaseInsensitiveBehaviour(): Integer;
    /// <summary>
    /// Change the effect of autocompleting when there are multiple selections.
    /// </summary>
    /// <param name="multi">
    /// The multi parameter
    /// </param>
    procedure AutoCSetMulti(multi: Integer);
    /// <summary>
    /// Retrieve the effect of autocompleting when there are multiple selections.
    /// </summary>
    /// <returns>
    /// Returns the value
    /// </returns>
    function AutoCGetMulti(): Integer;
    /// <summary>
    /// Set the way autocompletion lists are ordered.
    /// </summary>
    /// <param name="order">
    /// The order parameter
    /// </param>
    procedure AutoCSetOrder(order: Integer);
    /// <summary>
    /// Get the way autocompletion lists are ordered.
    /// </summary>
    /// <returns>
    /// Returns the value
    /// </returns>
    function AutoCGetOrder(): Integer;
    /// <summary>
    /// Enlarge the document to a particular size of text bytes.
    /// </summary>
    /// <param name="bytes">
    /// Position in the document
    /// </param>
    procedure Allocate(bytes: Integer);
    /// <summary>
    /// Returns the target converted to UTF8.
    /// Return the length in bytes.
    /// </summary>
    /// <param name="s">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function TargetAsUTF8(s: PAnsiChar): Integer;
    /// <summary>
    /// Set the length of the utf8 argument for calling EncodedFromUTF8.
    /// Set to -1 and the string will be measured to the first nul.
    /// </summary>
    /// <param name="bytes">
    /// Position in the document
    /// </param>
    procedure SetLengthForEncode(bytes: Integer);
    /// <summary>
    /// Translates a UTF8 string into the document encoding.
    /// Return the length of the result in bytes.
    /// On error return 0.
    /// </summary>
    /// <param name="utf8">
    /// Text string
    /// </param>
    /// <param name="encoded">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function EncodedFromUTF8(utf8: PAnsiChar; encoded: PAnsiChar): Integer;
    /// <summary>
    /// Find the position of a column on a line taking into account tabs and
    /// multi-byte characters. If beyond end of line, return line end position.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="column">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function FindColumn(line: Integer; column: Integer): Integer;
    /// <summary>
    /// Can the caret preferred x position only be changed by explicit movement commands?
    /// </summary>
    /// <returns>
    /// Returns the caretsticky
    /// </returns>
    function GetCaretSticky(): Integer;
    /// <summary>
    /// Stop the caret preferred x position changing when the user types.
    /// </summary>
    /// <param name="useCaretStickyBehaviour">
    /// The useCaretStickyBehaviour parameter
    /// </param>
    procedure SetCaretSticky(useCaretStickyBehaviour: Integer);
    /// <summary>
    /// Switch between sticky and non-sticky: meant to be bound to a key.
    /// </summary>
    procedure ToggleCaretSticky();
    /// <summary>
    /// Enable/Disable convert-on-paste for line endings
    /// </summary>
    /// <param name="convert">
    /// Boolean value
    /// </param>
    procedure SetPasteConvertEndings(convert: Boolean);
    /// <summary>
    /// Get convert-on-paste setting
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetPasteConvertEndings(): Boolean;
    /// <summary>
    /// Replace the selection with text like a rectangular paste.
    /// </summary>
    /// <param name="length">
    /// Position in the document
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure ReplaceRectangular(length: Integer; text: PAnsiChar);
    /// <summary>
    /// Duplicate the selection. If selection empty duplicate the line containing the caret.
    /// </summary>
    procedure SelectionDuplicate();
    /// <summary>
    /// Set background alpha of the caret line.
    /// </summary>
    /// <param name="alpha">
    /// The alpha parameter
    /// </param>
    procedure SetCaretLineBackAlpha(alpha: Integer);
    /// <summary>
    /// Get the background alpha of the caret line.
    /// </summary>
    /// <returns>
    /// Returns the caretlinebackalpha
    /// </returns>
    function GetCaretLineBackAlpha(): Integer;
    /// <summary>
    /// Set the style of the caret to be drawn.
    /// </summary>
    /// <param name="caretStyle">
    /// The caretStyle parameter
    /// </param>
    procedure SetCaretStyle(caretStyle: Integer);
    /// <summary>
    /// Returns the current style of the caret.
    /// </summary>
    /// <returns>
    /// Returns the caretstyle
    /// </returns>
    function GetCaretStyle(): Integer;
    /// <summary>
    /// Set the indicator used for IndicatorFillRange and IndicatorClearRange
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    procedure SetIndicatorCurrent(indicator: Integer);
    /// <summary>
    /// Get the current indicator
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetIndicatorCurrent(): Integer;
    /// <summary>
    /// Set the value used for IndicatorFillRange
    /// </summary>
    /// <param name="value">
    /// Integer value
    /// </param>
    procedure SetIndicatorValue(value: Integer);
    /// <summary>
    /// Get the current indicator value
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetIndicatorValue(): Integer;
    /// <summary>
    /// Turn a indicator on over a range.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="lengthFill">
    /// Position in the document
    /// </param>
    procedure IndicatorFillRange(start: Integer; lengthFill: Integer);
    /// <summary>
    /// Turn a indicator off over a range.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="lengthClear">
    /// Position in the document
    /// </param>
    procedure IndicatorClearRange(start: Integer; lengthClear: Integer);
    /// <summary>
    /// Are any indicators present at pos?
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function IndicatorAllOnFor(pos: Integer): Integer;
    /// <summary>
    /// What value does a particular indicator have at a position?
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function IndicatorValueAt(indicator: Integer; pos: Integer): Integer;
    /// <summary>
    /// Where does a particular indicator start?
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function IndicatorStart(indicator: Integer; pos: Integer): Integer;
    /// <summary>
    /// Where does a particular indicator end?
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function IndicatorEnd(indicator: Integer; pos: Integer): Integer;
    /// <summary>
    /// Set number of entries in position cache
    /// </summary>
    /// <param name="size">
    /// Integer value
    /// </param>
    procedure SetPositionCache(size: Integer);
    /// <summary>
    /// How many entries are allocated to the position cache?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetPositionCache(): Integer;
    /// <summary>
    /// Set maximum number of threads used for layout
    /// </summary>
    /// <param name="threads">
    /// Integer value
    /// </param>
    procedure SetLayoutThreads(threads: Integer);
    /// <summary>
    /// Get maximum number of threads used for layout
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetLayoutThreads(): Integer;
    /// <summary>
    /// Copy the selection, if selection empty copy the line with the caret
    /// </summary>
    procedure CopyAllowLine();
    /// <summary>
    /// Cut the selection, if selection empty cut the line with the caret
    /// </summary>
    procedure CutAllowLine();
    /// <summary>
    /// Set the string to separate parts when copying a multiple selection.
    /// </summary>
    /// <param name="separator">
    /// Text string
    /// </param>
    procedure SetCopySeparator(separator: PAnsiChar);
    /// <summary>
    /// Get the string to separate parts when copying a multiple selection.
    /// </summary>
    /// <param name="separator">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetCopySeparator(separator: PAnsiChar): Integer;
    /// <summary>
    /// Compact the document buffer and return a read-only pointer to the
    /// characters in the document.
    /// </summary>
    /// <returns>
    /// Returns the characterpointer
    /// </returns>
    function GetCharacterPointer(): Pointer;
    /// <summary>
    /// Return a read-only pointer to a range of characters in the document.
    /// May move the gap so that the range is contiguous, but will only move up
    /// to lengthRange bytes.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="lengthRange">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the rangepointer
    /// </returns>
    function GetRangePointer(start: Integer; lengthRange: Integer): Pointer;
    /// <summary>
    /// Return a position which, to avoid performance costs, should not be within
    /// the range of a call to GetRangePointer.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetGapPosition(): Integer;
    /// <summary>
    /// Set the alpha fill colour of the given indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="alpha">
    /// The alpha parameter
    /// </param>
    procedure IndicSetAlpha(indicator: Integer; alpha: Integer);
    /// <summary>
    /// Get the alpha fill colour of the given indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function IndicGetAlpha(indicator: Integer): Integer;
    /// <summary>
    /// Set the alpha outline colour of the given indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <param name="alpha">
    /// The alpha parameter
    /// </param>
    procedure IndicSetOutlineAlpha(indicator: Integer; alpha: Integer);
    /// <summary>
    /// Get the alpha outline colour of the given indicator.
    /// </summary>
    /// <param name="indicator">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the value
    /// </returns>
    function IndicGetOutlineAlpha(indicator: Integer): Integer;
    /// <summary>
    /// Set extra ascent for each line
    /// </summary>
    /// <param name="extraAscent">
    /// Integer value
    /// </param>
    procedure SetExtraAscent(extraAscent: Integer);
    /// <summary>
    /// Get extra ascent for each line
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetExtraAscent(): Integer;
    /// <summary>
    /// Set extra descent for each line
    /// </summary>
    /// <param name="extraDescent">
    /// Integer value
    /// </param>
    procedure SetExtraDescent(extraDescent: Integer);
    /// <summary>
    /// Get extra descent for each line
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetExtraDescent(): Integer;
    /// <summary>
    /// Which symbol was defined for markerNumber with MarkerDefine
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the result
    /// </returns>
    function MarkerSymbolDefined(markerNumber: Integer): Integer;
    /// <summary>
    /// Set the text in the text margin for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure MarginSetText(line: Integer; text: PAnsiChar);
    /// <summary>
    /// Get the text in the text margin for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarginGetText(line: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Set the style number for the text margin for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure MarginSetStyle(line: Integer; style: Integer);
    /// <summary>
    /// Get the style number for the text margin for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarginGetStyle(line: Integer): Integer;
    /// <summary>
    /// Set the style in the text margin for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="styles">
    /// Text string
    /// </param>
    procedure MarginSetStyles(line: Integer; styles: PAnsiChar);
    /// <summary>
    /// Get the styles in the text margin for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="styles">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarginGetStyles(line: Integer; styles: PAnsiChar): Integer;
    /// <summary>
    /// Clear the margin text on all lines
    /// </summary>
    procedure MarginTextClearAll();
    /// <summary>
    /// Get the start of the range of style numbers used for margin text
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure MarginSetStyleOffset(style: Integer);
    /// <summary>
    /// Get the start of the range of style numbers used for margin text
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function MarginGetStyleOffset(): Integer;
    /// <summary>
    /// Set the margin options.
    /// </summary>
    /// <param name="marginOptions">
    /// The marginOptions parameter
    /// </param>
    procedure SetMarginOptions(marginOptions: Integer);
    /// <summary>
    /// Get the margin options.
    /// </summary>
    /// <returns>
    /// Returns the marginoptions
    /// </returns>
    function GetMarginOptions(): Integer;
    /// <summary>
    /// Set the annotation text for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure AnnotationSetText(line: Integer; text: PAnsiChar);
    /// <summary>
    /// Get the annotation text for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AnnotationGetText(line: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Set the style number for the annotations for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure AnnotationSetStyle(line: Integer; style: Integer);
    /// <summary>
    /// Get the style number for the annotations for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AnnotationGetStyle(line: Integer): Integer;
    /// <summary>
    /// Set the annotation styles for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="styles">
    /// Text string
    /// </param>
    procedure AnnotationSetStyles(line: Integer; styles: PAnsiChar);
    /// <summary>
    /// Get the annotation styles for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="styles">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AnnotationGetStyles(line: Integer; styles: PAnsiChar): Integer;
    /// <summary>
    /// Get the number of annotation lines for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AnnotationGetLines(line: Integer): Integer;
    /// <summary>
    /// Clear the annotations from all lines
    /// </summary>
    procedure AnnotationClearAll();
    /// <summary>
    /// Set the visibility for the annotations for a view
    /// </summary>
    /// <param name="visible">
    /// The visible parameter
    /// </param>
    procedure AnnotationSetVisible(visible: Integer);
    /// <summary>
    /// Get the visibility for the annotations for a view
    /// </summary>
    /// <returns>
    /// Returns the value
    /// </returns>
    function AnnotationGetVisible(): Integer;
    /// <summary>
    /// Get the start of the range of style numbers used for annotations
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure AnnotationSetStyleOffset(style: Integer);
    /// <summary>
    /// Get the start of the range of style numbers used for annotations
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AnnotationGetStyleOffset(): Integer;
    /// <summary>
    /// Release all extended (>255) style numbers
    /// </summary>
    procedure ReleaseAllExtendedStyles();
    /// <summary>
    /// Allocate some extended (>255) style numbers and return the start of the range
    /// </summary>
    /// <param name="numberStyles">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AllocateExtendedStyles(numberStyles: Integer): Integer;
    /// <summary>
    /// Add a container action to the undo stack
    /// </summary>
    /// <param name="token">
    /// Integer value
    /// </param>
    /// <param name="flags">
    /// The flags parameter
    /// </param>
    procedure AddUndoAction(token: Integer; flags: Integer);
    /// <summary>
    /// Find the position of a character from a point within the window.
    /// </summary>
    /// <param name="x">
    /// Integer value
    /// </param>
    /// <param name="y">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function CharPositionFromPoint(x: Integer; y: Integer): Integer;
    /// <summary>
    /// Find the position of a character from a point within the window.
    /// Return INVALID_POSITION if not close to text.
    /// </summary>
    /// <param name="x">
    /// Integer value
    /// </param>
    /// <param name="y">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function CharPositionFromPointClose(x: Integer; y: Integer): Integer;
    /// <summary>
    /// Set whether switching to rectangular mode while selecting with the mouse is allowed.
    /// </summary>
    /// <param name="mouseSelectionRectangularSwitch">
    /// Boolean value
    /// </param>
    procedure SetMouseSelectionRectangularSwitch(mouseSelectionRectangularSwitch: Boolean);
    /// <summary>
    /// Whether switching to rectangular mode while selecting with the mouse is allowed.
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetMouseSelectionRectangularSwitch(): Boolean;
    /// <summary>
    /// Set whether multiple selections can be made
    /// </summary>
    /// <param name="multipleSelection">
    /// Boolean value
    /// </param>
    procedure SetMultipleSelection(multipleSelection: Boolean);
    /// <summary>
    /// Whether multiple selections can be made
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetMultipleSelection(): Boolean;
    /// <summary>
    /// Set whether typing can be performed into multiple selections
    /// </summary>
    /// <param name="additionalSelectionTyping">
    /// Boolean value
    /// </param>
    procedure SetAdditionalSelectionTyping(additionalSelectionTyping: Boolean);
    /// <summary>
    /// Whether typing can be performed into multiple selections
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetAdditionalSelectionTyping(): Boolean;
    /// <summary>
    /// Set whether additional carets will blink
    /// </summary>
    /// <param name="additionalCaretsBlink">
    /// Boolean value
    /// </param>
    procedure SetAdditionalCaretsBlink(additionalCaretsBlink: Boolean);
    /// <summary>
    /// Whether additional carets will blink
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetAdditionalCaretsBlink(): Boolean;
    /// <summary>
    /// Set whether additional carets are visible
    /// </summary>
    /// <param name="additionalCaretsVisible">
    /// Boolean value
    /// </param>
    procedure SetAdditionalCaretsVisible(additionalCaretsVisible: Boolean);
    /// <summary>
    /// Whether additional carets are visible
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetAdditionalCaretsVisible(): Boolean;
    /// <summary>
    /// How many selections are there?
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetSelections(): Integer;
    /// <summary>
    /// Is every selected range empty?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetSelectionEmpty(): Boolean;
    /// <summary>
    /// Clear selections to a single empty stream selection
    /// </summary>
    procedure ClearSelections();
    /// <summary>
    /// Set a simple selection
    /// </summary>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    procedure SetSelection(caret: Integer; anchor: Integer);
    /// <summary>
    /// Add a selection
    /// </summary>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    procedure AddSelection(caret: Integer; anchor: Integer);
    /// <summary>
    /// Find the selection index for a point. -1 when not at a selection.
    /// </summary>
    /// <param name="x">
    /// Integer value
    /// </param>
    /// <param name="y">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function SelectionFromPoint(x: Integer; y: Integer): Integer;
    /// <summary>
    /// Drop one selection
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    procedure DropSelectionN(selection: Integer);
    /// <summary>
    /// Set the main selection
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    procedure SetMainSelection(selection: Integer);
    /// <summary>
    /// Which selection is the main selection
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetMainSelection(): Integer;
    /// <summary>
    /// Set the caret position of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure SetSelectionNCaret(selection: Integer; caret: Integer);
    /// <summary>
    /// Return the caret position of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNCaret(selection: Integer): Integer;
    /// <summary>
    /// Set the anchor position of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    procedure SetSelectionNAnchor(selection: Integer; anchor: Integer);
    /// <summary>
    /// Return the anchor position of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNAnchor(selection: Integer): Integer;
    /// <summary>
    /// Set the virtual space of the caret of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <param name="space">
    /// Position in the document
    /// </param>
    procedure SetSelectionNCaretVirtualSpace(selection: Integer; space: Integer);
    /// <summary>
    /// Return the virtual space of the caret of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNCaretVirtualSpace(selection: Integer): Integer;
    /// <summary>
    /// Set the virtual space of the anchor of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <param name="space">
    /// Position in the document
    /// </param>
    procedure SetSelectionNAnchorVirtualSpace(selection: Integer; space: Integer);
    /// <summary>
    /// Return the virtual space of the anchor of the nth selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNAnchorVirtualSpace(selection: Integer): Integer;
    /// <summary>
    /// Sets the position that starts the selection - this becomes the anchor.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    procedure SetSelectionNStart(selection: Integer; anchor: Integer);
    /// <summary>
    /// Returns the position at the start of the selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNStart(selection: Integer): Integer;
    /// <summary>
    /// Returns the virtual space at the start of the selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNStartVirtualSpace(selection: Integer): Integer;
    /// <summary>
    /// Sets the position that ends the selection - this becomes the currentPosition.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure SetSelectionNEnd(selection: Integer; caret: Integer);
    /// <summary>
    /// Returns the virtual space at the end of the selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNEndVirtualSpace(selection: Integer): Integer;
    /// <summary>
    /// Returns the position at the end of the selection.
    /// </summary>
    /// <param name="selection">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetSelectionNEnd(selection: Integer): Integer;
    /// <summary>
    /// Set the caret position of the rectangular selection.
    /// </summary>
    /// <param name="caret">
    /// Position in the document
    /// </param>
    procedure SetRectangularSelectionCaret(caret: Integer);
    /// <summary>
    /// Return the caret position of the rectangular selection.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetRectangularSelectionCaret(): Integer;
    /// <summary>
    /// Set the anchor position of the rectangular selection.
    /// </summary>
    /// <param name="anchor">
    /// Position in the document
    /// </param>
    procedure SetRectangularSelectionAnchor(anchor: Integer);
    /// <summary>
    /// Return the anchor position of the rectangular selection.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetRectangularSelectionAnchor(): Integer;
    /// <summary>
    /// Set the virtual space of the caret of the rectangular selection.
    /// </summary>
    /// <param name="space">
    /// Position in the document
    /// </param>
    procedure SetRectangularSelectionCaretVirtualSpace(space: Integer);
    /// <summary>
    /// Return the virtual space of the caret of the rectangular selection.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetRectangularSelectionCaretVirtualSpace(): Integer;
    /// <summary>
    /// Set the virtual space of the anchor of the rectangular selection.
    /// </summary>
    /// <param name="space">
    /// Position in the document
    /// </param>
    procedure SetRectangularSelectionAnchorVirtualSpace(space: Integer);
    /// <summary>
    /// Return the virtual space of the anchor of the rectangular selection.
    /// </summary>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function GetRectangularSelectionAnchorVirtualSpace(): Integer;
    /// <summary>
    /// Set options for virtual space behaviour.
    /// </summary>
    /// <param name="virtualSpaceOptions">
    /// The virtualSpaceOptions parameter
    /// </param>
    procedure SetVirtualSpaceOptions(virtualSpaceOptions: Integer);
    /// <summary>
    /// Return options for virtual space behaviour.
    /// </summary>
    /// <returns>
    /// Returns the virtualspaceoptions
    /// </returns>
    function GetVirtualSpaceOptions(): Integer;
    /// <summary>
    /// On GTK, allow selecting the modifier key to use for mouse-based
    /// rectangular selection. Often the window manager requires Alt+Mouse Drag
    /// for moving windows.
    /// Valid values are SCMOD_CTRL(default), SCMOD_ALT, or SCMOD_SUPER.
    /// </summary>
    /// <param name="modifier">
    /// Integer value
    /// </param>
    procedure SetRectangularSelectionModifier(modifier: Integer);
    /// <summary>
    /// Get the modifier key used for rectangular selection.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetRectangularSelectionModifier(): Integer;
    /// <summary>
    /// Set the foreground colour of additional selections.
    /// Must have previously called SetSelFore with non-zero first argument for this to have an effect.
    /// </summary>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure SetAdditionalSelFore(fore: TColor);
    /// <summary>
    /// Set the background colour of additional selections.
    /// Must have previously called SetSelBack with non-zero first argument for this to have an effect.
    /// </summary>
    /// <param name="back">
    /// Color value
    /// </param>
    procedure SetAdditionalSelBack(back: TColor);
    /// <summary>
    /// Set the alpha of the selection.
    /// </summary>
    /// <param name="alpha">
    /// The alpha parameter
    /// </param>
    procedure SetAdditionalSelAlpha(alpha: Integer);
    /// <summary>
    /// Get the alpha of the selection.
    /// </summary>
    /// <returns>
    /// Returns the additionalselalpha
    /// </returns>
    function GetAdditionalSelAlpha(): Integer;
    /// <summary>
    /// Set the foreground colour of additional carets.
    /// </summary>
    /// <param name="fore">
    /// Color value
    /// </param>
    procedure SetAdditionalCaretFore(fore: TColor);
    /// <summary>
    /// Get the foreground colour of additional carets.
    /// </summary>
    /// <returns>
    /// Returns the color value
    /// </returns>
    function GetAdditionalCaretFore(): TColor;
    /// <summary>
    /// Set the main selection to the next selection.
    /// </summary>
    procedure RotateSelection();
    /// <summary>
    /// Swap that caret and anchor of the main selection.
    /// </summary>
    procedure SwapMainAnchorCaret();
    /// <summary>
    /// Add the next occurrence of the main selection to the set of selections as main.
    /// If the current selection is empty then select word around caret.
    /// </summary>
    procedure MultipleSelectAddNext();
    /// <summary>
    /// Add each occurrence of the main selection in the target to the set of selections.
    /// If the current selection is empty then select word around caret.
    /// </summary>
    procedure MultipleSelectAddEach();
    /// <summary>
    /// Indicate that the internal state of a lexer has changed over a range and therefore
    /// there may be a need to redraw.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function ChangeLexerState(start: Integer; end: Integer): Integer;
    /// <summary>
    /// Find the next line at or after lineStart that is a contracted fold header line.
    /// Return -1 when no more lines.
    /// </summary>
    /// <param name="lineStart">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function ContractedFoldNext(lineStart: Integer): Integer;
    /// <summary>
    /// Centre current line in window.
    /// </summary>
    procedure VerticalCentreCaret();
    /// <summary>
    /// Move the selected lines up one line, shifting the line above after the selection
    /// </summary>
    procedure MoveSelectedLinesUp();
    /// <summary>
    /// Move the selected lines down one line, shifting the line below before the selection
    /// </summary>
    procedure MoveSelectedLinesDown();
    /// <summary>
    /// Set the identifier reported as idFrom in notification messages.
    /// </summary>
    /// <param name="identifier">
    /// Integer value
    /// </param>
    procedure SetIdentifier(identifier: Integer);
    /// <summary>
    /// Get the identifier.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetIdentifier(): Integer;
    /// <summary>
    /// Set the width for future RGBA image data.
    /// </summary>
    /// <param name="width">
    /// Integer value
    /// </param>
    procedure RGBAImageSetWidth(width: Integer);
    /// <summary>
    /// Set the height for future RGBA image data.
    /// </summary>
    /// <param name="height">
    /// Integer value
    /// </param>
    procedure RGBAImageSetHeight(height: Integer);
    /// <summary>
    /// Set the scale factor in percent for future RGBA image data.
    /// </summary>
    /// <param name="scalePercent">
    /// Integer value
    /// </param>
    procedure RGBAImageSetScale(scalePercent: Integer);
    /// <summary>
    /// Define a marker from RGBA data.
    /// It has the width and height from RGBAImageSetWidth/Height
    /// </summary>
    /// <param name="markerNumber">
    /// Integer value
    /// </param>
    /// <param name="pixels">
    /// Text string
    /// </param>
    procedure MarkerDefineRGBAImage(markerNumber: Integer; pixels: PAnsiChar);
    /// <summary>
    /// Register an RGBA image for use in autocompletion lists.
    /// It has the width and height from RGBAImageSetWidth/Height
    /// </summary>
    /// <param name="type">
    /// Integer value
    /// </param>
    /// <param name="pixels">
    /// Text string
    /// </param>
    procedure RegisterRGBAImage(type: Integer; pixels: PAnsiChar);
    /// <summary>
    /// Scroll to start of document.
    /// </summary>
    procedure ScrollToStart();
    /// <summary>
    /// Scroll to end of document.
    /// </summary>
    procedure ScrollToEnd();
    /// <summary>
    /// Set the technology used.
    /// </summary>
    /// <param name="technology">
    /// The technology parameter
    /// </param>
    procedure SetTechnology(technology: Integer);
    /// <summary>
    /// Get the tech.
    /// </summary>
    /// <returns>
    /// Returns the technology
    /// </returns>
    function GetTechnology(): Integer;
    /// <summary>
    /// Create an ILoader*.
    /// </summary>
    /// <param name="bytes">
    /// Position in the document
    /// </param>
    /// <param name="documentOptions">
    /// The documentOptions parameter
    /// </param>
    /// <returns>
    /// Returns the result
    /// </returns>
    function CreateLoader(bytes: Integer; documentOptions: Integer): Pointer;
    /// <summary>
    /// On macOS, show a find indicator.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    procedure FindIndicatorShow(start: Integer; end: Integer);
    /// <summary>
    /// On macOS, flash a find indicator, then fade out.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    procedure FindIndicatorFlash(start: Integer; end: Integer);
    /// <summary>
    /// On macOS, hide the find indicator.
    /// </summary>
    procedure FindIndicatorHide();
    /// <summary>
    /// Move caret to before first visible character on display line.
    /// If already there move to first character on display line.
    /// </summary>
    procedure VCHomeDisplay();
    /// <summary>
    /// Like VCHomeDisplay but extending selection to new caret position.
    /// </summary>
    procedure VCHomeDisplayExtend();
    /// <summary>
    /// Is the caret line always visible?
    /// </summary>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function GetCaretLineVisibleAlways(): Boolean;
    /// <summary>
    /// Sets the caret line to always visible.
    /// </summary>
    /// <param name="alwaysVisible">
    /// Boolean value
    /// </param>
    procedure SetCaretLineVisibleAlways(alwaysVisible: Boolean);
    /// <summary>
    /// Set the line end types that the application wants to use. May not be used if incompatible with lexer or encoding.
    /// </summary>
    /// <param name="lineEndBitSet">
    /// The lineEndBitSet parameter
    /// </param>
    procedure SetLineEndTypesAllowed(lineEndBitSet: Integer);
    /// <summary>
    /// Get the line end types currently allowed.
    /// </summary>
    /// <returns>
    /// Returns the lineendtypesallowed
    /// </returns>
    function GetLineEndTypesAllowed(): Integer;
    /// <summary>
    /// Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
    /// </summary>
    /// <returns>
    /// Returns the lineendtypesactive
    /// </returns>
    function GetLineEndTypesActive(): Integer;
    /// <summary>
    /// Set the way a character is drawn.
    /// </summary>
    /// <param name="encodedCharacter">
    /// Text string
    /// </param>
    /// <param name="representation">
    /// Text string
    /// </param>
    procedure SetRepresentation(encodedCharacter: PAnsiChar; representation: PAnsiChar);
    /// <summary>
    /// Get the way a character is drawn.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="encodedCharacter">
    /// Text string
    /// </param>
    /// <param name="representation">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetRepresentation(encodedCharacter: PAnsiChar; representation: PAnsiChar): Integer;
    /// <summary>
    /// Remove a character representation.
    /// </summary>
    /// <param name="encodedCharacter">
    /// Text string
    /// </param>
    procedure ClearRepresentation(encodedCharacter: PAnsiChar);
    /// <summary>
    /// Clear representations to default.
    /// </summary>
    procedure ClearAllRepresentations();
    /// <summary>
    /// Set the appearance of a representation.
    /// </summary>
    /// <param name="encodedCharacter">
    /// Text string
    /// </param>
    /// <param name="appearance">
    /// The appearance parameter
    /// </param>
    procedure SetRepresentationAppearance(encodedCharacter: PAnsiChar; appearance: Integer);
    /// <summary>
    /// Get the appearance of a representation.
    /// </summary>
    /// <param name="encodedCharacter">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the representationappearance
    /// </returns>
    function GetRepresentationAppearance(encodedCharacter: PAnsiChar): Integer;
    /// <summary>
    /// Set the colour of a representation.
    /// </summary>
    /// <param name="encodedCharacter">
    /// Text string
    /// </param>
    /// <param name="colour">
    /// The colour parameter
    /// </param>
    procedure SetRepresentationColour(encodedCharacter: PAnsiChar; colour: TColorAlpha);
    /// <summary>
    /// Get the colour of a representation.
    /// </summary>
    /// <param name="encodedCharacter">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the representationcolour
    /// </returns>
    function GetRepresentationColour(encodedCharacter: PAnsiChar): TColorAlpha;
    /// <summary>
    /// Set the end of line annotation text for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Text string
    /// </param>
    procedure EOLAnnotationSetText(line: Integer; text: PAnsiChar);
    /// <summary>
    /// Get the end of line annotation text for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="text">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function EOLAnnotationGetText(line: Integer; text: PAnsiChar): Integer;
    /// <summary>
    /// Set the style number for the end of line annotations for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure EOLAnnotationSetStyle(line: Integer; style: Integer);
    /// <summary>
    /// Get the style number for the end of line annotations for a line
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function EOLAnnotationGetStyle(line: Integer): Integer;
    /// <summary>
    /// Clear the end of annotations from all lines
    /// </summary>
    procedure EOLAnnotationClearAll();
    /// <summary>
    /// Set the visibility for the end of line annotations for a view
    /// </summary>
    /// <param name="visible">
    /// The visible parameter
    /// </param>
    procedure EOLAnnotationSetVisible(visible: Integer);
    /// <summary>
    /// Get the visibility for the end of line annotations for a view
    /// </summary>
    /// <returns>
    /// Returns the value
    /// </returns>
    function EOLAnnotationGetVisible(): Integer;
    /// <summary>
    /// Get the start of the range of style numbers used for end of line annotations
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    procedure EOLAnnotationSetStyleOffset(style: Integer);
    /// <summary>
    /// Get the start of the range of style numbers used for end of line annotations
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function EOLAnnotationGetStyleOffset(): Integer;
    /// <summary>
    /// Get whether a feature is supported
    /// </summary>
    /// <param name="feature">
    /// The feature parameter
    /// </param>
    /// <returns>
    /// Returns true if successful, false otherwise
    /// </returns>
    function SupportsFeature(feature: Integer): Boolean;
    /// <summary>
    /// Retrieve line character index state.
    /// </summary>
    /// <returns>
    /// Returns the linecharacterindex
    /// </returns>
    function GetLineCharacterIndex(): Integer;
    /// <summary>
    /// Request line character index be created or its use count increased.
    /// </summary>
    /// <param name="lineCharacterIndex">
    /// The lineCharacterIndex parameter
    /// </param>
    procedure AllocateLineCharacterIndex(lineCharacterIndex: Integer);
    /// <summary>
    /// Decrease use count of line character index and remove if 0.
    /// </summary>
    /// <param name="lineCharacterIndex">
    /// The lineCharacterIndex parameter
    /// </param>
    procedure ReleaseLineCharacterIndex(lineCharacterIndex: Integer);
    /// <summary>
    /// Retrieve the document line containing a position measured in index units.
    /// </summary>
    /// <param name="pos">
    /// Position in the document
    /// </param>
    /// <param name="lineCharacterIndex">
    /// The lineCharacterIndex parameter
    /// </param>
    /// <returns>
    /// Returns the line number
    /// </returns>
    function LineFromIndexPosition(pos: Integer; lineCharacterIndex: Integer): Integer;
    /// <summary>
    /// Retrieve the position measured in index units at the start of a document line.
    /// </summary>
    /// <param name="line">
    /// Line number
    /// </param>
    /// <param name="lineCharacterIndex">
    /// The lineCharacterIndex parameter
    /// </param>
    /// <returns>
    /// Returns the position in the document
    /// </returns>
    function IndexPositionFromLine(line: Integer; lineCharacterIndex: Integer): Integer;
    /// <summary>
    /// Start notifying the container of all key presses and commands.
    /// </summary>
    procedure StartRecord();
    /// <summary>
    /// Stop notifying the container of all key presses and commands.
    /// </summary>
    procedure StopRecord();
    /// <summary>
    /// Retrieve the lexing language of the document.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetLexer(): Integer;
    /// <summary>
    /// Colourise a segment of the document using the current lexing language.
    /// </summary>
    /// <param name="start">
    /// Position in the document
    /// </param>
    /// <param name="end">
    /// Position in the document
    /// </param>
    procedure Colourise(start: Integer; end: Integer);
    /// <summary>
    /// Set up a value that may be used by a lexer for some optional feature.
    /// </summary>
    /// <param name="key">
    /// Text string
    /// </param>
    /// <param name="value">
    /// Text string
    /// </param>
    procedure SetProperty(key: PAnsiChar; value: PAnsiChar);
    /// <summary>
    /// Set up the key words used by the lexer.
    /// </summary>
    /// <param name="keyWordSet">
    /// Integer value
    /// </param>
    /// <param name="keyWords">
    /// Text string
    /// </param>
    procedure SetKeyWords(keyWordSet: Integer; keyWords: PAnsiChar);
    /// <summary>
    /// Retrieve a "property" value previously set with SetProperty.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="key">
    /// Text string
    /// </param>
    /// <param name="value">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetProperty(key: PAnsiChar; value: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve a "property" value previously set with SetProperty,
    /// with "$()" variable replacement on returned buffer.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="key">
    /// Text string
    /// </param>
    /// <param name="value">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetPropertyExpanded(key: PAnsiChar; value: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve a "property" value previously set with SetProperty,
    /// interpreted as an int AFTER any "$()" variable replacement.
    /// </summary>
    /// <param name="key">
    /// Text string
    /// </param>
    /// <param name="defaultValue">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetPropertyInt(key: PAnsiChar; defaultValue: Integer): Integer;
    /// <summary>
    /// Retrieve the name of the lexer.
    /// Return the length of the text.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="language">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetLexerLanguage(language: PAnsiChar): Integer;
    /// <summary>
    /// For private communication between an application and a known lexer.
    /// </summary>
    /// <param name="operation">
    /// Integer value
    /// </param>
    /// <param name="pointer">
    /// The pointer parameter
    /// </param>
    /// <returns>
    /// Returns the result
    /// </returns>
    function PrivateLexerCall(operation: Integer; pointer: Pointer): Pointer;
    /// <summary>
    /// Retrieve a '\n' separated list of properties understood by the current lexer.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="names">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function PropertyNames(names: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve the type of a property.
    /// </summary>
    /// <param name="name">
    /// Text string
    /// </param>
    /// <returns>
    /// Returns the result
    /// </returns>
    function PropertyType(name: PAnsiChar): Integer;
    /// <summary>
    /// Describe a property.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="name">
    /// Text string
    /// </param>
    /// <param name="description">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function DescribeProperty(name: PAnsiChar; description: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve a '\n' separated list of descriptions of the keyword sets understood by the current lexer.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="descriptions">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function DescribeKeyWordSets(descriptions: PAnsiChar): Integer;
    /// <summary>
    /// Bit set of LineEndType enumertion for which line ends beyond the standard
    /// LF, CR, and CRLF are supported by the lexer.
    /// </summary>
    /// <returns>
    /// Returns the lineendtypessupported
    /// </returns>
    function GetLineEndTypesSupported(): Integer;
    /// <summary>
    /// Allocate a set of sub styles for a particular base style, returning start of range
    /// </summary>
    /// <param name="styleBase">
    /// Integer value
    /// </param>
    /// <param name="numberStyles">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function AllocateSubStyles(styleBase: Integer; numberStyles: Integer): Integer;
    /// <summary>
    /// The starting style number for the sub styles associated with a base style
    /// </summary>
    /// <param name="styleBase">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetSubStylesStart(styleBase: Integer): Integer;
    /// <summary>
    /// The number of sub styles associated with a base style
    /// </summary>
    /// <param name="styleBase">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetSubStylesLength(styleBase: Integer): Integer;
    /// <summary>
    /// For a sub style, return the base style, else return the argument.
    /// </summary>
    /// <param name="subStyle">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetStyleFromSubStyle(subStyle: Integer): Integer;
    /// <summary>
    /// For a secondary style, return the primary style, else return the argument.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetPrimaryStyleFromStyle(style: Integer): Integer;
    /// <summary>
    /// Free allocated sub styles
    /// </summary>
    procedure FreeSubStyles();
    /// <summary>
    /// Set the identifiers that are shown in a particular style
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="identifiers">
    /// Text string
    /// </param>
    procedure SetIdentifiers(style: Integer; identifiers: PAnsiChar);
    /// <summary>
    /// Where styles are duplicated by a feature such as active/inactive code
    /// return the distance between the two types.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function DistanceToSecondaryStyles(): Integer;
    /// <summary>
    /// Get the set of base styles that can be extended with sub styles
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="styles">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetSubStyleBases(styles: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve the number of named styles for the lexer.
    /// </summary>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function GetNamedStyles(): Integer;
    /// <summary>
    /// Retrieve the name of a style.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="name">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function NameOfStyle(style: Integer; name: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve a ' ' separated list of style tags like "literal quoted string".
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="tags">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function TagsOfStyle(style: Integer; tags: PAnsiChar): Integer;
    /// <summary>
    /// Retrieve a description of a style.
    /// Result is NUL-terminated.
    /// </summary>
    /// <param name="style">
    /// Integer value
    /// </param>
    /// <param name="description">
    /// Buffer to receive the result
    /// </param>
    /// <returns>
    /// Returns the requested value
    /// </returns>
    function DescriptionOfStyle(style: Integer; description: PAnsiChar): Integer;
    /// <summary>
    /// Set the lexer from an ILexer*.
    /// </summary>
    /// <param name="ilexer">
    /// The ilexer parameter
    /// </param>
    procedure SetILexer(ilexer: Pointer);

    // Provisional
    /// <summary>
    /// Retrieve bidirectional text display state.
    /// </summary>
    /// <returns>
    /// Returns the bidirectional
    /// </returns>
    function GetBidirectional(): Integer;
    /// <summary>
    /// Set bidirectional text display state.
    /// </summary>
    /// <param name="bidirectional">
    /// The bidirectional parameter
    /// </param>
    procedure SetBidirectional(bidirectional: Integer);

  published
    // Auto-generated properties
    /// <summary>
    /// Retrieve the current tab draw mode.
    /// Returns one of SCTD_* constants.
    /// </summary>
    property TabDrawMode: Integer read GetTabDrawMode write SetTabDrawMode;
    /// <summary>
    /// Is printing line wrapped?
    /// </summary>
    property PrintWrapMode: Integer read GetPrintWrapMode write SetPrintWrapMode;
    /// <summary>
    /// Retrieve the caret line frame width.
    /// Width = 0 means this option is disabled.
    /// </summary>
    property CaretLineFrame: Integer read GetCaretLineFrame write SetCaretLineFrame;
    /// <summary>
    /// Which action is the save point?
    /// </summary>
    property UndoSavePoint: Integer read GetUndoSavePoint write SetUndoSavePoint;
    /// <summary>
    /// Returns the number of bytes in the document.
    /// </summary>
    property Length: Integer read GetLength;
    /// <summary>
    /// Get the size of the dots used to mark space characters.
    /// </summary>
    property WhitespaceSize: Integer read GetWhitespaceSize write SetWhitespaceSize;
    /// <summary>
    /// Get the code page used to interpret the bytes of the document as characters.
    /// </summary>
    property CodePage: Integer read GetCodePage write SetCodePage;
    /// <summary>
    /// In read-only mode?
    /// </summary>
    property ReadOnly: Boolean read GetReadOnly write SetReadOnly;
    /// <summary>
    /// Retrieve the visible size of a tab.
    /// </summary>
    property TabWidth: Integer read GetTabWidth write SetTabWidth;
    /// <summary>
    /// Retrieve the colour used in edge indication.
    /// </summary>
    property EdgeColour: TColor read GetEdgeColour write SetEdgeColour;
    /// <summary>
    /// Is every selected range empty?
    /// </summary>
    property SelectionEmpty: Boolean read GetSelectionEmpty;
    /// <summary>
    /// Retrive the start indent for wrapped lines.
    /// </summary>
    property WrapStartIndent: Integer read GetWrapStartIndent write SetWrapStartIndent;
    /// <summary>
    /// How many undo actions are in the history?
    /// </summary>
    property UndoActions: Integer read GetUndoActions;
    /// <summary>
    /// How many entries are allocated to the position cache?
    /// </summary>
    property PositionCache: Integer read GetPositionCache write SetPositionCache;
    /// <summary>
    /// Retrieve whether the maximum scroll position has the last
    /// line at the bottom of the view.
    /// </summary>
    property EndAtLastLine: Boolean read GetEndAtLastLine write SetEndAtLastLine;
    /// <summary>
    /// Which action is the tentative point?
    /// </summary>
    property UndoTentative: Integer read GetUndoTentative write SetUndoTentative;
    /// <summary>
    /// Retrieve whether tabs will be used in indentation.
    /// </summary>
    property UseTabs: Boolean read GetUseTabs write SetUseTabs;
    /// <summary>
    /// Get whether mouse gets captured.
    /// </summary>
    property MouseDownCaptures: Boolean read GetMouseDownCaptures write SetMouseDownCaptures;
    /// <summary>
    /// Retrieve a pointer to a function that processes messages for this Scintilla and returns status.
    /// </summary>
    property DirectStatusFunction: Pointer read GetDirectStatusFunction;
    /// <summary>
    /// Get the xOffset (ie, horizontal scroll position).
    /// </summary>
    property XOffset: Integer read GetXOffset write SetXOffset;
    /// <summary>
    /// Get the alpha of the selection.
    /// </summary>
    property SelAlpha: Integer read GetSelAlpha write SetSelAlpha;
    /// <summary>
    /// Get the identifier.
    /// </summary>
    property Identifier: Integer read GetIdentifier write SetIdentifier;
    /// <summary>
    /// Which action is the current point?
    /// </summary>
    property UndoCurrent: Integer read GetUndoCurrent write SetUndoCurrent;
    /// <summary>
    /// Get the number of characters to have directly indexed categories
    /// </summary>
    property CharacterCategoryOptimization: Integer read GetCharacterCategoryOptimization write SetCharacterCategoryOptimization;
    /// <summary>
    /// Is the IME displayed in a window or inline?
    /// </summary>
    property IMEInteraction: Integer read GetIMEInteraction write SetIMEInteraction;
    /// <summary>
    /// Retrieve the time the mouse must sit still to generate a mouse dwell event.
    /// </summary>
    property MouseDwellTime: Integer read GetMouseDwellTime write SetMouseDwellTime;
    /// <summary>
    /// Get the layer of the background of the line containing the caret.
    /// </summary>
    property CaretLineLayer: Integer read GetCaretLineLayer write SetCaretLineLayer;
    /// <summary>
    /// Is an undo sequence active?
    /// </summary>
    property UndoSequence: Integer read GetUndoSequence;
    /// <summary>
    /// Returns the size in pixels of the right margin.
    /// </summary>
    property MarginRight: Integer read GetMarginRight write SetMarginRight;
    /// <summary>
    /// Get cursor type.
    /// </summary>
    property Cursor: Integer read GetCursor write SetCursor;
    /// <summary>
    /// Get automatic folding behaviours.
    /// </summary>
    property AutomaticFold: Integer read GetAutomaticFold write SetAutomaticFold;
    /// <summary>
    /// Retrieve the quality level for text.
    /// </summary>
    property FontQuality: Integer read GetFontQuality write SetFontQuality;
    /// <summary>
    /// Return the virtual space of the anchor of the rectangular selection.
    /// </summary>
    property RectangularSelectionAnchorVirtualSpace: Integer read GetRectangularSelectionAnchorVirtualSpace write SetRectangularSelectionAnchorVirtualSpace;
    /// <summary>
    /// Get the tech.
    /// </summary>
    property Technology: Integer read GetTechnology write SetTechnology;
    /// <summary>
    /// Report change history status.
    /// </summary>
    property ChangeHistory: Integer read GetChangeHistory write SetChangeHistory;
    /// <summary>
    /// Retrieve the current end of line mode - one of CRLF, CR, or LF.
    /// </summary>
    property EOLMode: Integer read GetEOLMode write SetEOLMode;
    /// <summary>
    /// Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
    /// </summary>
    property LineEndTypesActive: Integer read GetLineEndTypesActive;
    /// <summary>
    /// Get convert-on-paste setting
    /// </summary>
    property PasteConvertEndings: Boolean read GetPasteConvertEndings write SetPasteConvertEndings;
    /// <summary>
    /// Retrieve the zoom level.
    /// </summary>
    property Zoom: Integer read GetZoom write SetZoom;
    /// <summary>
    /// Get the virtual space of the target start
    /// </summary>
    property TargetStartVirtualSpace: Integer read GetTargetStartVirtualSpace write SetTargetStartVirtualSpace;
    /// <summary>
    /// Retrieve the lexing language of the document.
    /// </summary>
    property Lexer: Integer read GetLexer;
    /// <summary>
    /// Get internal focus flag.
    /// </summary>
    property Focus: Boolean read GetFocus write SetFocus;
    /// <summary>
    /// Retrieve the degree of caching of layout information.
    /// </summary>
    property LayoutCache: Integer read GetLayoutCache write SetLayoutCache;
    /// <summary>
    /// Are all lines visible?
    /// </summary>
    property AllLinesVisible: Boolean read GetAllLinesVisible;
    /// <summary>
    /// Retrieve a pointer to a function that processes messages for this Scintilla.
    /// </summary>
    property DirectFunction: Pointer read GetDirectFunction;
    /// <summary>
    /// Are white space characters currently visible?
    /// Returns one of SCWS_* constants.
    /// </summary>
    property ViewWS: Integer read GetViewWS write SetViewWS;
    /// <summary>
    /// Retrieve the number of named styles for the lexer.
    /// </summary>
    property NamedStyles: Integer read GetNamedStyles;
    /// <summary>
    /// Get the fore colour for active hotspots.
    /// </summary>
    property HotspotActiveFore: TColor read GetHotspotActiveFore write SetHotspotActiveFore;
    /// <summary>
    /// Retrieve the edge highlight mode.
    /// </summary>
    property EdgeMode: Integer read GetEdgeMode write SetEdgeMode;
    /// <summary>
    /// Which selection is the main selection
    /// </summary>
    property MainSelection: Integer read GetMainSelection write SetMainSelection;
    /// <summary>
    /// Return options for virtual space behaviour.
    /// </summary>
    property VirtualSpaceOptions: Integer read GetVirtualSpaceOptions write SetVirtualSpaceOptions;
    /// <summary>
    /// Get the time in milliseconds that the caret is on and off.
    /// </summary>
    property CaretPeriod: Integer read GetCaretPeriod write SetCaretPeriod;
    /// <summary>
    /// Get the way control characters are displayed.
    /// </summary>
    property ControlCharSymbol: Integer read GetControlCharSymbol write SetControlCharSymbol;
    /// <summary>
    /// Is the document different from when it was last saved?
    /// </summary>
    property Modify: Boolean read GetModify;
    /// <summary>
    /// Get the search flags used by SearchInTarget.
    /// </summary>
    property SearchFlags: Integer read GetSearchFlags write SetSearchFlags;
    /// <summary>
    /// Retrieve the last line number that has line state.
    /// </summary>
    property MaxLineState: Integer read GetMaxLineState;
    /// <summary>
    /// Get the minimum visual width of a tab.
    /// </summary>
    property TabMinimumWidth: Integer read GetTabMinimumWidth write SetTabMinimumWidth;
    /// <summary>
    /// Returns the position at the end of the selection.
    /// </summary>
    property SelectionEnd: Integer read GetSelectionEnd write SetSelectionEnd;
    /// <summary>
    /// Whether typing can be performed into multiple selections
    /// </summary>
    property AdditionalSelectionTyping: Boolean read GetAdditionalSelectionTyping write SetAdditionalSelectionTyping;
    /// <summary>
    /// Get the layer for drawing selections
    /// </summary>
    property SelectionLayer: Integer read GetSelectionLayer write SetSelectionLayer;
    /// <summary>
    /// Return the caret position of the rectangular selection.
    /// </summary>
    property RectangularSelectionCaret: Integer read GetRectangularSelectionCaret write SetRectangularSelectionCaret;
    /// <summary>
    /// Get only highlighting subline instead of whole line.
    /// </summary>
    property CaretLineHighlightSubLine: Boolean read GetCaretLineHighlightSubLine write SetCaretLineHighlightSubLine;
    /// <summary>
    /// Get error status.
    /// </summary>
    property Status: Integer read GetStatus write SetStatus;
    /// <summary>
    /// Returns the position of the opposite end of the selection to the caret.
    /// </summary>
    property Anchor: Integer read GetAnchor write SetAnchor;
    /// <summary>
    /// How many phases is drawing done in?
    /// </summary>
    property PhasesDraw: Integer read GetPhasesDraw write SetPhasesDraw;
    /// <summary>
    /// Get whether or not regular caret moves will extend or reduce the selection.
    /// </summary>
    property MoveExtendsSelection: Boolean read GetMoveExtendsSelection write SetMoveExtendsSelection;
    /// <summary>
    /// Retrieve the limits to idle styling.
    /// </summary>
    property IdleStyling: Integer read GetIdleStyling write SetIdleStyling;
    /// <summary>
    /// Retrieve how wrapped sublines are placed. Default is fixed.
    /// </summary>
    property WrapIndentMode: Integer read GetWrapIndentMode write SetWrapIndentMode;
    /// <summary>
    /// Is the vertical scroll bar visible?
    /// </summary>
    property VScrollBar: Boolean read GetVScrollBar write SetVScrollBar;
    /// <summary>
    /// How many selections are there?
    /// </summary>
    property Selections: Integer read GetSelections;
    /// <summary>
    /// Returns the position at the start of the selection.
    /// </summary>
    property SelectionStart: Integer read GetSelectionStart write SetSelectionStart;
    /// <summary>
    /// Report undo selection history status.
    /// </summary>
    property UndoSelectionHistory: Integer read GetUndoSelectionHistory write SetUndoSelectionHistory;
    /// <summary>
    /// Retrieve the display line at the top of the display.
    /// </summary>
    property FirstVisibleLine: Integer read GetFirstVisibleLine write SetFirstVisibleLine;
    /// <summary>
    /// Retrieve whether text is word wrapped.
    /// </summary>
    property WrapMode: Integer read GetWrapMode write SetWrapMode;
    /// <summary>
    /// Return a position which, to avoid performance costs, should not be within
    /// the range of a call to GetRangePointer.
    /// </summary>
    property GapPosition: Integer read GetGapPosition;
    /// <summary>
    /// Is the background of the line containing the caret in a different colour?
    /// </summary>
    property CaretLineVisible: Boolean read GetCaretLineVisible write SetCaretLineVisible;
    /// <summary>
    /// Retrieve a pointer value to use as the first argument when calling
    /// the function returned by GetDirectFunction.
    /// </summary>
    property DirectPointer: Pointer read GetDirectPointer;
    /// <summary>
    /// Get the foreground colour of additional carets.
    /// </summary>
    property AdditionalCaretFore: TColor read GetAdditionalCaretFore write SetAdditionalCaretFore;
    /// <summary>
    /// Get the background alpha of the caret line.
    /// </summary>
    property CaretLineBackAlpha: Integer read GetCaretLineBackAlpha write SetCaretLineBackAlpha;
    /// <summary>
    /// Get whether mouse wheel can be active outside the window.
    /// </summary>
    property MouseWheelCaptures: Boolean read GetMouseWheelCaptures write SetMouseWheelCaptures;
    /// <summary>
    /// Get the HotspotSingleLine property
    /// </summary>
    property HotspotSingleLine: Boolean read GetHotspotSingleLine write SetHotspotSingleLine;
    /// <summary>
    /// Returns the current style of the caret.
    /// </summary>
    property CaretStyle: Integer read GetCaretStyle write SetCaretStyle;
    /// <summary>
    /// Get maximum number of threads used for layout
    /// </summary>
    property LayoutThreads: Integer read GetLayoutThreads write SetLayoutThreads;
    /// <summary>
    /// Retrieve indentation size.
    /// </summary>
    property Indent: Integer read GetIndent write SetIndent;
    /// <summary>
    /// Get extra descent for each line
    /// </summary>
    property ExtraDescent: Integer read GetExtraDescent write SetExtraDescent;
    /// <summary>
    /// Is drawing done first into a buffer or direct to the screen?
    /// </summary>
    property BufferedDraw: Boolean read GetBufferedDraw write SetBufferedDraw;
    /// <summary>
    /// Get the mode of the current selection.
    /// </summary>
    property SelectionMode: Integer read GetSelectionMode write SetSelectionMode;
    /// <summary>
    /// Retrieve the document width assumed for scrolling.
    /// </summary>
    property ScrollWidth: Integer read GetScrollWidth write SetScrollWidth;
    /// <summary>
    /// Get the modifier key used for rectangular selection.
    /// </summary>
    property RectangularSelectionModifier: Integer read GetRectangularSelectionModifier write SetRectangularSelectionModifier;
    /// <summary>
    /// Retrieve the position of the last correctly styled character.
    /// </summary>
    property EndStyled: Integer read GetEndStyled;
    /// <summary>
    /// Is the selection end of line filled?
    /// </summary>
    property SelEOLFilled: Boolean read GetSelEOLFilled write SetSelEOLFilled;
    /// <summary>
    /// Get the colour of the background of the line containing the caret.
    /// </summary>
    property CaretLineBack: TColor read GetCaretLineBack write SetCaretLineBack;
    /// <summary>
    /// Bit set of LineEndType enumertion for which line ends beyond the standard
    /// LF, CR, and CRLF are supported by the lexer.
    /// </summary>
    property LineEndTypesSupported: Integer read GetLineEndTypesSupported;
    /// <summary>
    /// Get whether command events are sent to the container.
    /// </summary>
    property CommandEvents: Boolean read GetCommandEvents write SetCommandEvents;
    /// <summary>
    /// Get the current indicator
    /// </summary>
    property IndicatorCurrent: Integer read GetIndicatorCurrent write SetIndicatorCurrent;
    property SelectionHidden: Boolean read GetSelectionHidden;
    /// <summary>
    /// Returns the number of lines in the document. There is always at least one.
    /// </summary>
    property LineCount: Integer read GetLineCount;
    /// <summary>
    /// Retrieve the effect of pasting when there are multiple selections.
    /// </summary>
    property MultiPaste: Integer read GetMultiPaste write SetMultiPaste;
    /// <summary>
    /// Report accessibility status.
    /// </summary>
    property Accessibility: Integer read GetAccessibility write SetAccessibility;
    /// <summary>
    /// Is undo history being collected?
    /// </summary>
    property UndoCollection: Boolean read GetUndoCollection write SetUndoCollection;
    /// <summary>
    /// Get the line end types currently allowed.
    /// </summary>
    property LineEndTypesAllowed: Integer read GetLineEndTypesAllowed write SetLineEndTypesAllowed;
    /// <summary>
    /// Get the foreground colour of the caret.
    /// </summary>
    property CaretFore: TColor read GetCaretFore write SetCaretFore;
    /// <summary>
    /// Get the margin options.
    /// </summary>
    property MarginOptions: Integer read GetMarginOptions write SetMarginOptions;
    /// <summary>
    /// Whether switching to rectangular mode while selecting with the mouse is allowed.
    /// </summary>
    property MouseSelectionRectangularSwitch: Boolean read GetMouseSelectionRectangularSwitch write SetMouseSelectionRectangularSwitch;
    /// <summary>
    /// Get which document modification events are sent to the container.
    /// </summary>
    property ModEventMask: Integer read GetModEventMask write SetModEventMask;
    /// <summary>
    /// Retrieve a pointer to the document object.
    /// </summary>
    property DocPointer: Pointer read GetDocPointer write SetDocPointer;
    /// <summary>
    /// How many margins are there?.
    /// </summary>
    property Margins: Integer read GetMargins write SetMargins;
    /// <summary>
    /// Get the back colour for active hotspots.
    /// </summary>
    property HotspotActiveBack: TColor read GetHotspotActiveBack write SetHotspotActiveBack;
    /// <summary>
    /// Retrieve the number of characters in the document.
    /// </summary>
    property TextLength: Integer read GetTextLength;
    /// <summary>
    /// Get the position that ends the target.
    /// </summary>
    property TargetEnd: Integer read GetTargetEnd write SetTargetEnd;
    /// <summary>
    /// Get the virtual space of the target end
    /// </summary>
    property TargetEndVirtualSpace: Integer read GetTargetEndVirtualSpace write SetTargetEndVirtualSpace;
    /// <summary>
    /// Does a backspace pressed when caret is within indentation unindent?
    /// </summary>
    property BackSpaceUnIndents: Boolean read GetBackSpaceUnIndents write SetBackSpaceUnIndents;
    /// <summary>
    /// Returns the position of the caret.
    /// </summary>
    property CurrentPos: Integer read GetCurrentPos write SetCurrentPos;
    /// <summary>
    /// Compact the document buffer and return a read-only pointer to the
    /// characters in the document.
    /// </summary>
    property CharacterPointer: Pointer read GetCharacterPointer;
    /// <summary>
    /// Whether additional carets are visible
    /// </summary>
    property AdditionalCaretsVisible: Boolean read GetAdditionalCaretsVisible write SetAdditionalCaretsVisible;
    /// <summary>
    /// Get the current indicator value
    /// </summary>
    property IndicatorValue: Integer read GetIndicatorValue write SetIndicatorValue;
    /// <summary>
    /// Returns true if overtype mode is active otherwise false is returned.
    /// </summary>
    property Overtype: Boolean read GetOvertype write SetOvertype;
    /// <summary>
    /// Return the anchor position of the rectangular selection.
    /// </summary>
    property RectangularSelectionAnchor: Integer read GetRectangularSelectionAnchor write SetRectangularSelectionAnchor;
    /// <summary>
    /// Returns the print colour mode.
    /// </summary>
    property PrintColourMode: Integer read GetPrintColourMode write SetPrintColourMode;
    /// <summary>
    /// Get the position that starts the target.
    /// </summary>
    property TargetStart: Integer read GetTargetStart write SetTargetStart;
    /// <summary>
    /// Returns the size in pixels of the left margin.
    /// </summary>
    property MarginLeft: Integer read GetMarginLeft write SetMarginLeft;
    /// <summary>
    /// Get extra ascent for each line
    /// </summary>
    property ExtraAscent: Integer read GetExtraAscent write SetExtraAscent;
    /// <summary>
    /// Return the virtual space of the caret of the rectangular selection.
    /// </summary>
    property RectangularSelectionCaretVirtualSpace: Integer read GetRectangularSelectionCaretVirtualSpace write SetRectangularSelectionCaretVirtualSpace;
    /// <summary>
    /// Whether additional carets will blink
    /// </summary>
    property AdditionalCaretsBlink: Boolean read GetAdditionalCaretsBlink write SetAdditionalCaretsBlink;
    /// <summary>
    /// Whether multiple selections can be made
    /// </summary>
    property MultipleSelection: Boolean read GetMultipleSelection write SetMultipleSelection;
    /// <summary>
    /// Retrive the location of visual flags for wrapped lines.
    /// </summary>
    property WrapVisualFlagsLocation: Integer read GetWrapVisualFlagsLocation write SetWrapVisualFlagsLocation;
    /// <summary>
    /// Returns the print magnification.
    /// </summary>
    property PrintMagnification: Integer read GetPrintMagnification write SetPrintMagnification;
    /// <summary>
    /// Returns the width of the insert mode caret.
    /// </summary>
    property CaretWidth: Integer read GetCaretWidth write SetCaretWidth;
    /// <summary>
    /// Retrieve bidirectional text display state.
    /// </summary>
    property Bidirectional: Integer read GetBidirectional write SetBidirectional;
    /// <summary>
    /// Is the caret line always visible?
    /// </summary>
    property CaretLineVisibleAlways: Boolean read GetCaretLineVisibleAlways write SetCaretLineVisibleAlways;
    /// <summary>
    /// Get the highlighted indentation guide column.
    /// </summary>
    property HighlightGuide: Integer read GetHighlightGuide write SetHighlightGuide;
    /// <summary>
    /// Can the caret preferred x position only be changed by explicit movement commands?
    /// </summary>
    property CaretSticky: Integer read GetCaretSticky write SetCaretSticky;
    /// <summary>
    /// Get whether underlining for active hotspots.
    /// </summary>
    property HotspotActiveUnderline: Boolean read GetHotspotActiveUnderline write SetHotspotActiveUnderline;
    /// <summary>
    /// Retrive the display mode of visual flags for wrapped lines.
    /// </summary>
    property WrapVisualFlags: Integer read GetWrapVisualFlags write SetWrapVisualFlags;
    /// <summary>
    /// Are the end of line characters visible?
    /// </summary>
    property ViewEOL: Boolean read GetViewEOL write SetViewEOL;
    /// <summary>
    /// Retrieve the column number which text should be kept within.
    /// </summary>
    property EdgeColumn: Integer read GetEdgeColumn write SetEdgeColumn;
    /// <summary>
    /// Is the horizontal scroll bar visible?
    /// </summary>
    property HScrollBar: Boolean read GetHScrollBar write SetHScrollBar;
    /// <summary>
    /// Get which document options are set.
    /// </summary>
    property DocumentOptions: Integer read GetDocumentOptions;
    /// <summary>
    /// Get the alpha of the selection.
    /// </summary>
    property AdditionalSelAlpha: Integer read GetAdditionalSelAlpha write SetAdditionalSelAlpha;
    /// <summary>
    /// Are the indentation guides visible?
    /// </summary>
    property IndentationGuides: Integer read GetIndentationGuides write SetIndentationGuides;
    /// <summary>
    /// Retrieve whether the scroll width tracks wide lines.
    /// </summary>
    property ScrollWidthTracking: Boolean read GetScrollWidthTracking write SetScrollWidthTracking;
    /// <summary>
    /// Which action is the detach point?
    /// </summary>
    property UndoDetach: Integer read GetUndoDetach write SetUndoDetach;
    /// <summary>
    /// Retrieve line character index state.
    /// </summary>
    property LineCharacterIndex: Integer read GetLineCharacterIndex;
    /// <summary>
    /// Does a tab pressed when caret is within indentation indent?
    /// </summary>
    property TabIndents: Boolean read GetTabIndents write SetTabIndents;
  end;

procedure Register;

implementation

const
  ScintillaClassName = 'Scintilla';
  ScintillaDLL = 'SciLexer.dll';

procedure Register;
begin
  RegisterComponents('Scintilla', [TScintilla]);
end;

{ TScintilla }

constructor TScintilla.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 300;
  Height := 200;
  TabStop := True;
  ControlStyle := ControlStyle + [csCaptureMouse, csClickEvents, csDoubleClicks, csOpaque];
end;

destructor TScintilla.Destroy;
begin
  inherited Destroy;
end;

procedure TScintilla.CreateWnd;
var
  LoadResult: THandle;
begin
  LoadResult := LoadLibrary(ScintillaDLL);
  if LoadResult = 0 then
    raise Exception.Create('Failed to load ' + ScintillaDLL);

  CreateWindowEx(0, ScintillaClassName, nil,
    WS_CHILD or WS_VISIBLE or WS_TABSTOP or WS_CLIPCHILDREN,
    0, 0, Width, Height, Handle, 0, HInstance, nil);

  // Get direct access for better performance
  FDirectPtr := Pointer(SendMessage(Handle, SCI_GETDIRECTPOINTER, 0, 0));
  FDirectFunction := Pointer(SendMessage(Handle, SCI_GETDIRECTFUNCTION, 0, 0));
end;

procedure TScintilla.DestroyWnd;
begin
  FDirectPtr := nil;
  FDirectFunction := nil;
  inherited DestroyWnd;
end;

procedure TScintilla.WMGetDlgCode(var Message: TWMGetDlgCode);
begin
  inherited;
  Message.Result := Message.Result or DLGC_WANTARROWS or DLGC_WANTCHARS;
end;

procedure TScintilla.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
  Message.Result := 1; // Prevent flicker
end;

procedure TScintilla.AddText(length: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_ADDTEXT, length, LPARAM(text));
end;

procedure TScintilla.AddStyledText(length: Integer; c: PAnsiChar);
begin
  SendMessage(Handle, SCI_ADDSTYLEDTEXT, length, c);
end;

procedure TScintilla.InsertText(pos: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_INSERTTEXT, pos, LPARAM(text));
end;

procedure TScintilla.ChangeInsertion(length: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_CHANGEINSERTION, length, LPARAM(text));
end;

procedure TScintilla.ClearAll();
begin
  SendMessage(Handle, SCI_CLEARALL, 0, 0);
end;

procedure TScintilla.DeleteRange(start: Integer; lengthDelete: Integer);
begin
  SendMessage(Handle, SCI_DELETERANGE, start, lengthDelete);
end;

procedure TScintilla.ClearDocumentStyle();
begin
  SendMessage(Handle, SCI_CLEARDOCUMENTSTYLE, 0, 0);
end;

function TScintilla.GetLength(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLENGTH, 0, 0);
end;

function TScintilla.GetCharAt(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCHARAT, pos, 0);
end;

function TScintilla.GetCurrentPos(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCURRENTPOS, 0, 0);
end;

function TScintilla.GetAnchor(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETANCHOR, 0, 0);
end;

function TScintilla.GetStyleAt(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSTYLEAT, pos, 0);
end;

function TScintilla.GetStyleIndexAt(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSTYLEINDEXAT, pos, 0);
end;

procedure TScintilla.Redo();
begin
  SendMessage(Handle, SCI_REDO, 0, 0);
end;

procedure TScintilla.SetUndoCollection(collectUndo: Boolean);
begin
  SendMessage(Handle, SCI_SETUNDOCOLLECTION, collectUndo, 0);
end;

procedure TScintilla.SelectAll();
begin
  SendMessage(Handle, SCI_SELECTALL, 0, 0);
end;

procedure TScintilla.SetSavePoint();
begin
  SendMessage(Handle, SCI_SETSAVEPOINT, 0, 0);
end;

function TScintilla.GetStyledText(tr: PTextRange): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSTYLEDTEXT, 0, tr);
end;

function TScintilla.GetStyledTextFull(tr: PTextRangeFull): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSTYLEDTEXTFULL, 0, tr);
end;

function TScintilla.CanRedo(): Boolean;
begin
  Result := SendMessage(Handle, SCI_CANREDO, 0, 0);
end;

function TScintilla.MarkerLineFromHandle(markerHandle: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERLINEFROMHANDLE, markerHandle, 0);
end;

procedure TScintilla.MarkerDeleteHandle(markerHandle: Integer);
begin
  SendMessage(Handle, SCI_MARKERDELETEHANDLE, markerHandle, 0);
end;

function TScintilla.MarkerHandleFromLine(line: Integer; which: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERHANDLEFROMLINE, line, which);
end;

function TScintilla.MarkerNumberFromLine(line: Integer; which: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERNUMBERFROMLINE, line, which);
end;

function TScintilla.GetUndoCollection(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETUNDOCOLLECTION, 0, 0);
end;

function TScintilla.GetViewWS(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETVIEWWS, 0, 0);
end;

procedure TScintilla.SetViewWS(viewWS: Integer);
begin
  SendMessage(Handle, SCI_SETVIEWWS, viewWS, 0);
end;

function TScintilla.GetTabDrawMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTABDRAWMODE, 0, 0);
end;

procedure TScintilla.SetTabDrawMode(tabDrawMode: Integer);
begin
  SendMessage(Handle, SCI_SETTABDRAWMODE, tabDrawMode, 0);
end;

function TScintilla.PositionFromPoint(x: Integer; y: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POSITIONFROMPOINT, x, y);
end;

function TScintilla.PositionFromPointClose(x: Integer; y: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POSITIONFROMPOINTCLOSE, x, y);
end;

procedure TScintilla.GotoLine(line: Integer);
begin
  SendMessage(Handle, SCI_GOTOLINE, line, 0);
end;

procedure TScintilla.GotoPos(caret: Integer);
begin
  SendMessage(Handle, SCI_GOTOPOS, caret, 0);
end;

procedure TScintilla.SetAnchor(anchor: Integer);
begin
  SendMessage(Handle, SCI_SETANCHOR, anchor, 0);
end;

function TScintilla.GetCurLine(length: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCURLINE, length, LPARAM(text));
end;

function TScintilla.GetEndStyled(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETENDSTYLED, 0, 0);
end;

procedure TScintilla.ConvertEOLs(eolMode: Integer);
begin
  SendMessage(Handle, SCI_CONVERTEOLS, eolMode, 0);
end;

function TScintilla.GetEOLMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETEOLMODE, 0, 0);
end;

procedure TScintilla.SetEOLMode(eolMode: Integer);
begin
  SendMessage(Handle, SCI_SETEOLMODE, eolMode, 0);
end;

procedure TScintilla.StartStyling(start: Integer; unused: Integer);
begin
  SendMessage(Handle, SCI_STARTSTYLING, start, unused);
end;

procedure TScintilla.SetStyling(length: Integer; style: Integer);
begin
  SendMessage(Handle, SCI_SETSTYLING, length, style);
end;

function TScintilla.GetBufferedDraw(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETBUFFEREDDRAW, 0, 0);
end;

procedure TScintilla.SetBufferedDraw(buffered: Boolean);
begin
  SendMessage(Handle, SCI_SETBUFFEREDDRAW, buffered, 0);
end;

procedure TScintilla.SetTabWidth(tabWidth: Integer);
begin
  SendMessage(Handle, SCI_SETTABWIDTH, tabWidth, 0);
end;

function TScintilla.GetTabWidth(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTABWIDTH, 0, 0);
end;

procedure TScintilla.SetTabMinimumWidth(pixels: Integer);
begin
  SendMessage(Handle, SCI_SETTABMINIMUMWIDTH, pixels, 0);
end;

function TScintilla.GetTabMinimumWidth(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTABMINIMUMWIDTH, 0, 0);
end;

procedure TScintilla.ClearTabStops(line: Integer);
begin
  SendMessage(Handle, SCI_CLEARTABSTOPS, line, 0);
end;

procedure TScintilla.AddTabStop(line: Integer; x: Integer);
begin
  SendMessage(Handle, SCI_ADDTABSTOP, line, x);
end;

function TScintilla.GetNextTabStop(line: Integer; x: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETNEXTTABSTOP, line, x);
end;

procedure TScintilla.SetCodePage(codePage: Integer);
begin
  SendMessage(Handle, SCI_SETCODEPAGE, codePage, 0);
end;

procedure TScintilla.SetFontLocale(localeName: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETFONTLOCALE, 0, LPARAM(localeName));
end;

function TScintilla.GetFontLocale(localeName: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETFONTLOCALE, 0, LPARAM(localeName));
end;

function TScintilla.GetIMEInteraction(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETIMEINTERACTION, 0, 0);
end;

procedure TScintilla.SetIMEInteraction(imeInteraction: Integer);
begin
  SendMessage(Handle, SCI_SETIMEINTERACTION, imeInteraction, 0);
end;

procedure TScintilla.MarkerDefine(markerNumber: Integer; markerSymbol: Integer);
begin
  SendMessage(Handle, SCI_MARKERDEFINE, markerNumber, markerSymbol);
end;

procedure TScintilla.MarkerSetFore(markerNumber: Integer; fore: TColor);
begin
  SendMessage(Handle, SCI_MARKERSETFORE, markerNumber, fore);
end;

procedure TScintilla.MarkerSetBack(markerNumber: Integer; back: TColor);
begin
  SendMessage(Handle, SCI_MARKERSETBACK, markerNumber, back);
end;

procedure TScintilla.MarkerSetBackSelected(markerNumber: Integer; back: TColor);
begin
  SendMessage(Handle, SCI_MARKERSETBACKSELECTED, markerNumber, back);
end;

procedure TScintilla.MarkerSetForeTranslucent(markerNumber: Integer; fore: TColorAlpha);
begin
  SendMessage(Handle, SCI_MARKERSETFORETRANSLUCENT, markerNumber, fore);
end;

procedure TScintilla.MarkerSetBackTranslucent(markerNumber: Integer; back: TColorAlpha);
begin
  SendMessage(Handle, SCI_MARKERSETBACKTRANSLUCENT, markerNumber, back);
end;

procedure TScintilla.MarkerSetBackSelectedTranslucent(markerNumber: Integer; back: TColorAlpha);
begin
  SendMessage(Handle, SCI_MARKERSETBACKSELECTEDTRANSLUCENT, markerNumber, back);
end;

procedure TScintilla.MarkerSetStrokeWidth(markerNumber: Integer; hundredths: Integer);
begin
  SendMessage(Handle, SCI_MARKERSETSTROKEWIDTH, markerNumber, hundredths);
end;

procedure TScintilla.MarkerEnableHighlight(enabled: Boolean);
begin
  SendMessage(Handle, SCI_MARKERENABLEHIGHLIGHT, enabled, 0);
end;

function TScintilla.MarkerAdd(line: Integer; markerNumber: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERADD, line, markerNumber);
end;

procedure TScintilla.MarkerDelete(line: Integer; markerNumber: Integer);
begin
  SendMessage(Handle, SCI_MARKERDELETE, line, markerNumber);
end;

procedure TScintilla.MarkerDeleteAll(markerNumber: Integer);
begin
  SendMessage(Handle, SCI_MARKERDELETEALL, markerNumber, 0);
end;

function TScintilla.MarkerGet(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERGET, line, 0);
end;

function TScintilla.MarkerNext(lineStart: Integer; markerMask: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERNEXT, lineStart, markerMask);
end;

function TScintilla.MarkerPrevious(lineStart: Integer; markerMask: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERPREVIOUS, lineStart, markerMask);
end;

procedure TScintilla.MarkerDefinePixmap(markerNumber: Integer; pixmap: PAnsiChar);
begin
  SendMessage(Handle, SCI_MARKERDEFINEPIXMAP, markerNumber, LPARAM(pixmap));
end;

procedure TScintilla.MarkerAddSet(line: Integer; markerSet: Integer);
begin
  SendMessage(Handle, SCI_MARKERADDSET, line, markerSet);
end;

procedure TScintilla.MarkerSetAlpha(markerNumber: Integer; alpha: Integer);
begin
  SendMessage(Handle, SCI_MARKERSETALPHA, markerNumber, alpha);
end;

function TScintilla.MarkerGetLayer(markerNumber: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERGETLAYER, markerNumber, 0);
end;

procedure TScintilla.MarkerSetLayer(markerNumber: Integer; layer: Integer);
begin
  SendMessage(Handle, SCI_MARKERSETLAYER, markerNumber, layer);
end;

procedure TScintilla.SetMarginTypeN(margin: Integer; marginType: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINTYPEN, margin, marginType);
end;

function TScintilla.GetMarginTypeN(margin: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINTYPEN, margin, 0);
end;

procedure TScintilla.SetMarginWidthN(margin: Integer; pixelWidth: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINWIDTHN, margin, pixelWidth);
end;

function TScintilla.GetMarginWidthN(margin: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINWIDTHN, margin, 0);
end;

procedure TScintilla.SetMarginMaskN(margin: Integer; mask: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINMASKN, margin, mask);
end;

function TScintilla.GetMarginMaskN(margin: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINMASKN, margin, 0);
end;

procedure TScintilla.SetMarginSensitiveN(margin: Integer; sensitive: Boolean);
begin
  SendMessage(Handle, SCI_SETMARGINSENSITIVEN, margin, sensitive);
end;

function TScintilla.GetMarginSensitiveN(margin: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETMARGINSENSITIVEN, margin, 0);
end;

procedure TScintilla.SetMarginCursorN(margin: Integer; cursor: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINCURSORN, margin, cursor);
end;

function TScintilla.GetMarginCursorN(margin: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINCURSORN, margin, 0);
end;

procedure TScintilla.SetMarginBackN(margin: Integer; back: TColor);
begin
  SendMessage(Handle, SCI_SETMARGINBACKN, margin, back);
end;

function TScintilla.GetMarginBackN(margin: Integer): TColor;
begin
  Result := SendMessage(Handle, SCI_GETMARGINBACKN, margin, 0);
end;

procedure TScintilla.SetMargins(margins: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINS, margins, 0);
end;

function TScintilla.GetMargins(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINS, 0, 0);
end;

procedure TScintilla.StyleClearAll();
begin
  SendMessage(Handle, SCI_STYLECLEARALL, 0, 0);
end;

procedure TScintilla.StyleSetFore(style: Integer; fore: TColor);
begin
  SendMessage(Handle, SCI_STYLESETFORE, style, fore);
end;

procedure TScintilla.StyleSetBack(style: Integer; back: TColor);
begin
  SendMessage(Handle, SCI_STYLESETBACK, style, back);
end;

procedure TScintilla.StyleSetBold(style: Integer; bold: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETBOLD, style, bold);
end;

procedure TScintilla.StyleSetItalic(style: Integer; italic: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETITALIC, style, italic);
end;

procedure TScintilla.StyleSetSize(style: Integer; sizePoints: Integer);
begin
  SendMessage(Handle, SCI_STYLESETSIZE, style, sizePoints);
end;

procedure TScintilla.StyleSetFont(style: Integer; fontName: PAnsiChar);
begin
  SendMessage(Handle, SCI_STYLESETFONT, style, LPARAM(fontName));
end;

procedure TScintilla.StyleSetEOLFilled(style: Integer; eolFilled: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETEOLFILLED, style, eolFilled);
end;

procedure TScintilla.StyleResetDefault();
begin
  SendMessage(Handle, SCI_STYLERESETDEFAULT, 0, 0);
end;

procedure TScintilla.StyleSetUnderline(style: Integer; underline: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETUNDERLINE, style, underline);
end;

function TScintilla.StyleGetFore(style: Integer): TColor;
begin
  Result := SendMessage(Handle, SCI_STYLEGETFORE, style, 0);
end;

function TScintilla.StyleGetBack(style: Integer): TColor;
begin
  Result := SendMessage(Handle, SCI_STYLEGETBACK, style, 0);
end;

function TScintilla.StyleGetBold(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETBOLD, style, 0);
end;

function TScintilla.StyleGetItalic(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETITALIC, style, 0);
end;

function TScintilla.StyleGetSize(style: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETSIZE, style, 0);
end;

function TScintilla.StyleGetFont(style: Integer; fontName: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETFONT, style, LPARAM(fontName));
end;

function TScintilla.StyleGetEOLFilled(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETEOLFILLED, style, 0);
end;

function TScintilla.StyleGetUnderline(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETUNDERLINE, style, 0);
end;

function TScintilla.StyleGetCase(style: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETCASE, style, 0);
end;

function TScintilla.StyleGetCharacterSet(style: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETCHARACTERSET, style, 0);
end;

function TScintilla.StyleGetVisible(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETVISIBLE, style, 0);
end;

function TScintilla.StyleGetChangeable(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETCHANGEABLE, style, 0);
end;

function TScintilla.StyleGetHotSpot(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETHOTSPOT, style, 0);
end;

procedure TScintilla.StyleSetCase(style: Integer; caseVisible: Integer);
begin
  SendMessage(Handle, SCI_STYLESETCASE, style, caseVisible);
end;

procedure TScintilla.StyleSetSizeFractional(style: Integer; sizeHundredthPoints: Integer);
begin
  SendMessage(Handle, SCI_STYLESETSIZEFRACTIONAL, style, sizeHundredthPoints);
end;

function TScintilla.StyleGetSizeFractional(style: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETSIZEFRACTIONAL, style, 0);
end;

procedure TScintilla.StyleSetWeight(style: Integer; weight: Integer);
begin
  SendMessage(Handle, SCI_STYLESETWEIGHT, style, weight);
end;

function TScintilla.StyleGetWeight(style: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETWEIGHT, style, 0);
end;

procedure TScintilla.StyleSetCharacterSet(style: Integer; characterSet: Integer);
begin
  SendMessage(Handle, SCI_STYLESETCHARACTERSET, style, characterSet);
end;

procedure TScintilla.StyleSetHotSpot(style: Integer; hotspot: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETHOTSPOT, style, hotspot);
end;

procedure TScintilla.StyleSetCheckMonospaced(style: Integer; checkMonospaced: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETCHECKMONOSPACED, style, checkMonospaced);
end;

function TScintilla.StyleGetCheckMonospaced(style: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_STYLEGETCHECKMONOSPACED, style, 0);
end;

procedure TScintilla.StyleSetStretch(style: Integer; stretch: Integer);
begin
  SendMessage(Handle, SCI_STYLESETSTRETCH, style, stretch);
end;

function TScintilla.StyleGetStretch(style: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETSTRETCH, style, 0);
end;

procedure TScintilla.StyleSetInvisibleRepresentation(style: Integer; representation: PAnsiChar);
begin
  SendMessage(Handle, SCI_STYLESETINVISIBLEREPRESENTATION, style, LPARAM(representation));
end;

function TScintilla.StyleGetInvisibleRepresentation(style: Integer; representation: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_STYLEGETINVISIBLEREPRESENTATION, style, LPARAM(representation));
end;

procedure TScintilla.SetElementColour(element: Integer; colourElement: TColorAlpha);
begin
  SendMessage(Handle, SCI_SETELEMENTCOLOUR, element, colourElement);
end;

function TScintilla.GetElementColour(element: Integer): TColorAlpha;
begin
  Result := SendMessage(Handle, SCI_GETELEMENTCOLOUR, element, 0);
end;

procedure TScintilla.ResetElementColour(element: Integer);
begin
  SendMessage(Handle, SCI_RESETELEMENTCOLOUR, element, 0);
end;

function TScintilla.GetElementIsSet(element: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETELEMENTISSET, element, 0);
end;

function TScintilla.GetElementAllowsTranslucent(element: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETELEMENTALLOWSTRANSLUCENT, element, 0);
end;

function TScintilla.GetElementBaseColour(element: Integer): TColorAlpha;
begin
  Result := SendMessage(Handle, SCI_GETELEMENTBASECOLOUR, element, 0);
end;

procedure TScintilla.SetSelFore(useSetting: Boolean; fore: TColor);
begin
  SendMessage(Handle, SCI_SETSELFORE, useSetting, fore);
end;

procedure TScintilla.SetSelBack(useSetting: Boolean; back: TColor);
begin
  SendMessage(Handle, SCI_SETSELBACK, useSetting, back);
end;

function TScintilla.GetSelAlpha(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELALPHA, 0, 0);
end;

procedure TScintilla.SetSelAlpha(alpha: Integer);
begin
  SendMessage(Handle, SCI_SETSELALPHA, alpha, 0);
end;

function TScintilla.GetSelEOLFilled(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETSELEOLFILLED, 0, 0);
end;

procedure TScintilla.SetSelEOLFilled(filled: Boolean);
begin
  SendMessage(Handle, SCI_SETSELEOLFILLED, filled, 0);
end;

function TScintilla.GetSelectionLayer(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONLAYER, 0, 0);
end;

procedure TScintilla.SetSelectionLayer(layer: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONLAYER, layer, 0);
end;

function TScintilla.GetCaretLineLayer(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCARETLINELAYER, 0, 0);
end;

procedure TScintilla.SetCaretLineLayer(layer: Integer);
begin
  SendMessage(Handle, SCI_SETCARETLINELAYER, layer, 0);
end;

function TScintilla.GetCaretLineHighlightSubLine(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETCARETLINEHIGHLIGHTSUBLINE, 0, 0);
end;

procedure TScintilla.SetCaretLineHighlightSubLine(subLine: Boolean);
begin
  SendMessage(Handle, SCI_SETCARETLINEHIGHLIGHTSUBLINE, subLine, 0);
end;

procedure TScintilla.SetCaretFore(fore: TColor);
begin
  SendMessage(Handle, SCI_SETCARETFORE, fore, 0);
end;

procedure TScintilla.AssignCmdKey(keyDefinition: Integer; sciCommand: Integer);
begin
  SendMessage(Handle, SCI_ASSIGNCMDKEY, keyDefinition, sciCommand);
end;

procedure TScintilla.ClearCmdKey(keyDefinition: Integer);
begin
  SendMessage(Handle, SCI_CLEARCMDKEY, keyDefinition, 0);
end;

procedure TScintilla.ClearAllCmdKeys();
begin
  SendMessage(Handle, SCI_CLEARALLCMDKEYS, 0, 0);
end;

procedure TScintilla.SetStylingEx(length: Integer; styles: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETSTYLINGEX, length, LPARAM(styles));
end;

procedure TScintilla.StyleSetVisible(style: Integer; visible: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETVISIBLE, style, visible);
end;

function TScintilla.GetCaretPeriod(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCARETPERIOD, 0, 0);
end;

procedure TScintilla.SetCaretPeriod(periodMilliseconds: Integer);
begin
  SendMessage(Handle, SCI_SETCARETPERIOD, periodMilliseconds, 0);
end;

procedure TScintilla.SetWordChars(characters: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETWORDCHARS, 0, LPARAM(characters));
end;

function TScintilla.GetWordChars(characters: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWORDCHARS, 0, LPARAM(characters));
end;

procedure TScintilla.SetCharacterCategoryOptimization(countCharacters: Integer);
begin
  SendMessage(Handle, SCI_SETCHARACTERCATEGORYOPTIMIZATION, countCharacters, 0);
end;

function TScintilla.GetCharacterCategoryOptimization(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCHARACTERCATEGORYOPTIMIZATION, 0, 0);
end;

procedure TScintilla.BeginUndoAction();
begin
  SendMessage(Handle, SCI_BEGINUNDOACTION, 0, 0);
end;

procedure TScintilla.EndUndoAction();
begin
  SendMessage(Handle, SCI_ENDUNDOACTION, 0, 0);
end;

function TScintilla.GetUndoSequence(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOSEQUENCE, 0, 0);
end;

function TScintilla.GetUndoActions(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOACTIONS, 0, 0);
end;

procedure TScintilla.SetUndoSavePoint(action: Integer);
begin
  SendMessage(Handle, SCI_SETUNDOSAVEPOINT, action, 0);
end;

function TScintilla.GetUndoSavePoint(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOSAVEPOINT, 0, 0);
end;

procedure TScintilla.SetUndoDetach(action: Integer);
begin
  SendMessage(Handle, SCI_SETUNDODETACH, action, 0);
end;

function TScintilla.GetUndoDetach(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDODETACH, 0, 0);
end;

procedure TScintilla.SetUndoTentative(action: Integer);
begin
  SendMessage(Handle, SCI_SETUNDOTENTATIVE, action, 0);
end;

function TScintilla.GetUndoTentative(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOTENTATIVE, 0, 0);
end;

procedure TScintilla.SetUndoCurrent(action: Integer);
begin
  SendMessage(Handle, SCI_SETUNDOCURRENT, action, 0);
end;

function TScintilla.GetUndoCurrent(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOCURRENT, 0, 0);
end;

procedure TScintilla.PushUndoActionType(type: Integer; pos: Integer);
begin
  SendMessage(Handle, SCI_PUSHUNDOACTIONTYPE, type, pos);
end;

procedure TScintilla.ChangeLastUndoActionText(length: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_CHANGELASTUNDOACTIONTEXT, length, LPARAM(text));
end;

function TScintilla.GetUndoActionType(action: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOACTIONTYPE, action, 0);
end;

function TScintilla.GetUndoActionPosition(action: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOACTIONPOSITION, action, 0);
end;

function TScintilla.GetUndoActionText(action: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOACTIONTEXT, action, LPARAM(text));
end;

procedure TScintilla.IndicSetStyle(indicator: Integer; indicatorStyle: Integer);
begin
  SendMessage(Handle, SCI_INDICSETSTYLE, indicator, indicatorStyle);
end;

function TScintilla.IndicGetStyle(indicator: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICGETSTYLE, indicator, 0);
end;

procedure TScintilla.IndicSetFore(indicator: Integer; fore: TColor);
begin
  SendMessage(Handle, SCI_INDICSETFORE, indicator, fore);
end;

function TScintilla.IndicGetFore(indicator: Integer): TColor;
begin
  Result := SendMessage(Handle, SCI_INDICGETFORE, indicator, 0);
end;

procedure TScintilla.IndicSetUnder(indicator: Integer; under: Boolean);
begin
  SendMessage(Handle, SCI_INDICSETUNDER, indicator, under);
end;

function TScintilla.IndicGetUnder(indicator: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_INDICGETUNDER, indicator, 0);
end;

procedure TScintilla.IndicSetHoverStyle(indicator: Integer; indicatorStyle: Integer);
begin
  SendMessage(Handle, SCI_INDICSETHOVERSTYLE, indicator, indicatorStyle);
end;

function TScintilla.IndicGetHoverStyle(indicator: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICGETHOVERSTYLE, indicator, 0);
end;

procedure TScintilla.IndicSetHoverFore(indicator: Integer; fore: TColor);
begin
  SendMessage(Handle, SCI_INDICSETHOVERFORE, indicator, fore);
end;

function TScintilla.IndicGetHoverFore(indicator: Integer): TColor;
begin
  Result := SendMessage(Handle, SCI_INDICGETHOVERFORE, indicator, 0);
end;

procedure TScintilla.IndicSetFlags(indicator: Integer; flags: Integer);
begin
  SendMessage(Handle, SCI_INDICSETFLAGS, indicator, flags);
end;

function TScintilla.IndicGetFlags(indicator: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICGETFLAGS, indicator, 0);
end;

procedure TScintilla.IndicSetStrokeWidth(indicator: Integer; hundredths: Integer);
begin
  SendMessage(Handle, SCI_INDICSETSTROKEWIDTH, indicator, hundredths);
end;

function TScintilla.IndicGetStrokeWidth(indicator: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICGETSTROKEWIDTH, indicator, 0);
end;

procedure TScintilla.SetWhitespaceFore(useSetting: Boolean; fore: TColor);
begin
  SendMessage(Handle, SCI_SETWHITESPACEFORE, useSetting, fore);
end;

procedure TScintilla.SetWhitespaceBack(useSetting: Boolean; back: TColor);
begin
  SendMessage(Handle, SCI_SETWHITESPACEBACK, useSetting, back);
end;

procedure TScintilla.SetWhitespaceSize(size: Integer);
begin
  SendMessage(Handle, SCI_SETWHITESPACESIZE, size, 0);
end;

function TScintilla.GetWhitespaceSize(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWHITESPACESIZE, 0, 0);
end;

procedure TScintilla.SetLineState(line: Integer; state: Integer);
begin
  SendMessage(Handle, SCI_SETLINESTATE, line, state);
end;

function TScintilla.GetLineState(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINESTATE, line, 0);
end;

function TScintilla.GetMaxLineState(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMAXLINESTATE, 0, 0);
end;

function TScintilla.GetCaretLineVisible(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETCARETLINEVISIBLE, 0, 0);
end;

procedure TScintilla.SetCaretLineVisible(show: Boolean);
begin
  SendMessage(Handle, SCI_SETCARETLINEVISIBLE, show, 0);
end;

function TScintilla.GetCaretLineBack(): TColor;
begin
  Result := SendMessage(Handle, SCI_GETCARETLINEBACK, 0, 0);
end;

procedure TScintilla.SetCaretLineBack(back: TColor);
begin
  SendMessage(Handle, SCI_SETCARETLINEBACK, back, 0);
end;

function TScintilla.GetCaretLineFrame(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCARETLINEFRAME, 0, 0);
end;

procedure TScintilla.SetCaretLineFrame(width: Integer);
begin
  SendMessage(Handle, SCI_SETCARETLINEFRAME, width, 0);
end;

procedure TScintilla.StyleSetChangeable(style: Integer; changeable: Boolean);
begin
  SendMessage(Handle, SCI_STYLESETCHANGEABLE, style, changeable);
end;

procedure TScintilla.AutoCShow(lengthEntered: Integer; itemList: PAnsiChar);
begin
  SendMessage(Handle, SCI_AUTOCSHOW, lengthEntered, LPARAM(itemList));
end;

procedure TScintilla.AutoCCancel();
begin
  SendMessage(Handle, SCI_AUTOCCANCEL, 0, 0);
end;

function TScintilla.AutoCActive(): Boolean;
begin
  Result := SendMessage(Handle, SCI_AUTOCACTIVE, 0, 0);
end;

function TScintilla.AutoCPosStart(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCPOSSTART, 0, 0);
end;

procedure TScintilla.AutoCComplete();
begin
  SendMessage(Handle, SCI_AUTOCCOMPLETE, 0, 0);
end;

procedure TScintilla.AutoCStops(characterSet: PAnsiChar);
begin
  SendMessage(Handle, SCI_AUTOCSTOPS, 0, LPARAM(characterSet));
end;

procedure TScintilla.AutoCSetSeparator(separatorCharacter: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETSEPARATOR, separatorCharacter, 0);
end;

function TScintilla.AutoCGetSeparator(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETSEPARATOR, 0, 0);
end;

procedure TScintilla.AutoCSelect(select: PAnsiChar);
begin
  SendMessage(Handle, SCI_AUTOCSELECT, 0, LPARAM(select));
end;

procedure TScintilla.AutoCSetCancelAtStart(cancel: Boolean);
begin
  SendMessage(Handle, SCI_AUTOCSETCANCELATSTART, cancel, 0);
end;

function TScintilla.AutoCGetCancelAtStart(): Boolean;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETCANCELATSTART, 0, 0);
end;

procedure TScintilla.AutoCSetFillUps(characterSet: PAnsiChar);
begin
  SendMessage(Handle, SCI_AUTOCSETFILLUPS, 0, LPARAM(characterSet));
end;

procedure TScintilla.AutoCSetChooseSingle(chooseSingle: Boolean);
begin
  SendMessage(Handle, SCI_AUTOCSETCHOOSESINGLE, chooseSingle, 0);
end;

function TScintilla.AutoCGetChooseSingle(): Boolean;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETCHOOSESINGLE, 0, 0);
end;

procedure TScintilla.AutoCSetIgnoreCase(ignoreCase: Boolean);
begin
  SendMessage(Handle, SCI_AUTOCSETIGNORECASE, ignoreCase, 0);
end;

function TScintilla.AutoCGetIgnoreCase(): Boolean;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETIGNORECASE, 0, 0);
end;

procedure TScintilla.UserListShow(listType: Integer; itemList: PAnsiChar);
begin
  SendMessage(Handle, SCI_USERLISTSHOW, listType, LPARAM(itemList));
end;

procedure TScintilla.AutoCSetAutoHide(autoHide: Boolean);
begin
  SendMessage(Handle, SCI_AUTOCSETAUTOHIDE, autoHide, 0);
end;

function TScintilla.AutoCGetAutoHide(): Boolean;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETAUTOHIDE, 0, 0);
end;

procedure TScintilla.AutoCSetOptions(options: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETOPTIONS, options, 0);
end;

function TScintilla.AutoCGetOptions(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETOPTIONS, 0, 0);
end;

procedure TScintilla.AutoCSetDropRestOfWord(dropRestOfWord: Boolean);
begin
  SendMessage(Handle, SCI_AUTOCSETDROPRESTOFWORD, dropRestOfWord, 0);
end;

function TScintilla.AutoCGetDropRestOfWord(): Boolean;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETDROPRESTOFWORD, 0, 0);
end;

procedure TScintilla.RegisterImage(type: Integer; xpmData: PAnsiChar);
begin
  SendMessage(Handle, SCI_REGISTERIMAGE, type, LPARAM(xpmData));
end;

procedure TScintilla.ClearRegisteredImages();
begin
  SendMessage(Handle, SCI_CLEARREGISTEREDIMAGES, 0, 0);
end;

function TScintilla.AutoCGetTypeSeparator(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETTYPESEPARATOR, 0, 0);
end;

procedure TScintilla.AutoCSetTypeSeparator(separatorCharacter: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETTYPESEPARATOR, separatorCharacter, 0);
end;

procedure TScintilla.AutoCSetMaxWidth(characterCount: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETMAXWIDTH, characterCount, 0);
end;

function TScintilla.AutoCGetMaxWidth(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETMAXWIDTH, 0, 0);
end;

procedure TScintilla.AutoCSetMaxHeight(rowCount: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETMAXHEIGHT, rowCount, 0);
end;

function TScintilla.AutoCGetMaxHeight(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETMAXHEIGHT, 0, 0);
end;

procedure TScintilla.AutoCSetStyle(style: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETSTYLE, style, 0);
end;

function TScintilla.AutoCGetStyle(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETSTYLE, 0, 0);
end;

procedure TScintilla.SetIndent(indentSize: Integer);
begin
  SendMessage(Handle, SCI_SETINDENT, indentSize, 0);
end;

function TScintilla.GetIndent(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETINDENT, 0, 0);
end;

procedure TScintilla.SetUseTabs(useTabs: Boolean);
begin
  SendMessage(Handle, SCI_SETUSETABS, useTabs, 0);
end;

function TScintilla.GetUseTabs(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETUSETABS, 0, 0);
end;

procedure TScintilla.SetLineIndentation(line: Integer; indentation: Integer);
begin
  SendMessage(Handle, SCI_SETLINEINDENTATION, line, indentation);
end;

function TScintilla.GetLineIndentation(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINEINDENTATION, line, 0);
end;

function TScintilla.GetLineIndentPosition(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINEINDENTPOSITION, line, 0);
end;

function TScintilla.GetColumn(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCOLUMN, pos, 0);
end;

function TScintilla.CountCharacters(start: Integer; end: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_COUNTCHARACTERS, start, end);
end;

function TScintilla.CountCodeUnits(start: Integer; end: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_COUNTCODEUNITS, start, end);
end;

procedure TScintilla.SetHScrollBar(visible: Boolean);
begin
  SendMessage(Handle, SCI_SETHSCROLLBAR, visible, 0);
end;

function TScintilla.GetHScrollBar(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETHSCROLLBAR, 0, 0);
end;

procedure TScintilla.SetIndentationGuides(indentView: Integer);
begin
  SendMessage(Handle, SCI_SETINDENTATIONGUIDES, indentView, 0);
end;

function TScintilla.GetIndentationGuides(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETINDENTATIONGUIDES, 0, 0);
end;

procedure TScintilla.SetHighlightGuide(column: Integer);
begin
  SendMessage(Handle, SCI_SETHIGHLIGHTGUIDE, column, 0);
end;

function TScintilla.GetHighlightGuide(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETHIGHLIGHTGUIDE, 0, 0);
end;

function TScintilla.GetLineEndPosition(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINEENDPOSITION, line, 0);
end;

function TScintilla.GetCodePage(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCODEPAGE, 0, 0);
end;

function TScintilla.GetCaretFore(): TColor;
begin
  Result := SendMessage(Handle, SCI_GETCARETFORE, 0, 0);
end;

function TScintilla.GetReadOnly(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETREADONLY, 0, 0);
end;

procedure TScintilla.SetCurrentPos(caret: Integer);
begin
  SendMessage(Handle, SCI_SETCURRENTPOS, caret, 0);
end;

procedure TScintilla.SetSelectionStart(anchor: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONSTART, anchor, 0);
end;

function TScintilla.GetSelectionStart(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONSTART, 0, 0);
end;

procedure TScintilla.SetSelectionEnd(caret: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONEND, caret, 0);
end;

function TScintilla.GetSelectionEnd(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONEND, 0, 0);
end;

procedure TScintilla.SetEmptySelection(caret: Integer);
begin
  SendMessage(Handle, SCI_SETEMPTYSELECTION, caret, 0);
end;

procedure TScintilla.SetPrintMagnification(magnification: Integer);
begin
  SendMessage(Handle, SCI_SETPRINTMAGNIFICATION, magnification, 0);
end;

function TScintilla.GetPrintMagnification(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPRINTMAGNIFICATION, 0, 0);
end;

procedure TScintilla.SetPrintColourMode(mode: Integer);
begin
  SendMessage(Handle, SCI_SETPRINTCOLOURMODE, mode, 0);
end;

function TScintilla.GetPrintColourMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPRINTCOLOURMODE, 0, 0);
end;

function TScintilla.FindText(searchFlags: Integer; ft: PFindText): Integer;
begin
  Result := SendMessage(Handle, SCI_FINDTEXT, searchFlags, ft);
end;

function TScintilla.FindTextFull(searchFlags: Integer; ft: PFindTextFull): Integer;
begin
  Result := SendMessage(Handle, SCI_FINDTEXTFULL, searchFlags, ft);
end;

function TScintilla.FormatRange(draw: Boolean; fr: PFormatRange): Integer;
begin
  Result := SendMessage(Handle, SCI_FORMATRANGE, draw, fr);
end;

function TScintilla.FormatRangeFull(draw: Boolean; fr: PFormatRangeFull): Integer;
begin
  Result := SendMessage(Handle, SCI_FORMATRANGEFULL, draw, fr);
end;

procedure TScintilla.SetChangeHistory(changeHistory: Integer);
begin
  SendMessage(Handle, SCI_SETCHANGEHISTORY, changeHistory, 0);
end;

function TScintilla.GetChangeHistory(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCHANGEHISTORY, 0, 0);
end;

procedure TScintilla.SetUndoSelectionHistory(undoSelectionHistory: Integer);
begin
  SendMessage(Handle, SCI_SETUNDOSELECTIONHISTORY, undoSelectionHistory, 0);
end;

function TScintilla.GetUndoSelectionHistory(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETUNDOSELECTIONHISTORY, 0, 0);
end;

procedure TScintilla.SetSelectionSerialized(selectionString: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETSELECTIONSERIALIZED, 0, LPARAM(selectionString));
end;

function TScintilla.GetSelectionSerialized(selectionString: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONSERIALIZED, 0, LPARAM(selectionString));
end;

function TScintilla.GetFirstVisibleLine(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETFIRSTVISIBLELINE, 0, 0);
end;

function TScintilla.GetLine(line: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINE, line, LPARAM(text));
end;

function TScintilla.GetLineCount(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINECOUNT, 0, 0);
end;

procedure TScintilla.AllocateLines(lines: Integer);
begin
  SendMessage(Handle, SCI_ALLOCATELINES, lines, 0);
end;

procedure TScintilla.SetMarginLeft(pixelWidth: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINLEFT, 0, pixelWidth);
end;

function TScintilla.GetMarginLeft(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINLEFT, 0, 0);
end;

procedure TScintilla.SetMarginRight(pixelWidth: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINRIGHT, 0, pixelWidth);
end;

function TScintilla.GetMarginRight(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINRIGHT, 0, 0);
end;

function TScintilla.GetModify(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETMODIFY, 0, 0);
end;

procedure TScintilla.SetSel(anchor: Integer; caret: Integer);
begin
  SendMessage(Handle, SCI_SETSEL, anchor, caret);
end;

function TScintilla.GetSelText(text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELTEXT, 0, LPARAM(text));
end;

function TScintilla.GetTextRange(tr: PTextRange): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTEXTRANGE, 0, tr);
end;

function TScintilla.GetTextRangeFull(tr: PTextRangeFull): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTEXTRANGEFULL, 0, tr);
end;

procedure TScintilla.HideSelection(hide: Boolean);
begin
  SendMessage(Handle, SCI_HIDESELECTION, hide, 0);
end;

function TScintilla.GetSelectionHidden(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONHIDDEN, 0, 0);
end;

function TScintilla.PointXFromPosition(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POINTXFROMPOSITION, 0, pos);
end;

function TScintilla.PointYFromPosition(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POINTYFROMPOSITION, 0, pos);
end;

function TScintilla.LineFromPosition(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_LINEFROMPOSITION, pos, 0);
end;

function TScintilla.PositionFromLine(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POSITIONFROMLINE, line, 0);
end;

procedure TScintilla.LineScroll(columns: Integer; lines: Integer);
begin
  SendMessage(Handle, SCI_LINESCROLL, columns, lines);
end;

procedure TScintilla.ScrollCaret();
begin
  SendMessage(Handle, SCI_SCROLLCARET, 0, 0);
end;

procedure TScintilla.ScrollRange(secondary: Integer; primary: Integer);
begin
  SendMessage(Handle, SCI_SCROLLRANGE, secondary, primary);
end;

procedure TScintilla.ReplaceSel(text: PAnsiChar);
begin
  SendMessage(Handle, SCI_REPLACESEL, 0, LPARAM(text));
end;

procedure TScintilla.SetReadOnly(readOnly: Boolean);
begin
  SendMessage(Handle, SCI_SETREADONLY, readOnly, 0);
end;

procedure TScintilla.Null();
begin
  SendMessage(Handle, SCI_NULL, 0, 0);
end;

function TScintilla.CanPaste(): Boolean;
begin
  Result := SendMessage(Handle, SCI_CANPASTE, 0, 0);
end;

function TScintilla.CanUndo(): Boolean;
begin
  Result := SendMessage(Handle, SCI_CANUNDO, 0, 0);
end;

procedure TScintilla.EmptyUndoBuffer();
begin
  SendMessage(Handle, SCI_EMPTYUNDOBUFFER, 0, 0);
end;

procedure TScintilla.Undo();
begin
  SendMessage(Handle, SCI_UNDO, 0, 0);
end;

procedure TScintilla.Cut();
begin
  SendMessage(Handle, SCI_CUT, 0, 0);
end;

procedure TScintilla.Copy();
begin
  SendMessage(Handle, SCI_COPY, 0, 0);
end;

procedure TScintilla.Paste();
begin
  SendMessage(Handle, SCI_PASTE, 0, 0);
end;

procedure TScintilla.Clear();
begin
  SendMessage(Handle, SCI_CLEAR, 0, 0);
end;

procedure TScintilla.SetText(text: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETTEXT, 0, LPARAM(text));
end;

function TScintilla.GetText(length: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTEXT, length, LPARAM(text));
end;

function TScintilla.GetTextLength(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTEXTLENGTH, 0, 0);
end;

function TScintilla.GetDirectFunction(): Pointer;
begin
  Result := SendMessage(Handle, SCI_GETDIRECTFUNCTION, 0, 0);
end;

function TScintilla.GetDirectStatusFunction(): Pointer;
begin
  Result := SendMessage(Handle, SCI_GETDIRECTSTATUSFUNCTION, 0, 0);
end;

function TScintilla.GetDirectPointer(): Pointer;
begin
  Result := SendMessage(Handle, SCI_GETDIRECTPOINTER, 0, 0);
end;

procedure TScintilla.SetOvertype(overType: Boolean);
begin
  SendMessage(Handle, SCI_SETOVERTYPE, overType, 0);
end;

function TScintilla.GetOvertype(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETOVERTYPE, 0, 0);
end;

procedure TScintilla.SetCaretWidth(pixelWidth: Integer);
begin
  SendMessage(Handle, SCI_SETCARETWIDTH, pixelWidth, 0);
end;

function TScintilla.GetCaretWidth(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCARETWIDTH, 0, 0);
end;

procedure TScintilla.SetTargetStart(start: Integer);
begin
  SendMessage(Handle, SCI_SETTARGETSTART, start, 0);
end;

function TScintilla.GetTargetStart(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTARGETSTART, 0, 0);
end;

procedure TScintilla.SetTargetStartVirtualSpace(space: Integer);
begin
  SendMessage(Handle, SCI_SETTARGETSTARTVIRTUALSPACE, space, 0);
end;

function TScintilla.GetTargetStartVirtualSpace(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTARGETSTARTVIRTUALSPACE, 0, 0);
end;

procedure TScintilla.SetTargetEnd(end: Integer);
begin
  SendMessage(Handle, SCI_SETTARGETEND, end, 0);
end;

function TScintilla.GetTargetEnd(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTARGETEND, 0, 0);
end;

procedure TScintilla.SetTargetEndVirtualSpace(space: Integer);
begin
  SendMessage(Handle, SCI_SETTARGETENDVIRTUALSPACE, space, 0);
end;

function TScintilla.GetTargetEndVirtualSpace(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTARGETENDVIRTUALSPACE, 0, 0);
end;

procedure TScintilla.SetTargetRange(start: Integer; end: Integer);
begin
  SendMessage(Handle, SCI_SETTARGETRANGE, start, end);
end;

function TScintilla.GetTargetText(text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTARGETTEXT, 0, LPARAM(text));
end;

procedure TScintilla.TargetFromSelection();
begin
  SendMessage(Handle, SCI_TARGETFROMSELECTION, 0, 0);
end;

procedure TScintilla.TargetWholeDocument();
begin
  SendMessage(Handle, SCI_TARGETWHOLEDOCUMENT, 0, 0);
end;

function TScintilla.ReplaceTarget(length: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_REPLACETARGET, length, LPARAM(text));
end;

function TScintilla.ReplaceTargetRE(length: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_REPLACETARGETRE, length, LPARAM(text));
end;

function TScintilla.ReplaceTargetMinimal(length: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_REPLACETARGETMINIMAL, length, LPARAM(text));
end;

function TScintilla.SearchInTarget(length: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_SEARCHINTARGET, length, LPARAM(text));
end;

procedure TScintilla.SetSearchFlags(searchFlags: Integer);
begin
  SendMessage(Handle, SCI_SETSEARCHFLAGS, searchFlags, 0);
end;

function TScintilla.GetSearchFlags(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSEARCHFLAGS, 0, 0);
end;

procedure TScintilla.CallTipShow(pos: Integer; definition: PAnsiChar);
begin
  SendMessage(Handle, SCI_CALLTIPSHOW, pos, LPARAM(definition));
end;

procedure TScintilla.CallTipCancel();
begin
  SendMessage(Handle, SCI_CALLTIPCANCEL, 0, 0);
end;

function TScintilla.CallTipActive(): Boolean;
begin
  Result := SendMessage(Handle, SCI_CALLTIPACTIVE, 0, 0);
end;

function TScintilla.CallTipPosStart(): Integer;
begin
  Result := SendMessage(Handle, SCI_CALLTIPPOSSTART, 0, 0);
end;

procedure TScintilla.CallTipSetPosStart(posStart: Integer);
begin
  SendMessage(Handle, SCI_CALLTIPSETPOSSTART, posStart, 0);
end;

procedure TScintilla.CallTipSetHlt(highlightStart: Integer; highlightEnd: Integer);
begin
  SendMessage(Handle, SCI_CALLTIPSETHLT, highlightStart, highlightEnd);
end;

procedure TScintilla.CallTipSetBack(back: TColor);
begin
  SendMessage(Handle, SCI_CALLTIPSETBACK, back, 0);
end;

procedure TScintilla.CallTipSetFore(fore: TColor);
begin
  SendMessage(Handle, SCI_CALLTIPSETFORE, fore, 0);
end;

procedure TScintilla.CallTipSetForeHlt(fore: TColor);
begin
  SendMessage(Handle, SCI_CALLTIPSETFOREHLT, fore, 0);
end;

procedure TScintilla.CallTipUseStyle(tabSize: Integer);
begin
  SendMessage(Handle, SCI_CALLTIPUSESTYLE, tabSize, 0);
end;

procedure TScintilla.CallTipSetPosition(above: Boolean);
begin
  SendMessage(Handle, SCI_CALLTIPSETPOSITION, above, 0);
end;

function TScintilla.VisibleFromDocLine(docLine: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_VISIBLEFROMDOCLINE, docLine, 0);
end;

function TScintilla.DocLineFromVisible(displayLine: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_DOCLINEFROMVISIBLE, displayLine, 0);
end;

function TScintilla.WrapCount(docLine: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_WRAPCOUNT, docLine, 0);
end;

procedure TScintilla.SetFoldLevel(line: Integer; level: Integer);
begin
  SendMessage(Handle, SCI_SETFOLDLEVEL, line, level);
end;

function TScintilla.GetFoldLevel(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETFOLDLEVEL, line, 0);
end;

function TScintilla.GetLastChild(line: Integer; level: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLASTCHILD, line, level);
end;

function TScintilla.GetFoldParent(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETFOLDPARENT, line, 0);
end;

procedure TScintilla.ShowLines(lineStart: Integer; lineEnd: Integer);
begin
  SendMessage(Handle, SCI_SHOWLINES, lineStart, lineEnd);
end;

procedure TScintilla.HideLines(lineStart: Integer; lineEnd: Integer);
begin
  SendMessage(Handle, SCI_HIDELINES, lineStart, lineEnd);
end;

function TScintilla.GetLineVisible(line: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETLINEVISIBLE, line, 0);
end;

function TScintilla.GetAllLinesVisible(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETALLLINESVISIBLE, 0, 0);
end;

procedure TScintilla.SetFoldExpanded(line: Integer; expanded: Boolean);
begin
  SendMessage(Handle, SCI_SETFOLDEXPANDED, line, expanded);
end;

function TScintilla.GetFoldExpanded(line: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETFOLDEXPANDED, line, 0);
end;

procedure TScintilla.ToggleFold(line: Integer);
begin
  SendMessage(Handle, SCI_TOGGLEFOLD, line, 0);
end;

procedure TScintilla.ToggleFoldShowText(line: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_TOGGLEFOLDSHOWTEXT, line, LPARAM(text));
end;

procedure TScintilla.FoldDisplayTextSetStyle(style: Integer);
begin
  SendMessage(Handle, SCI_FOLDDISPLAYTEXTSETSTYLE, style, 0);
end;

function TScintilla.FoldDisplayTextGetStyle(): Integer;
begin
  Result := SendMessage(Handle, SCI_FOLDDISPLAYTEXTGETSTYLE, 0, 0);
end;

procedure TScintilla.SetDefaultFoldDisplayText(text: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETDEFAULTFOLDDISPLAYTEXT, 0, LPARAM(text));
end;

function TScintilla.GetDefaultFoldDisplayText(text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETDEFAULTFOLDDISPLAYTEXT, 0, LPARAM(text));
end;

procedure TScintilla.FoldLine(line: Integer; action: Integer);
begin
  SendMessage(Handle, SCI_FOLDLINE, line, action);
end;

procedure TScintilla.FoldChildren(line: Integer; action: Integer);
begin
  SendMessage(Handle, SCI_FOLDCHILDREN, line, action);
end;

procedure TScintilla.ExpandChildren(line: Integer; level: Integer);
begin
  SendMessage(Handle, SCI_EXPANDCHILDREN, line, level);
end;

procedure TScintilla.FoldAll(action: Integer);
begin
  SendMessage(Handle, SCI_FOLDALL, action, 0);
end;

procedure TScintilla.EnsureVisible(line: Integer);
begin
  SendMessage(Handle, SCI_ENSUREVISIBLE, line, 0);
end;

procedure TScintilla.SetAutomaticFold(automaticFold: Integer);
begin
  SendMessage(Handle, SCI_SETAUTOMATICFOLD, automaticFold, 0);
end;

function TScintilla.GetAutomaticFold(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETAUTOMATICFOLD, 0, 0);
end;

procedure TScintilla.SetFoldFlags(flags: Integer);
begin
  SendMessage(Handle, SCI_SETFOLDFLAGS, flags, 0);
end;

procedure TScintilla.EnsureVisibleEnforcePolicy(line: Integer);
begin
  SendMessage(Handle, SCI_ENSUREVISIBLEENFORCEPOLICY, line, 0);
end;

procedure TScintilla.SetTabIndents(tabIndents: Boolean);
begin
  SendMessage(Handle, SCI_SETTABINDENTS, tabIndents, 0);
end;

function TScintilla.GetTabIndents(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETTABINDENTS, 0, 0);
end;

procedure TScintilla.SetBackSpaceUnIndents(bsUnIndents: Boolean);
begin
  SendMessage(Handle, SCI_SETBACKSPACEUNINDENTS, bsUnIndents, 0);
end;

function TScintilla.GetBackSpaceUnIndents(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETBACKSPACEUNINDENTS, 0, 0);
end;

procedure TScintilla.SetMouseDwellTime(periodMilliseconds: Integer);
begin
  SendMessage(Handle, SCI_SETMOUSEDWELLTIME, periodMilliseconds, 0);
end;

function TScintilla.GetMouseDwellTime(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMOUSEDWELLTIME, 0, 0);
end;

function TScintilla.WordStartPosition(pos: Integer; onlyWordCharacters: Boolean): Integer;
begin
  Result := SendMessage(Handle, SCI_WORDSTARTPOSITION, pos, onlyWordCharacters);
end;

function TScintilla.WordEndPosition(pos: Integer; onlyWordCharacters: Boolean): Integer;
begin
  Result := SendMessage(Handle, SCI_WORDENDPOSITION, pos, onlyWordCharacters);
end;

function TScintilla.IsRangeWord(start: Integer; end: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_ISRANGEWORD, start, end);
end;

procedure TScintilla.SetIdleStyling(idleStyling: Integer);
begin
  SendMessage(Handle, SCI_SETIDLESTYLING, idleStyling, 0);
end;

function TScintilla.GetIdleStyling(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETIDLESTYLING, 0, 0);
end;

procedure TScintilla.SetWrapMode(wrapMode: Integer);
begin
  SendMessage(Handle, SCI_SETWRAPMODE, wrapMode, 0);
end;

function TScintilla.GetWrapMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWRAPMODE, 0, 0);
end;

procedure TScintilla.SetWrapVisualFlags(wrapVisualFlags: Integer);
begin
  SendMessage(Handle, SCI_SETWRAPVISUALFLAGS, wrapVisualFlags, 0);
end;

function TScintilla.GetWrapVisualFlags(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWRAPVISUALFLAGS, 0, 0);
end;

procedure TScintilla.SetWrapVisualFlagsLocation(wrapVisualFlagsLocation: Integer);
begin
  SendMessage(Handle, SCI_SETWRAPVISUALFLAGSLOCATION, wrapVisualFlagsLocation, 0);
end;

function TScintilla.GetWrapVisualFlagsLocation(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWRAPVISUALFLAGSLOCATION, 0, 0);
end;

procedure TScintilla.SetWrapStartIndent(indent: Integer);
begin
  SendMessage(Handle, SCI_SETWRAPSTARTINDENT, indent, 0);
end;

function TScintilla.GetWrapStartIndent(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWRAPSTARTINDENT, 0, 0);
end;

procedure TScintilla.SetWrapIndentMode(wrapIndentMode: Integer);
begin
  SendMessage(Handle, SCI_SETWRAPINDENTMODE, wrapIndentMode, 0);
end;

function TScintilla.GetWrapIndentMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWRAPINDENTMODE, 0, 0);
end;

procedure TScintilla.SetLayoutCache(cacheMode: Integer);
begin
  SendMessage(Handle, SCI_SETLAYOUTCACHE, cacheMode, 0);
end;

function TScintilla.GetLayoutCache(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLAYOUTCACHE, 0, 0);
end;

procedure TScintilla.SetScrollWidth(pixelWidth: Integer);
begin
  SendMessage(Handle, SCI_SETSCROLLWIDTH, pixelWidth, 0);
end;

function TScintilla.GetScrollWidth(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSCROLLWIDTH, 0, 0);
end;

procedure TScintilla.SetScrollWidthTracking(tracking: Boolean);
begin
  SendMessage(Handle, SCI_SETSCROLLWIDTHTRACKING, tracking, 0);
end;

function TScintilla.GetScrollWidthTracking(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETSCROLLWIDTHTRACKING, 0, 0);
end;

function TScintilla.TextWidth(style: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_TEXTWIDTH, style, LPARAM(text));
end;

procedure TScintilla.SetEndAtLastLine(endAtLastLine: Boolean);
begin
  SendMessage(Handle, SCI_SETENDATLASTLINE, endAtLastLine, 0);
end;

function TScintilla.GetEndAtLastLine(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETENDATLASTLINE, 0, 0);
end;

function TScintilla.TextHeight(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_TEXTHEIGHT, line, 0);
end;

procedure TScintilla.SetVScrollBar(visible: Boolean);
begin
  SendMessage(Handle, SCI_SETVSCROLLBAR, visible, 0);
end;

function TScintilla.GetVScrollBar(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETVSCROLLBAR, 0, 0);
end;

procedure TScintilla.AppendText(length: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_APPENDTEXT, length, LPARAM(text));
end;

function TScintilla.GetPhasesDraw(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPHASESDRAW, 0, 0);
end;

procedure TScintilla.SetPhasesDraw(phases: Integer);
begin
  SendMessage(Handle, SCI_SETPHASESDRAW, phases, 0);
end;

procedure TScintilla.SetFontQuality(fontQuality: Integer);
begin
  SendMessage(Handle, SCI_SETFONTQUALITY, fontQuality, 0);
end;

function TScintilla.GetFontQuality(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETFONTQUALITY, 0, 0);
end;

procedure TScintilla.SetFirstVisibleLine(displayLine: Integer);
begin
  SendMessage(Handle, SCI_SETFIRSTVISIBLELINE, displayLine, 0);
end;

procedure TScintilla.SetMultiPaste(multiPaste: Integer);
begin
  SendMessage(Handle, SCI_SETMULTIPASTE, multiPaste, 0);
end;

function TScintilla.GetMultiPaste(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMULTIPASTE, 0, 0);
end;

function TScintilla.GetTag(tagNumber: Integer; tagValue: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTAG, tagNumber, LPARAM(tagValue));
end;

procedure TScintilla.LinesJoin();
begin
  SendMessage(Handle, SCI_LINESJOIN, 0, 0);
end;

procedure TScintilla.LinesSplit(pixelWidth: Integer);
begin
  SendMessage(Handle, SCI_LINESSPLIT, pixelWidth, 0);
end;

procedure TScintilla.SetFoldMarginColour(useSetting: Boolean; back: TColor);
begin
  SendMessage(Handle, SCI_SETFOLDMARGINCOLOUR, useSetting, back);
end;

procedure TScintilla.SetFoldMarginHiColour(useSetting: Boolean; fore: TColor);
begin
  SendMessage(Handle, SCI_SETFOLDMARGINHICOLOUR, useSetting, fore);
end;

procedure TScintilla.SetAccessibility(accessibility: Integer);
begin
  SendMessage(Handle, SCI_SETACCESSIBILITY, accessibility, 0);
end;

function TScintilla.GetAccessibility(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETACCESSIBILITY, 0, 0);
end;

procedure TScintilla.LineDown();
begin
  SendMessage(Handle, SCI_LINEDOWN, 0, 0);
end;

procedure TScintilla.LineDownExtend();
begin
  SendMessage(Handle, SCI_LINEDOWNEXTEND, 0, 0);
end;

procedure TScintilla.LineUp();
begin
  SendMessage(Handle, SCI_LINEUP, 0, 0);
end;

procedure TScintilla.LineUpExtend();
begin
  SendMessage(Handle, SCI_LINEUPEXTEND, 0, 0);
end;

procedure TScintilla.CharLeft();
begin
  SendMessage(Handle, SCI_CHARLEFT, 0, 0);
end;

procedure TScintilla.CharLeftExtend();
begin
  SendMessage(Handle, SCI_CHARLEFTEXTEND, 0, 0);
end;

procedure TScintilla.CharRight();
begin
  SendMessage(Handle, SCI_CHARRIGHT, 0, 0);
end;

procedure TScintilla.CharRightExtend();
begin
  SendMessage(Handle, SCI_CHARRIGHTEXTEND, 0, 0);
end;

procedure TScintilla.WordLeft();
begin
  SendMessage(Handle, SCI_WORDLEFT, 0, 0);
end;

procedure TScintilla.WordLeftExtend();
begin
  SendMessage(Handle, SCI_WORDLEFTEXTEND, 0, 0);
end;

procedure TScintilla.WordRight();
begin
  SendMessage(Handle, SCI_WORDRIGHT, 0, 0);
end;

procedure TScintilla.WordRightExtend();
begin
  SendMessage(Handle, SCI_WORDRIGHTEXTEND, 0, 0);
end;

procedure TScintilla.Home();
begin
  SendMessage(Handle, SCI_HOME, 0, 0);
end;

procedure TScintilla.HomeExtend();
begin
  SendMessage(Handle, SCI_HOMEEXTEND, 0, 0);
end;

procedure TScintilla.LineEnd();
begin
  SendMessage(Handle, SCI_LINEEND, 0, 0);
end;

procedure TScintilla.LineEndExtend();
begin
  SendMessage(Handle, SCI_LINEENDEXTEND, 0, 0);
end;

procedure TScintilla.DocumentStart();
begin
  SendMessage(Handle, SCI_DOCUMENTSTART, 0, 0);
end;

procedure TScintilla.DocumentStartExtend();
begin
  SendMessage(Handle, SCI_DOCUMENTSTARTEXTEND, 0, 0);
end;

procedure TScintilla.DocumentEnd();
begin
  SendMessage(Handle, SCI_DOCUMENTEND, 0, 0);
end;

procedure TScintilla.DocumentEndExtend();
begin
  SendMessage(Handle, SCI_DOCUMENTENDEXTEND, 0, 0);
end;

procedure TScintilla.PageUp();
begin
  SendMessage(Handle, SCI_PAGEUP, 0, 0);
end;

procedure TScintilla.PageUpExtend();
begin
  SendMessage(Handle, SCI_PAGEUPEXTEND, 0, 0);
end;

procedure TScintilla.PageDown();
begin
  SendMessage(Handle, SCI_PAGEDOWN, 0, 0);
end;

procedure TScintilla.PageDownExtend();
begin
  SendMessage(Handle, SCI_PAGEDOWNEXTEND, 0, 0);
end;

procedure TScintilla.EditToggleOvertype();
begin
  SendMessage(Handle, SCI_EDITTOGGLEOVERTYPE, 0, 0);
end;

procedure TScintilla.Cancel();
begin
  SendMessage(Handle, SCI_CANCEL, 0, 0);
end;

procedure TScintilla.DeleteBack();
begin
  SendMessage(Handle, SCI_DELETEBACK, 0, 0);
end;

procedure TScintilla.Tab();
begin
  SendMessage(Handle, SCI_TAB, 0, 0);
end;

procedure TScintilla.LineIndent();
begin
  SendMessage(Handle, SCI_LINEINDENT, 0, 0);
end;

procedure TScintilla.BackTab();
begin
  SendMessage(Handle, SCI_BACKTAB, 0, 0);
end;

procedure TScintilla.LineDedent();
begin
  SendMessage(Handle, SCI_LINEDEDENT, 0, 0);
end;

procedure TScintilla.NewLine();
begin
  SendMessage(Handle, SCI_NEWLINE, 0, 0);
end;

procedure TScintilla.FormFeed();
begin
  SendMessage(Handle, SCI_FORMFEED, 0, 0);
end;

procedure TScintilla.VCHome();
begin
  SendMessage(Handle, SCI_VCHOME, 0, 0);
end;

procedure TScintilla.VCHomeExtend();
begin
  SendMessage(Handle, SCI_VCHOMEEXTEND, 0, 0);
end;

procedure TScintilla.ZoomIn();
begin
  SendMessage(Handle, SCI_ZOOMIN, 0, 0);
end;

procedure TScintilla.ZoomOut();
begin
  SendMessage(Handle, SCI_ZOOMOUT, 0, 0);
end;

procedure TScintilla.DelWordLeft();
begin
  SendMessage(Handle, SCI_DELWORDLEFT, 0, 0);
end;

procedure TScintilla.DelWordRight();
begin
  SendMessage(Handle, SCI_DELWORDRIGHT, 0, 0);
end;

procedure TScintilla.DelWordRightEnd();
begin
  SendMessage(Handle, SCI_DELWORDRIGHTEND, 0, 0);
end;

procedure TScintilla.LineCut();
begin
  SendMessage(Handle, SCI_LINECUT, 0, 0);
end;

procedure TScintilla.LineDelete();
begin
  SendMessage(Handle, SCI_LINEDELETE, 0, 0);
end;

procedure TScintilla.LineTranspose();
begin
  SendMessage(Handle, SCI_LINETRANSPOSE, 0, 0);
end;

procedure TScintilla.LineReverse();
begin
  SendMessage(Handle, SCI_LINEREVERSE, 0, 0);
end;

procedure TScintilla.LineDuplicate();
begin
  SendMessage(Handle, SCI_LINEDUPLICATE, 0, 0);
end;

procedure TScintilla.LowerCase();
begin
  SendMessage(Handle, SCI_LOWERCASE, 0, 0);
end;

procedure TScintilla.UpperCase();
begin
  SendMessage(Handle, SCI_UPPERCASE, 0, 0);
end;

procedure TScintilla.LineScrollDown();
begin
  SendMessage(Handle, SCI_LINESCROLLDOWN, 0, 0);
end;

procedure TScintilla.LineScrollUp();
begin
  SendMessage(Handle, SCI_LINESCROLLUP, 0, 0);
end;

procedure TScintilla.DeleteBackNotLine();
begin
  SendMessage(Handle, SCI_DELETEBACKNOTLINE, 0, 0);
end;

procedure TScintilla.HomeDisplay();
begin
  SendMessage(Handle, SCI_HOMEDISPLAY, 0, 0);
end;

procedure TScintilla.HomeDisplayExtend();
begin
  SendMessage(Handle, SCI_HOMEDISPLAYEXTEND, 0, 0);
end;

procedure TScintilla.LineEndDisplay();
begin
  SendMessage(Handle, SCI_LINEENDDISPLAY, 0, 0);
end;

procedure TScintilla.LineEndDisplayExtend();
begin
  SendMessage(Handle, SCI_LINEENDDISPLAYEXTEND, 0, 0);
end;

procedure TScintilla.HomeWrap();
begin
  SendMessage(Handle, SCI_HOMEWRAP, 0, 0);
end;

procedure TScintilla.HomeWrapExtend();
begin
  SendMessage(Handle, SCI_HOMEWRAPEXTEND, 0, 0);
end;

procedure TScintilla.LineEndWrap();
begin
  SendMessage(Handle, SCI_LINEENDWRAP, 0, 0);
end;

procedure TScintilla.LineEndWrapExtend();
begin
  SendMessage(Handle, SCI_LINEENDWRAPEXTEND, 0, 0);
end;

procedure TScintilla.VCHomeWrap();
begin
  SendMessage(Handle, SCI_VCHOMEWRAP, 0, 0);
end;

procedure TScintilla.VCHomeWrapExtend();
begin
  SendMessage(Handle, SCI_VCHOMEWRAPEXTEND, 0, 0);
end;

procedure TScintilla.LineCopy();
begin
  SendMessage(Handle, SCI_LINECOPY, 0, 0);
end;

procedure TScintilla.MoveCaretInsideView();
begin
  SendMessage(Handle, SCI_MOVECARETINSIDEVIEW, 0, 0);
end;

function TScintilla.LineLength(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_LINELENGTH, line, 0);
end;

procedure TScintilla.BraceHighlight(posA: Integer; posB: Integer);
begin
  SendMessage(Handle, SCI_BRACEHIGHLIGHT, posA, posB);
end;

procedure TScintilla.BraceHighlightIndicator(useSetting: Boolean; indicator: Integer);
begin
  SendMessage(Handle, SCI_BRACEHIGHLIGHTINDICATOR, useSetting, indicator);
end;

procedure TScintilla.BraceBadLight(pos: Integer);
begin
  SendMessage(Handle, SCI_BRACEBADLIGHT, pos, 0);
end;

procedure TScintilla.BraceBadLightIndicator(useSetting: Boolean; indicator: Integer);
begin
  SendMessage(Handle, SCI_BRACEBADLIGHTINDICATOR, useSetting, indicator);
end;

function TScintilla.BraceMatch(pos: Integer; maxReStyle: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_BRACEMATCH, pos, maxReStyle);
end;

function TScintilla.BraceMatchNext(pos: Integer; startPos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_BRACEMATCHNEXT, pos, startPos);
end;

function TScintilla.GetViewEOL(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETVIEWEOL, 0, 0);
end;

procedure TScintilla.SetViewEOL(visible: Boolean);
begin
  SendMessage(Handle, SCI_SETVIEWEOL, visible, 0);
end;

function TScintilla.GetDocPointer(): Pointer;
begin
  Result := SendMessage(Handle, SCI_GETDOCPOINTER, 0, 0);
end;

procedure TScintilla.SetDocPointer(doc: Pointer);
begin
  SendMessage(Handle, SCI_SETDOCPOINTER, 0, LPARAM(doc));
end;

procedure TScintilla.SetModEventMask(eventMask: Integer);
begin
  SendMessage(Handle, SCI_SETMODEVENTMASK, eventMask, 0);
end;

function TScintilla.GetEdgeColumn(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETEDGECOLUMN, 0, 0);
end;

procedure TScintilla.SetEdgeColumn(column: Integer);
begin
  SendMessage(Handle, SCI_SETEDGECOLUMN, column, 0);
end;

function TScintilla.GetEdgeMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETEDGEMODE, 0, 0);
end;

procedure TScintilla.SetEdgeMode(edgeMode: Integer);
begin
  SendMessage(Handle, SCI_SETEDGEMODE, edgeMode, 0);
end;

function TScintilla.GetEdgeColour(): TColor;
begin
  Result := SendMessage(Handle, SCI_GETEDGECOLOUR, 0, 0);
end;

procedure TScintilla.SetEdgeColour(edgeColour: TColor);
begin
  SendMessage(Handle, SCI_SETEDGECOLOUR, edgeColour, 0);
end;

procedure TScintilla.MultiEdgeAddLine(column: Integer; edgeColour: TColor);
begin
  SendMessage(Handle, SCI_MULTIEDGEADDLINE, column, edgeColour);
end;

procedure TScintilla.MultiEdgeClearAll();
begin
  SendMessage(Handle, SCI_MULTIEDGECLEARALL, 0, 0);
end;

function TScintilla.GetMultiEdgeColumn(which: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMULTIEDGECOLUMN, which, 0);
end;

procedure TScintilla.SearchAnchor();
begin
  SendMessage(Handle, SCI_SEARCHANCHOR, 0, 0);
end;

function TScintilla.SearchNext(searchFlags: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_SEARCHNEXT, searchFlags, LPARAM(text));
end;

function TScintilla.SearchPrev(searchFlags: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_SEARCHPREV, searchFlags, LPARAM(text));
end;

function TScintilla.LinesOnScreen(): Integer;
begin
  Result := SendMessage(Handle, SCI_LINESONSCREEN, 0, 0);
end;

procedure TScintilla.UsePopUp(popUpMode: Integer);
begin
  SendMessage(Handle, SCI_USEPOPUP, popUpMode, 0);
end;

function TScintilla.SelectionIsRectangle(): Boolean;
begin
  Result := SendMessage(Handle, SCI_SELECTIONISRECTANGLE, 0, 0);
end;

procedure TScintilla.SetZoom(zoomInPoints: Integer);
begin
  SendMessage(Handle, SCI_SETZOOM, zoomInPoints, 0);
end;

function TScintilla.GetZoom(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETZOOM, 0, 0);
end;

function TScintilla.CreateDocument(bytes: Integer; documentOptions: Integer): Pointer;
begin
  Result := SendMessage(Handle, SCI_CREATEDOCUMENT, bytes, documentOptions);
end;

procedure TScintilla.AddRefDocument(doc: Pointer);
begin
  SendMessage(Handle, SCI_ADDREFDOCUMENT, 0, LPARAM(doc));
end;

procedure TScintilla.ReleaseDocument(doc: Pointer);
begin
  SendMessage(Handle, SCI_RELEASEDOCUMENT, 0, LPARAM(doc));
end;

function TScintilla.GetDocumentOptions(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETDOCUMENTOPTIONS, 0, 0);
end;

function TScintilla.GetModEventMask(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMODEVENTMASK, 0, 0);
end;

procedure TScintilla.SetCommandEvents(commandEvents: Boolean);
begin
  SendMessage(Handle, SCI_SETCOMMANDEVENTS, commandEvents, 0);
end;

function TScintilla.GetCommandEvents(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETCOMMANDEVENTS, 0, 0);
end;

procedure TScintilla.SetFocus(focus: Boolean);
begin
  SendMessage(Handle, SCI_SETFOCUS, focus, 0);
end;

function TScintilla.GetFocus(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETFOCUS, 0, 0);
end;

procedure TScintilla.SetStatus(status: Integer);
begin
  SendMessage(Handle, SCI_SETSTATUS, status, 0);
end;

function TScintilla.GetStatus(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSTATUS, 0, 0);
end;

procedure TScintilla.SetMouseDownCaptures(captures: Boolean);
begin
  SendMessage(Handle, SCI_SETMOUSEDOWNCAPTURES, captures, 0);
end;

function TScintilla.GetMouseDownCaptures(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETMOUSEDOWNCAPTURES, 0, 0);
end;

procedure TScintilla.SetMouseWheelCaptures(captures: Boolean);
begin
  SendMessage(Handle, SCI_SETMOUSEWHEELCAPTURES, captures, 0);
end;

function TScintilla.GetMouseWheelCaptures(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETMOUSEWHEELCAPTURES, 0, 0);
end;

procedure TScintilla.SetCursor(cursorType: Integer);
begin
  SendMessage(Handle, SCI_SETCURSOR, cursorType, 0);
end;

function TScintilla.GetCursor(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCURSOR, 0, 0);
end;

procedure TScintilla.SetControlCharSymbol(symbol: Integer);
begin
  SendMessage(Handle, SCI_SETCONTROLCHARSYMBOL, symbol, 0);
end;

function TScintilla.GetControlCharSymbol(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCONTROLCHARSYMBOL, 0, 0);
end;

procedure TScintilla.WordPartLeft();
begin
  SendMessage(Handle, SCI_WORDPARTLEFT, 0, 0);
end;

procedure TScintilla.WordPartLeftExtend();
begin
  SendMessage(Handle, SCI_WORDPARTLEFTEXTEND, 0, 0);
end;

procedure TScintilla.WordPartRight();
begin
  SendMessage(Handle, SCI_WORDPARTRIGHT, 0, 0);
end;

procedure TScintilla.WordPartRightExtend();
begin
  SendMessage(Handle, SCI_WORDPARTRIGHTEXTEND, 0, 0);
end;

procedure TScintilla.SetVisiblePolicy(visiblePolicy: Integer; visibleSlop: Integer);
begin
  SendMessage(Handle, SCI_SETVISIBLEPOLICY, visiblePolicy, visibleSlop);
end;

procedure TScintilla.DelLineLeft();
begin
  SendMessage(Handle, SCI_DELLINELEFT, 0, 0);
end;

procedure TScintilla.DelLineRight();
begin
  SendMessage(Handle, SCI_DELLINERIGHT, 0, 0);
end;

procedure TScintilla.SetXOffset(xOffset: Integer);
begin
  SendMessage(Handle, SCI_SETXOFFSET, xOffset, 0);
end;

function TScintilla.GetXOffset(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETXOFFSET, 0, 0);
end;

procedure TScintilla.ChooseCaretX();
begin
  SendMessage(Handle, SCI_CHOOSECARETX, 0, 0);
end;

procedure TScintilla.GrabFocus();
begin
  SendMessage(Handle, SCI_GRABFOCUS, 0, 0);
end;

procedure TScintilla.SetXCaretPolicy(caretPolicy: Integer; caretSlop: Integer);
begin
  SendMessage(Handle, SCI_SETXCARETPOLICY, caretPolicy, caretSlop);
end;

procedure TScintilla.SetYCaretPolicy(caretPolicy: Integer; caretSlop: Integer);
begin
  SendMessage(Handle, SCI_SETYCARETPOLICY, caretPolicy, caretSlop);
end;

procedure TScintilla.SetPrintWrapMode(wrapMode: Integer);
begin
  SendMessage(Handle, SCI_SETPRINTWRAPMODE, wrapMode, 0);
end;

function TScintilla.GetPrintWrapMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPRINTWRAPMODE, 0, 0);
end;

procedure TScintilla.SetHotspotActiveFore(useSetting: Boolean; fore: TColor);
begin
  SendMessage(Handle, SCI_SETHOTSPOTACTIVEFORE, useSetting, fore);
end;

function TScintilla.GetHotspotActiveFore(): TColor;
begin
  Result := SendMessage(Handle, SCI_GETHOTSPOTACTIVEFORE, 0, 0);
end;

procedure TScintilla.SetHotspotActiveBack(useSetting: Boolean; back: TColor);
begin
  SendMessage(Handle, SCI_SETHOTSPOTACTIVEBACK, useSetting, back);
end;

function TScintilla.GetHotspotActiveBack(): TColor;
begin
  Result := SendMessage(Handle, SCI_GETHOTSPOTACTIVEBACK, 0, 0);
end;

procedure TScintilla.SetHotspotActiveUnderline(underline: Boolean);
begin
  SendMessage(Handle, SCI_SETHOTSPOTACTIVEUNDERLINE, underline, 0);
end;

function TScintilla.GetHotspotActiveUnderline(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETHOTSPOTACTIVEUNDERLINE, 0, 0);
end;

procedure TScintilla.SetHotspotSingleLine(singleLine: Boolean);
begin
  SendMessage(Handle, SCI_SETHOTSPOTSINGLELINE, singleLine, 0);
end;

function TScintilla.GetHotspotSingleLine(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETHOTSPOTSINGLELINE, 0, 0);
end;

procedure TScintilla.ParaDown();
begin
  SendMessage(Handle, SCI_PARADOWN, 0, 0);
end;

procedure TScintilla.ParaDownExtend();
begin
  SendMessage(Handle, SCI_PARADOWNEXTEND, 0, 0);
end;

procedure TScintilla.ParaUp();
begin
  SendMessage(Handle, SCI_PARAUP, 0, 0);
end;

procedure TScintilla.ParaUpExtend();
begin
  SendMessage(Handle, SCI_PARAUPEXTEND, 0, 0);
end;

function TScintilla.PositionBefore(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POSITIONBEFORE, pos, 0);
end;

function TScintilla.PositionAfter(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POSITIONAFTER, pos, 0);
end;

function TScintilla.PositionRelative(pos: Integer; relative: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POSITIONRELATIVE, pos, relative);
end;

function TScintilla.PositionRelativeCodeUnits(pos: Integer; relative: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_POSITIONRELATIVECODEUNITS, pos, relative);
end;

procedure TScintilla.CopyRange(start: Integer; end: Integer);
begin
  SendMessage(Handle, SCI_COPYRANGE, start, end);
end;

procedure TScintilla.CopyText(length: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_COPYTEXT, length, LPARAM(text));
end;

procedure TScintilla.SetSelectionMode(selectionMode: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONMODE, selectionMode, 0);
end;

procedure TScintilla.ChangeSelectionMode(selectionMode: Integer);
begin
  SendMessage(Handle, SCI_CHANGESELECTIONMODE, selectionMode, 0);
end;

function TScintilla.GetSelectionMode(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONMODE, 0, 0);
end;

procedure TScintilla.SetMoveExtendsSelection(moveExtendsSelection: Boolean);
begin
  SendMessage(Handle, SCI_SETMOVEEXTENDSSELECTION, moveExtendsSelection, 0);
end;

function TScintilla.GetMoveExtendsSelection(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETMOVEEXTENDSSELECTION, 0, 0);
end;

function TScintilla.GetLineSelStartPosition(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINESELSTARTPOSITION, line, 0);
end;

function TScintilla.GetLineSelEndPosition(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINESELENDPOSITION, line, 0);
end;

procedure TScintilla.LineDownRectExtend();
begin
  SendMessage(Handle, SCI_LINEDOWNRECTEXTEND, 0, 0);
end;

procedure TScintilla.LineUpRectExtend();
begin
  SendMessage(Handle, SCI_LINEUPRECTEXTEND, 0, 0);
end;

procedure TScintilla.CharLeftRectExtend();
begin
  SendMessage(Handle, SCI_CHARLEFTRECTEXTEND, 0, 0);
end;

procedure TScintilla.CharRightRectExtend();
begin
  SendMessage(Handle, SCI_CHARRIGHTRECTEXTEND, 0, 0);
end;

procedure TScintilla.HomeRectExtend();
begin
  SendMessage(Handle, SCI_HOMERECTEXTEND, 0, 0);
end;

procedure TScintilla.VCHomeRectExtend();
begin
  SendMessage(Handle, SCI_VCHOMERECTEXTEND, 0, 0);
end;

procedure TScintilla.LineEndRectExtend();
begin
  SendMessage(Handle, SCI_LINEENDRECTEXTEND, 0, 0);
end;

procedure TScintilla.PageUpRectExtend();
begin
  SendMessage(Handle, SCI_PAGEUPRECTEXTEND, 0, 0);
end;

procedure TScintilla.PageDownRectExtend();
begin
  SendMessage(Handle, SCI_PAGEDOWNRECTEXTEND, 0, 0);
end;

procedure TScintilla.StutteredPageUp();
begin
  SendMessage(Handle, SCI_STUTTEREDPAGEUP, 0, 0);
end;

procedure TScintilla.StutteredPageUpExtend();
begin
  SendMessage(Handle, SCI_STUTTEREDPAGEUPEXTEND, 0, 0);
end;

procedure TScintilla.StutteredPageDown();
begin
  SendMessage(Handle, SCI_STUTTEREDPAGEDOWN, 0, 0);
end;

procedure TScintilla.StutteredPageDownExtend();
begin
  SendMessage(Handle, SCI_STUTTEREDPAGEDOWNEXTEND, 0, 0);
end;

procedure TScintilla.WordLeftEnd();
begin
  SendMessage(Handle, SCI_WORDLEFTEND, 0, 0);
end;

procedure TScintilla.WordLeftEndExtend();
begin
  SendMessage(Handle, SCI_WORDLEFTENDEXTEND, 0, 0);
end;

procedure TScintilla.WordRightEnd();
begin
  SendMessage(Handle, SCI_WORDRIGHTEND, 0, 0);
end;

procedure TScintilla.WordRightEndExtend();
begin
  SendMessage(Handle, SCI_WORDRIGHTENDEXTEND, 0, 0);
end;

procedure TScintilla.SetWhitespaceChars(characters: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETWHITESPACECHARS, 0, LPARAM(characters));
end;

function TScintilla.GetWhitespaceChars(characters: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETWHITESPACECHARS, 0, LPARAM(characters));
end;

procedure TScintilla.SetPunctuationChars(characters: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETPUNCTUATIONCHARS, 0, LPARAM(characters));
end;

function TScintilla.GetPunctuationChars(characters: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPUNCTUATIONCHARS, 0, LPARAM(characters));
end;

procedure TScintilla.SetCharsDefault();
begin
  SendMessage(Handle, SCI_SETCHARSDEFAULT, 0, 0);
end;

function TScintilla.AutoCGetCurrent(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETCURRENT, 0, 0);
end;

function TScintilla.AutoCGetCurrentText(text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETCURRENTTEXT, 0, LPARAM(text));
end;

procedure TScintilla.AutoCSetCaseInsensitiveBehaviour(behaviour: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR, behaviour, 0);
end;

function TScintilla.AutoCGetCaseInsensitiveBehaviour(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETCASEINSENSITIVEBEHAVIOUR, 0, 0);
end;

procedure TScintilla.AutoCSetMulti(multi: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETMULTI, multi, 0);
end;

function TScintilla.AutoCGetMulti(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETMULTI, 0, 0);
end;

procedure TScintilla.AutoCSetOrder(order: Integer);
begin
  SendMessage(Handle, SCI_AUTOCSETORDER, order, 0);
end;

function TScintilla.AutoCGetOrder(): Integer;
begin
  Result := SendMessage(Handle, SCI_AUTOCGETORDER, 0, 0);
end;

procedure TScintilla.Allocate(bytes: Integer);
begin
  SendMessage(Handle, SCI_ALLOCATE, bytes, 0);
end;

function TScintilla.TargetAsUTF8(s: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_TARGETASUTF8, 0, LPARAM(s));
end;

procedure TScintilla.SetLengthForEncode(bytes: Integer);
begin
  SendMessage(Handle, SCI_SETLENGTHFORENCODE, bytes, 0);
end;

function TScintilla.EncodedFromUTF8(utf8: PAnsiChar; encoded: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_ENCODEDFROMUTF8, utf8, LPARAM(encoded));
end;

function TScintilla.FindColumn(line: Integer; column: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_FINDCOLUMN, line, column);
end;

function TScintilla.GetCaretSticky(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCARETSTICKY, 0, 0);
end;

procedure TScintilla.SetCaretSticky(useCaretStickyBehaviour: Integer);
begin
  SendMessage(Handle, SCI_SETCARETSTICKY, useCaretStickyBehaviour, 0);
end;

procedure TScintilla.ToggleCaretSticky();
begin
  SendMessage(Handle, SCI_TOGGLECARETSTICKY, 0, 0);
end;

procedure TScintilla.SetPasteConvertEndings(convert: Boolean);
begin
  SendMessage(Handle, SCI_SETPASTECONVERTENDINGS, convert, 0);
end;

function TScintilla.GetPasteConvertEndings(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETPASTECONVERTENDINGS, 0, 0);
end;

procedure TScintilla.ReplaceRectangular(length: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_REPLACERECTANGULAR, length, LPARAM(text));
end;

procedure TScintilla.SelectionDuplicate();
begin
  SendMessage(Handle, SCI_SELECTIONDUPLICATE, 0, 0);
end;

procedure TScintilla.SetCaretLineBackAlpha(alpha: Integer);
begin
  SendMessage(Handle, SCI_SETCARETLINEBACKALPHA, alpha, 0);
end;

function TScintilla.GetCaretLineBackAlpha(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCARETLINEBACKALPHA, 0, 0);
end;

procedure TScintilla.SetCaretStyle(caretStyle: Integer);
begin
  SendMessage(Handle, SCI_SETCARETSTYLE, caretStyle, 0);
end;

function TScintilla.GetCaretStyle(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCARETSTYLE, 0, 0);
end;

procedure TScintilla.SetIndicatorCurrent(indicator: Integer);
begin
  SendMessage(Handle, SCI_SETINDICATORCURRENT, indicator, 0);
end;

function TScintilla.GetIndicatorCurrent(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETINDICATORCURRENT, 0, 0);
end;

procedure TScintilla.SetIndicatorValue(value: Integer);
begin
  SendMessage(Handle, SCI_SETINDICATORVALUE, value, 0);
end;

function TScintilla.GetIndicatorValue(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETINDICATORVALUE, 0, 0);
end;

procedure TScintilla.IndicatorFillRange(start: Integer; lengthFill: Integer);
begin
  SendMessage(Handle, SCI_INDICATORFILLRANGE, start, lengthFill);
end;

procedure TScintilla.IndicatorClearRange(start: Integer; lengthClear: Integer);
begin
  SendMessage(Handle, SCI_INDICATORCLEARRANGE, start, lengthClear);
end;

function TScintilla.IndicatorAllOnFor(pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICATORALLONFOR, pos, 0);
end;

function TScintilla.IndicatorValueAt(indicator: Integer; pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICATORVALUEAT, indicator, pos);
end;

function TScintilla.IndicatorStart(indicator: Integer; pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICATORSTART, indicator, pos);
end;

function TScintilla.IndicatorEnd(indicator: Integer; pos: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICATOREND, indicator, pos);
end;

procedure TScintilla.SetPositionCache(size: Integer);
begin
  SendMessage(Handle, SCI_SETPOSITIONCACHE, size, 0);
end;

function TScintilla.GetPositionCache(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPOSITIONCACHE, 0, 0);
end;

procedure TScintilla.SetLayoutThreads(threads: Integer);
begin
  SendMessage(Handle, SCI_SETLAYOUTTHREADS, threads, 0);
end;

function TScintilla.GetLayoutThreads(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLAYOUTTHREADS, 0, 0);
end;

procedure TScintilla.CopyAllowLine();
begin
  SendMessage(Handle, SCI_COPYALLOWLINE, 0, 0);
end;

procedure TScintilla.CutAllowLine();
begin
  SendMessage(Handle, SCI_CUTALLOWLINE, 0, 0);
end;

procedure TScintilla.SetCopySeparator(separator: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETCOPYSEPARATOR, 0, LPARAM(separator));
end;

function TScintilla.GetCopySeparator(separator: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETCOPYSEPARATOR, 0, LPARAM(separator));
end;

function TScintilla.GetCharacterPointer(): Pointer;
begin
  Result := SendMessage(Handle, SCI_GETCHARACTERPOINTER, 0, 0);
end;

function TScintilla.GetRangePointer(start: Integer; lengthRange: Integer): Pointer;
begin
  Result := SendMessage(Handle, SCI_GETRANGEPOINTER, start, lengthRange);
end;

function TScintilla.GetGapPosition(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETGAPPOSITION, 0, 0);
end;

procedure TScintilla.IndicSetAlpha(indicator: Integer; alpha: Integer);
begin
  SendMessage(Handle, SCI_INDICSETALPHA, indicator, alpha);
end;

function TScintilla.IndicGetAlpha(indicator: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICGETALPHA, indicator, 0);
end;

procedure TScintilla.IndicSetOutlineAlpha(indicator: Integer; alpha: Integer);
begin
  SendMessage(Handle, SCI_INDICSETOUTLINEALPHA, indicator, alpha);
end;

function TScintilla.IndicGetOutlineAlpha(indicator: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDICGETOUTLINEALPHA, indicator, 0);
end;

procedure TScintilla.SetExtraAscent(extraAscent: Integer);
begin
  SendMessage(Handle, SCI_SETEXTRAASCENT, extraAscent, 0);
end;

function TScintilla.GetExtraAscent(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETEXTRAASCENT, 0, 0);
end;

procedure TScintilla.SetExtraDescent(extraDescent: Integer);
begin
  SendMessage(Handle, SCI_SETEXTRADESCENT, extraDescent, 0);
end;

function TScintilla.GetExtraDescent(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETEXTRADESCENT, 0, 0);
end;

function TScintilla.MarkerSymbolDefined(markerNumber: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARKERSYMBOLDEFINED, markerNumber, 0);
end;

procedure TScintilla.MarginSetText(line: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_MARGINSETTEXT, line, LPARAM(text));
end;

function TScintilla.MarginGetText(line: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_MARGINGETTEXT, line, LPARAM(text));
end;

procedure TScintilla.MarginSetStyle(line: Integer; style: Integer);
begin
  SendMessage(Handle, SCI_MARGINSETSTYLE, line, style);
end;

function TScintilla.MarginGetStyle(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_MARGINGETSTYLE, line, 0);
end;

procedure TScintilla.MarginSetStyles(line: Integer; styles: PAnsiChar);
begin
  SendMessage(Handle, SCI_MARGINSETSTYLES, line, LPARAM(styles));
end;

function TScintilla.MarginGetStyles(line: Integer; styles: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_MARGINGETSTYLES, line, LPARAM(styles));
end;

procedure TScintilla.MarginTextClearAll();
begin
  SendMessage(Handle, SCI_MARGINTEXTCLEARALL, 0, 0);
end;

procedure TScintilla.MarginSetStyleOffset(style: Integer);
begin
  SendMessage(Handle, SCI_MARGINSETSTYLEOFFSET, style, 0);
end;

function TScintilla.MarginGetStyleOffset(): Integer;
begin
  Result := SendMessage(Handle, SCI_MARGINGETSTYLEOFFSET, 0, 0);
end;

procedure TScintilla.SetMarginOptions(marginOptions: Integer);
begin
  SendMessage(Handle, SCI_SETMARGINOPTIONS, marginOptions, 0);
end;

function TScintilla.GetMarginOptions(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMARGINOPTIONS, 0, 0);
end;

procedure TScintilla.AnnotationSetText(line: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_ANNOTATIONSETTEXT, line, LPARAM(text));
end;

function TScintilla.AnnotationGetText(line: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_ANNOTATIONGETTEXT, line, LPARAM(text));
end;

procedure TScintilla.AnnotationSetStyle(line: Integer; style: Integer);
begin
  SendMessage(Handle, SCI_ANNOTATIONSETSTYLE, line, style);
end;

function TScintilla.AnnotationGetStyle(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_ANNOTATIONGETSTYLE, line, 0);
end;

procedure TScintilla.AnnotationSetStyles(line: Integer; styles: PAnsiChar);
begin
  SendMessage(Handle, SCI_ANNOTATIONSETSTYLES, line, LPARAM(styles));
end;

function TScintilla.AnnotationGetStyles(line: Integer; styles: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_ANNOTATIONGETSTYLES, line, LPARAM(styles));
end;

function TScintilla.AnnotationGetLines(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_ANNOTATIONGETLINES, line, 0);
end;

procedure TScintilla.AnnotationClearAll();
begin
  SendMessage(Handle, SCI_ANNOTATIONCLEARALL, 0, 0);
end;

procedure TScintilla.AnnotationSetVisible(visible: Integer);
begin
  SendMessage(Handle, SCI_ANNOTATIONSETVISIBLE, visible, 0);
end;

function TScintilla.AnnotationGetVisible(): Integer;
begin
  Result := SendMessage(Handle, SCI_ANNOTATIONGETVISIBLE, 0, 0);
end;

procedure TScintilla.AnnotationSetStyleOffset(style: Integer);
begin
  SendMessage(Handle, SCI_ANNOTATIONSETSTYLEOFFSET, style, 0);
end;

function TScintilla.AnnotationGetStyleOffset(): Integer;
begin
  Result := SendMessage(Handle, SCI_ANNOTATIONGETSTYLEOFFSET, 0, 0);
end;

procedure TScintilla.ReleaseAllExtendedStyles();
begin
  SendMessage(Handle, SCI_RELEASEALLEXTENDEDSTYLES, 0, 0);
end;

function TScintilla.AllocateExtendedStyles(numberStyles: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_ALLOCATEEXTENDEDSTYLES, numberStyles, 0);
end;

procedure TScintilla.AddUndoAction(token: Integer; flags: Integer);
begin
  SendMessage(Handle, SCI_ADDUNDOACTION, token, flags);
end;

function TScintilla.CharPositionFromPoint(x: Integer; y: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_CHARPOSITIONFROMPOINT, x, y);
end;

function TScintilla.CharPositionFromPointClose(x: Integer; y: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_CHARPOSITIONFROMPOINTCLOSE, x, y);
end;

procedure TScintilla.SetMouseSelectionRectangularSwitch(mouseSelectionRectangularSwitch: Boolean);
begin
  SendMessage(Handle, SCI_SETMOUSESELECTIONRECTANGULARSWITCH, mouseSelectionRectangularSwitch, 0);
end;

function TScintilla.GetMouseSelectionRectangularSwitch(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETMOUSESELECTIONRECTANGULARSWITCH, 0, 0);
end;

procedure TScintilla.SetMultipleSelection(multipleSelection: Boolean);
begin
  SendMessage(Handle, SCI_SETMULTIPLESELECTION, multipleSelection, 0);
end;

function TScintilla.GetMultipleSelection(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETMULTIPLESELECTION, 0, 0);
end;

procedure TScintilla.SetAdditionalSelectionTyping(additionalSelectionTyping: Boolean);
begin
  SendMessage(Handle, SCI_SETADDITIONALSELECTIONTYPING, additionalSelectionTyping, 0);
end;

function TScintilla.GetAdditionalSelectionTyping(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETADDITIONALSELECTIONTYPING, 0, 0);
end;

procedure TScintilla.SetAdditionalCaretsBlink(additionalCaretsBlink: Boolean);
begin
  SendMessage(Handle, SCI_SETADDITIONALCARETSBLINK, additionalCaretsBlink, 0);
end;

function TScintilla.GetAdditionalCaretsBlink(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETADDITIONALCARETSBLINK, 0, 0);
end;

procedure TScintilla.SetAdditionalCaretsVisible(additionalCaretsVisible: Boolean);
begin
  SendMessage(Handle, SCI_SETADDITIONALCARETSVISIBLE, additionalCaretsVisible, 0);
end;

function TScintilla.GetAdditionalCaretsVisible(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETADDITIONALCARETSVISIBLE, 0, 0);
end;

function TScintilla.GetSelections(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONS, 0, 0);
end;

function TScintilla.GetSelectionEmpty(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONEMPTY, 0, 0);
end;

procedure TScintilla.ClearSelections();
begin
  SendMessage(Handle, SCI_CLEARSELECTIONS, 0, 0);
end;

procedure TScintilla.SetSelection(caret: Integer; anchor: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTION, caret, anchor);
end;

procedure TScintilla.AddSelection(caret: Integer; anchor: Integer);
begin
  SendMessage(Handle, SCI_ADDSELECTION, caret, anchor);
end;

function TScintilla.SelectionFromPoint(x: Integer; y: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_SELECTIONFROMPOINT, x, y);
end;

procedure TScintilla.DropSelectionN(selection: Integer);
begin
  SendMessage(Handle, SCI_DROPSELECTIONN, selection, 0);
end;

procedure TScintilla.SetMainSelection(selection: Integer);
begin
  SendMessage(Handle, SCI_SETMAINSELECTION, selection, 0);
end;

function TScintilla.GetMainSelection(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETMAINSELECTION, 0, 0);
end;

procedure TScintilla.SetSelectionNCaret(selection: Integer; caret: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONNCARET, selection, caret);
end;

function TScintilla.GetSelectionNCaret(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNCARET, selection, 0);
end;

procedure TScintilla.SetSelectionNAnchor(selection: Integer; anchor: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONNANCHOR, selection, anchor);
end;

function TScintilla.GetSelectionNAnchor(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNANCHOR, selection, 0);
end;

procedure TScintilla.SetSelectionNCaretVirtualSpace(selection: Integer; space: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONNCARETVIRTUALSPACE, selection, space);
end;

function TScintilla.GetSelectionNCaretVirtualSpace(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNCARETVIRTUALSPACE, selection, 0);
end;

procedure TScintilla.SetSelectionNAnchorVirtualSpace(selection: Integer; space: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONNANCHORVIRTUALSPACE, selection, space);
end;

function TScintilla.GetSelectionNAnchorVirtualSpace(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNANCHORVIRTUALSPACE, selection, 0);
end;

procedure TScintilla.SetSelectionNStart(selection: Integer; anchor: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONNSTART, selection, anchor);
end;

function TScintilla.GetSelectionNStart(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNSTART, selection, 0);
end;

function TScintilla.GetSelectionNStartVirtualSpace(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNSTARTVIRTUALSPACE, selection, 0);
end;

procedure TScintilla.SetSelectionNEnd(selection: Integer; caret: Integer);
begin
  SendMessage(Handle, SCI_SETSELECTIONNEND, selection, caret);
end;

function TScintilla.GetSelectionNEndVirtualSpace(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNENDVIRTUALSPACE, selection, 0);
end;

function TScintilla.GetSelectionNEnd(selection: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSELECTIONNEND, selection, 0);
end;

procedure TScintilla.SetRectangularSelectionCaret(caret: Integer);
begin
  SendMessage(Handle, SCI_SETRECTANGULARSELECTIONCARET, caret, 0);
end;

function TScintilla.GetRectangularSelectionCaret(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETRECTANGULARSELECTIONCARET, 0, 0);
end;

procedure TScintilla.SetRectangularSelectionAnchor(anchor: Integer);
begin
  SendMessage(Handle, SCI_SETRECTANGULARSELECTIONANCHOR, anchor, 0);
end;

function TScintilla.GetRectangularSelectionAnchor(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETRECTANGULARSELECTIONANCHOR, 0, 0);
end;

procedure TScintilla.SetRectangularSelectionCaretVirtualSpace(space: Integer);
begin
  SendMessage(Handle, SCI_SETRECTANGULARSELECTIONCARETVIRTUALSPACE, space, 0);
end;

function TScintilla.GetRectangularSelectionCaretVirtualSpace(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE, 0, 0);
end;

procedure TScintilla.SetRectangularSelectionAnchorVirtualSpace(space: Integer);
begin
  SendMessage(Handle, SCI_SETRECTANGULARSELECTIONANCHORVIRTUALSPACE, space, 0);
end;

function TScintilla.GetRectangularSelectionAnchorVirtualSpace(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE, 0, 0);
end;

procedure TScintilla.SetVirtualSpaceOptions(virtualSpaceOptions: Integer);
begin
  SendMessage(Handle, SCI_SETVIRTUALSPACEOPTIONS, virtualSpaceOptions, 0);
end;

function TScintilla.GetVirtualSpaceOptions(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETVIRTUALSPACEOPTIONS, 0, 0);
end;

procedure TScintilla.SetRectangularSelectionModifier(modifier: Integer);
begin
  SendMessage(Handle, SCI_SETRECTANGULARSELECTIONMODIFIER, modifier, 0);
end;

function TScintilla.GetRectangularSelectionModifier(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETRECTANGULARSELECTIONMODIFIER, 0, 0);
end;

procedure TScintilla.SetAdditionalSelFore(fore: TColor);
begin
  SendMessage(Handle, SCI_SETADDITIONALSELFORE, fore, 0);
end;

procedure TScintilla.SetAdditionalSelBack(back: TColor);
begin
  SendMessage(Handle, SCI_SETADDITIONALSELBACK, back, 0);
end;

procedure TScintilla.SetAdditionalSelAlpha(alpha: Integer);
begin
  SendMessage(Handle, SCI_SETADDITIONALSELALPHA, alpha, 0);
end;

function TScintilla.GetAdditionalSelAlpha(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETADDITIONALSELALPHA, 0, 0);
end;

procedure TScintilla.SetAdditionalCaretFore(fore: TColor);
begin
  SendMessage(Handle, SCI_SETADDITIONALCARETFORE, fore, 0);
end;

function TScintilla.GetAdditionalCaretFore(): TColor;
begin
  Result := SendMessage(Handle, SCI_GETADDITIONALCARETFORE, 0, 0);
end;

procedure TScintilla.RotateSelection();
begin
  SendMessage(Handle, SCI_ROTATESELECTION, 0, 0);
end;

procedure TScintilla.SwapMainAnchorCaret();
begin
  SendMessage(Handle, SCI_SWAPMAINANCHORCARET, 0, 0);
end;

procedure TScintilla.MultipleSelectAddNext();
begin
  SendMessage(Handle, SCI_MULTIPLESELECTADDNEXT, 0, 0);
end;

procedure TScintilla.MultipleSelectAddEach();
begin
  SendMessage(Handle, SCI_MULTIPLESELECTADDEACH, 0, 0);
end;

function TScintilla.ChangeLexerState(start: Integer; end: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_CHANGELEXERSTATE, start, end);
end;

function TScintilla.ContractedFoldNext(lineStart: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_CONTRACTEDFOLDNEXT, lineStart, 0);
end;

procedure TScintilla.VerticalCentreCaret();
begin
  SendMessage(Handle, SCI_VERTICALCENTRECARET, 0, 0);
end;

procedure TScintilla.MoveSelectedLinesUp();
begin
  SendMessage(Handle, SCI_MOVESELECTEDLINESUP, 0, 0);
end;

procedure TScintilla.MoveSelectedLinesDown();
begin
  SendMessage(Handle, SCI_MOVESELECTEDLINESDOWN, 0, 0);
end;

procedure TScintilla.SetIdentifier(identifier: Integer);
begin
  SendMessage(Handle, SCI_SETIDENTIFIER, identifier, 0);
end;

function TScintilla.GetIdentifier(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETIDENTIFIER, 0, 0);
end;

procedure TScintilla.RGBAImageSetWidth(width: Integer);
begin
  SendMessage(Handle, SCI_RGBAIMAGESETWIDTH, width, 0);
end;

procedure TScintilla.RGBAImageSetHeight(height: Integer);
begin
  SendMessage(Handle, SCI_RGBAIMAGESETHEIGHT, height, 0);
end;

procedure TScintilla.RGBAImageSetScale(scalePercent: Integer);
begin
  SendMessage(Handle, SCI_RGBAIMAGESETSCALE, scalePercent, 0);
end;

procedure TScintilla.MarkerDefineRGBAImage(markerNumber: Integer; pixels: PAnsiChar);
begin
  SendMessage(Handle, SCI_MARKERDEFINERGBAIMAGE, markerNumber, LPARAM(pixels));
end;

procedure TScintilla.RegisterRGBAImage(type: Integer; pixels: PAnsiChar);
begin
  SendMessage(Handle, SCI_REGISTERRGBAIMAGE, type, LPARAM(pixels));
end;

procedure TScintilla.ScrollToStart();
begin
  SendMessage(Handle, SCI_SCROLLTOSTART, 0, 0);
end;

procedure TScintilla.ScrollToEnd();
begin
  SendMessage(Handle, SCI_SCROLLTOEND, 0, 0);
end;

procedure TScintilla.SetTechnology(technology: Integer);
begin
  SendMessage(Handle, SCI_SETTECHNOLOGY, technology, 0);
end;

function TScintilla.GetTechnology(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETTECHNOLOGY, 0, 0);
end;

function TScintilla.CreateLoader(bytes: Integer; documentOptions: Integer): Pointer;
begin
  Result := SendMessage(Handle, SCI_CREATELOADER, bytes, documentOptions);
end;

procedure TScintilla.FindIndicatorShow(start: Integer; end: Integer);
begin
  SendMessage(Handle, SCI_FINDINDICATORSHOW, start, end);
end;

procedure TScintilla.FindIndicatorFlash(start: Integer; end: Integer);
begin
  SendMessage(Handle, SCI_FINDINDICATORFLASH, start, end);
end;

procedure TScintilla.FindIndicatorHide();
begin
  SendMessage(Handle, SCI_FINDINDICATORHIDE, 0, 0);
end;

procedure TScintilla.VCHomeDisplay();
begin
  SendMessage(Handle, SCI_VCHOMEDISPLAY, 0, 0);
end;

procedure TScintilla.VCHomeDisplayExtend();
begin
  SendMessage(Handle, SCI_VCHOMEDISPLAYEXTEND, 0, 0);
end;

function TScintilla.GetCaretLineVisibleAlways(): Boolean;
begin
  Result := SendMessage(Handle, SCI_GETCARETLINEVISIBLEALWAYS, 0, 0);
end;

procedure TScintilla.SetCaretLineVisibleAlways(alwaysVisible: Boolean);
begin
  SendMessage(Handle, SCI_SETCARETLINEVISIBLEALWAYS, alwaysVisible, 0);
end;

procedure TScintilla.SetLineEndTypesAllowed(lineEndBitSet: Integer);
begin
  SendMessage(Handle, SCI_SETLINEENDTYPESALLOWED, lineEndBitSet, 0);
end;

function TScintilla.GetLineEndTypesAllowed(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINEENDTYPESALLOWED, 0, 0);
end;

function TScintilla.GetLineEndTypesActive(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINEENDTYPESACTIVE, 0, 0);
end;

procedure TScintilla.SetRepresentation(encodedCharacter: PAnsiChar; representation: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETREPRESENTATION, encodedCharacter, LPARAM(representation));
end;

function TScintilla.GetRepresentation(encodedCharacter: PAnsiChar; representation: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETREPRESENTATION, encodedCharacter, LPARAM(representation));
end;

procedure TScintilla.ClearRepresentation(encodedCharacter: PAnsiChar);
begin
  SendMessage(Handle, SCI_CLEARREPRESENTATION, encodedCharacter, 0);
end;

procedure TScintilla.ClearAllRepresentations();
begin
  SendMessage(Handle, SCI_CLEARALLREPRESENTATIONS, 0, 0);
end;

procedure TScintilla.SetRepresentationAppearance(encodedCharacter: PAnsiChar; appearance: Integer);
begin
  SendMessage(Handle, SCI_SETREPRESENTATIONAPPEARANCE, encodedCharacter, appearance);
end;

function TScintilla.GetRepresentationAppearance(encodedCharacter: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETREPRESENTATIONAPPEARANCE, encodedCharacter, 0);
end;

procedure TScintilla.SetRepresentationColour(encodedCharacter: PAnsiChar; colour: TColorAlpha);
begin
  SendMessage(Handle, SCI_SETREPRESENTATIONCOLOUR, encodedCharacter, colour);
end;

function TScintilla.GetRepresentationColour(encodedCharacter: PAnsiChar): TColorAlpha;
begin
  Result := SendMessage(Handle, SCI_GETREPRESENTATIONCOLOUR, encodedCharacter, 0);
end;

procedure TScintilla.EOLAnnotationSetText(line: Integer; text: PAnsiChar);
begin
  SendMessage(Handle, SCI_EOLANNOTATIONSETTEXT, line, LPARAM(text));
end;

function TScintilla.EOLAnnotationGetText(line: Integer; text: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_EOLANNOTATIONGETTEXT, line, LPARAM(text));
end;

procedure TScintilla.EOLAnnotationSetStyle(line: Integer; style: Integer);
begin
  SendMessage(Handle, SCI_EOLANNOTATIONSETSTYLE, line, style);
end;

function TScintilla.EOLAnnotationGetStyle(line: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_EOLANNOTATIONGETSTYLE, line, 0);
end;

procedure TScintilla.EOLAnnotationClearAll();
begin
  SendMessage(Handle, SCI_EOLANNOTATIONCLEARALL, 0, 0);
end;

procedure TScintilla.EOLAnnotationSetVisible(visible: Integer);
begin
  SendMessage(Handle, SCI_EOLANNOTATIONSETVISIBLE, visible, 0);
end;

function TScintilla.EOLAnnotationGetVisible(): Integer;
begin
  Result := SendMessage(Handle, SCI_EOLANNOTATIONGETVISIBLE, 0, 0);
end;

procedure TScintilla.EOLAnnotationSetStyleOffset(style: Integer);
begin
  SendMessage(Handle, SCI_EOLANNOTATIONSETSTYLEOFFSET, style, 0);
end;

function TScintilla.EOLAnnotationGetStyleOffset(): Integer;
begin
  Result := SendMessage(Handle, SCI_EOLANNOTATIONGETSTYLEOFFSET, 0, 0);
end;

function TScintilla.SupportsFeature(feature: Integer): Boolean;
begin
  Result := SendMessage(Handle, SCI_SUPPORTSFEATURE, feature, 0);
end;

function TScintilla.GetLineCharacterIndex(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINECHARACTERINDEX, 0, 0);
end;

procedure TScintilla.AllocateLineCharacterIndex(lineCharacterIndex: Integer);
begin
  SendMessage(Handle, SCI_ALLOCATELINECHARACTERINDEX, lineCharacterIndex, 0);
end;

procedure TScintilla.ReleaseLineCharacterIndex(lineCharacterIndex: Integer);
begin
  SendMessage(Handle, SCI_RELEASELINECHARACTERINDEX, lineCharacterIndex, 0);
end;

function TScintilla.LineFromIndexPosition(pos: Integer; lineCharacterIndex: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_LINEFROMINDEXPOSITION, pos, lineCharacterIndex);
end;

function TScintilla.IndexPositionFromLine(line: Integer; lineCharacterIndex: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_INDEXPOSITIONFROMLINE, line, lineCharacterIndex);
end;

procedure TScintilla.StartRecord();
begin
  SendMessage(Handle, SCI_STARTRECORD, 0, 0);
end;

procedure TScintilla.StopRecord();
begin
  SendMessage(Handle, SCI_STOPRECORD, 0, 0);
end;

function TScintilla.GetLexer(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLEXER, 0, 0);
end;

procedure TScintilla.Colourise(start: Integer; end: Integer);
begin
  SendMessage(Handle, SCI_COLOURISE, start, end);
end;

procedure TScintilla.SetProperty(key: PAnsiChar; value: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETPROPERTY, key, LPARAM(value));
end;

procedure TScintilla.SetKeyWords(keyWordSet: Integer; keyWords: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETKEYWORDS, keyWordSet, LPARAM(keyWords));
end;

function TScintilla.GetProperty(key: PAnsiChar; value: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPROPERTY, key, LPARAM(value));
end;

function TScintilla.GetPropertyExpanded(key: PAnsiChar; value: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPROPERTYEXPANDED, key, LPARAM(value));
end;

function TScintilla.GetPropertyInt(key: PAnsiChar; defaultValue: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPROPERTYINT, key, defaultValue);
end;

function TScintilla.GetLexerLanguage(language: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLEXERLANGUAGE, 0, LPARAM(language));
end;

function TScintilla.PrivateLexerCall(operation: Integer; pointer: Pointer): Pointer;
begin
  Result := SendMessage(Handle, SCI_PRIVATELEXERCALL, operation, LPARAM(pointer));
end;

function TScintilla.PropertyNames(names: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_PROPERTYNAMES, 0, LPARAM(names));
end;

function TScintilla.PropertyType(name: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_PROPERTYTYPE, name, 0);
end;

function TScintilla.DescribeProperty(name: PAnsiChar; description: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_DESCRIBEPROPERTY, name, LPARAM(description));
end;

function TScintilla.DescribeKeyWordSets(descriptions: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_DESCRIBEKEYWORDSETS, 0, LPARAM(descriptions));
end;

function TScintilla.GetLineEndTypesSupported(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETLINEENDTYPESSUPPORTED, 0, 0);
end;

function TScintilla.AllocateSubStyles(styleBase: Integer; numberStyles: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_ALLOCATESUBSTYLES, styleBase, numberStyles);
end;

function TScintilla.GetSubStylesStart(styleBase: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSUBSTYLESSTART, styleBase, 0);
end;

function TScintilla.GetSubStylesLength(styleBase: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSUBSTYLESLENGTH, styleBase, 0);
end;

function TScintilla.GetStyleFromSubStyle(subStyle: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSTYLEFROMSUBSTYLE, subStyle, 0);
end;

function TScintilla.GetPrimaryStyleFromStyle(style: Integer): Integer;
begin
  Result := SendMessage(Handle, SCI_GETPRIMARYSTYLEFROMSTYLE, style, 0);
end;

procedure TScintilla.FreeSubStyles();
begin
  SendMessage(Handle, SCI_FREESUBSTYLES, 0, 0);
end;

procedure TScintilla.SetIdentifiers(style: Integer; identifiers: PAnsiChar);
begin
  SendMessage(Handle, SCI_SETIDENTIFIERS, style, LPARAM(identifiers));
end;

function TScintilla.DistanceToSecondaryStyles(): Integer;
begin
  Result := SendMessage(Handle, SCI_DISTANCETOSECONDARYSTYLES, 0, 0);
end;

function TScintilla.GetSubStyleBases(styles: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_GETSUBSTYLEBASES, 0, LPARAM(styles));
end;

function TScintilla.GetNamedStyles(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETNAMEDSTYLES, 0, 0);
end;

function TScintilla.NameOfStyle(style: Integer; name: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_NAMEOFSTYLE, style, LPARAM(name));
end;

function TScintilla.TagsOfStyle(style: Integer; tags: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_TAGSOFSTYLE, style, LPARAM(tags));
end;

function TScintilla.DescriptionOfStyle(style: Integer; description: PAnsiChar): Integer;
begin
  Result := SendMessage(Handle, SCI_DESCRIPTIONOFSTYLE, style, LPARAM(description));
end;

procedure TScintilla.SetILexer(ilexer: Pointer);
begin
  SendMessage(Handle, SCI_SETILEXER, 0, LPARAM(ilexer));
end;

function TScintilla.GetBidirectional(): Integer;
begin
  Result := SendMessage(Handle, SCI_GETBIDIRECTIONAL, 0, 0);
end;

procedure TScintilla.SetBidirectional(bidirectional: Integer);
begin
  SendMessage(Handle, SCI_SETBIDIRECTIONAL, bidirectional, 0);
end;

end.
