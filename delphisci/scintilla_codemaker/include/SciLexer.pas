unit SciLexer;

////////////////////////////////////////////////////////////////////////////////
// Unit    : SciLexer
// Purpose : Interface for Scintilla Lexer DLL
// Created : 05/03/2001
// Author  : Simon Steele (ss@pnotepad.org)
// History : 05/03/2001 Turned this into a proper VCL wrapper for Scintilla
//                      class window controls. SetFocus is not entirely right,
//                      and is overridden by the scintilla thing. To set focus do:
//                      Scintilla1.SetFocus(True);
//                      Windows.SetFocus(Scintilla1.Handle);
//                      There's no error checking yet, so make sure the DLL is
//                      present!
//                     	Daytime :): Added Event handling generation stuff, and
//                      some ported	types from scintilla.h so that event handling can work!
//           19/03/2001 Added FindText stuff, needs updating in the python...
//           25/03/2001 Changed SCI_REPLACESEL Wrapper variable order - it was wrong!
//		    27/05/2001 Re-Wrote the python generator, and changed the structure of the
//					control.
//           09/06/2001 Removed some function-less functions.
//           03/12/2001 Added WM_ERASEBKGND function to remove scroll-flicker. Thanks
//                  	to Gertjan Schuurmans and Jeff Cogswell.
//           15/02/2003 Extensive changes to make the control active at design time and
//                      expose a large number of properties (see KV comments)
//                      (kvlahos@london.edu)
//           15/03/2003 LoadFromStream and SaveToStream added which now
//                      properly handle Unicode.  Property CodeFolding added
//                      (kvlahos@london.edu)
//           05/11/2003 Workaround for Scintilla bug in GetSelText
//                      Updated for Scintilla 1.56 (works with later versions)
//                      Other improvements and bug fixes
//                      (kvlahos@london.edu)
//           01/03/2004 Python and Ruby Keywords and Styles added
//                      Keyboard customisation
//                      Help file added
//////////////////////////////////////////////////////////////////////////////////

// Most of this file is automatically generated from the Scintilla.iface interface definition
// file which contains any comments about the definitions. PasGen.py does the generation.

interface

{.$DEFINE DEBUG}

uses Classes, Windows, Controls, Forms, Messages, SysUtils, Graphics,  StdActns,
     SciSupport, ScintillaLanguageManager, SciKeyBindings;

var
  scmod : HMODULE;

const
  BorderStyles: array[TBorderStyle] of DWORD = (0, WS_BORDER);

{$DEFINE MACRO_SUPPORT}

type
  //++EventTypes
    TSCEvent_styleneeded = procedure(Sender : TObject; position : LongInt) of object;
    TSCEvent_charadded = procedure(Sender : TObject; ch : LongInt) of object;
    TSCEvent_savepointreached = procedure(Sender : TObject) of object;
    TSCEvent_savepointleft = procedure(Sender : TObject) of object;
    TSCEvent_modifyattemptro = procedure(Sender : TObject) of object;
    TSCEvent_key = procedure(Sender : TObject; ch : LongInt; modifiers : LongInt) of object;
    TSCEvent_doubleclick = procedure(Sender : TObject) of object;
    TSCEvent_updateui = procedure(Sender : TObject) of object;
    TSCEvent_modified = procedure(Sender : TObject; position : LongInt; modificationType : LongInt; text : PChar; length : LongInt; linesAdded : LongInt; line : LongInt; foldLevelNow : LongInt; foldLevelPrev : LongInt) of object;
    TSCEvent_macrorecord = procedure(Sender : TObject; message : LongInt; wParam : LongInt; lParam : LongInt) of object;
    TSCEvent_marginclick = procedure(Sender : TObject; modifiers : LongInt; position : LongInt; margin : LongInt) of object;
    TSCEvent_needshown = procedure(Sender : TObject; position : LongInt; length : LongInt) of object;
    TSCEvent_painted = procedure(Sender : TObject) of object;
    TSCEvent_userlistselection = procedure(Sender : TObject; listType : LongInt; text : PChar) of object;
    TSCEvent_uridropped = procedure(Sender : TObject; text : PChar) of object;
    TSCEvent_dwellstart = procedure(Sender : TObject; position : LongInt) of object;
    TSCEvent_dwellend = procedure(Sender : TObject; position : LongInt) of object;
    TSCEvent_zoom = procedure(Sender : TObject) of object;
    TSCEvent_hotspotclick = procedure(Sender : TObject; modifiers : LongInt; position : LongInt) of object;
    TSCEvent_hotspotdoubleclick = procedure(Sender : TObject; modifiers : LongInt; position : LongInt) of object;
    TSCEvent_calltipclick = procedure(Sender : TObject; position : LongInt) of object;
//--EventTypes
    TSCEventMsgSent = procedure(Sender : TObject; Msg : Integer; wParam, lParam : Longint) of object;

  TMarginType = (GUT_SYMBOL = 0, GUT_LINENUMBER = 1);
  TIndentationOption = (KeepIndent, TabIndents, BackSpaceUnIndents, IndentationGuides);
  TIndentationOptions = Set of TIndentationOption;
  TEOLStyle = (EOL_CRLF, EOL_CR, EOL_LF);

  TScintilla = class;

  TMargin = class(TPersistent)
  private
    fScintilla : TScintilla;
    fNumber : integer;
    function GetWidth: integer;
    procedure SetWidth(const Value: integer);
    function GetMarginType: TMarginType;
    procedure SetMarginType(const Value: TMarginType);
  public
    constructor Create(Scintilla : TScintilla; Number : integer);
    procedure Assign(Source: TPersistent); override;
  published
    property Width : integer read GetWidth write SetWidth;
    property MarginType : TMarginType read GetMarginType write SetMarginType;
  end;

  TScintilla = class(TWinControl)
  private
    FBorderStyle: TBorderStyle;
    FCreating: Boolean;
    SCPerform : TScintillaMessageFnc;
    sccmdctr : Pointer;
    FWantReturns: Boolean;
    FWantTabs: Boolean;
    //++EventPrivates
        FOnstyleneeded : TSCEvent_styleneeded;
        FOncharadded : TSCEvent_charadded;
        FOnsavepointreached : TSCEvent_savepointreached;
        FOnsavepointleft : TSCEvent_savepointleft;
        FOnmodifyattemptro : TSCEvent_modifyattemptro;
        FOnkey : TSCEvent_key;
        FOndoubleclick : TSCEvent_doubleclick;
        FOnupdateui : TSCEvent_updateui;
        FOnmodified : TSCEvent_modified;
        FOnmacrorecord : TSCEvent_macrorecord;
        FOnmarginclick : TSCEvent_marginclick;
        FOnneedshown : TSCEvent_needshown;
        FOnpainted : TSCEvent_painted;
        FOnuserlistselection : TSCEvent_userlistselection;
        FOnuridropped : TSCEvent_uridropped;
        FOndwellstart : TSCEvent_dwellstart;
        FOndwellend : TSCEvent_dwellend;
        FOnzoom : TSCEvent_zoom;
        FOnhotspotclick : TSCEvent_hotspotclick;
        FOnhotspotdoubleclick : TSCEvent_hotspotdoubleclick;
        FOncalltipclick : TSCEvent_calltipclick;
    //--EventPrivates
    FOnMsgSent : TSCEventMsgSent;
    FDummy : Boolean;
    procedure SetBorderStyle(Value: TBorderStyle);
    procedure CMCtl3DChanged(var Message: TMessage); message CM_CTL3DCHANGED;
    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
    procedure WMNCDestroy(var Message: TWMNCDestroy); message WM_NCDESTROY;
    procedure WMNotify(var Message: TWMNotify); message CN_NOTIFY;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure SetDummy(Value : Boolean);
    function GetIndentation: TIndentationOptions;
    procedure SetIndentation(const Value: TIndentationOptions);
  protected
    procedure CreateParams(var Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure DestroyWnd; override;
  published
    property Align;
    property Hint;
    property ShowHint;
    property ParentShowHint;
    property ParentFont;
    property BorderStyle: TBorderStyle read FBorderStyle write SetBorderStyle default bsSingle;
    //++EventProperties
    property OnStyleNeeded : TSCEvent_styleneeded read FOnstyleneeded write FOnstyleneeded;
    property OnCharAdded : TSCEvent_charadded read FOncharadded write FOncharadded;
    property OnSavePointReached : TSCEvent_savepointreached read FOnsavepointreached write FOnsavepointreached;
    property OnSavePointLeft : TSCEvent_savepointleft read FOnsavepointleft write FOnsavepointleft;
    property OnModifyAttemptRO : TSCEvent_modifyattemptro read FOnmodifyattemptro write FOnmodifyattemptro;
    property OnKey : TSCEvent_key read FOnkey write FOnkey;
    property OnDoubleClick : TSCEvent_doubleclick read FOndoubleclick write FOndoubleclick;
    property OnUpdateUI : TSCEvent_updateui read FOnupdateui write FOnupdateui;
    property OnModified : TSCEvent_modified read FOnmodified write FOnmodified;
    property OnMacroRecord : TSCEvent_macrorecord read FOnmacrorecord write FOnmacrorecord;
    property OnMarginClick : TSCEvent_marginclick read FOnmarginclick write FOnmarginclick;
    property OnNeedShown : TSCEvent_needshown read FOnneedshown write FOnneedshown;
    property OnPainted : TSCEvent_painted read FOnpainted write FOnpainted;
    property OnUserListSelection : TSCEvent_userlistselection read FOnuserlistselection write FOnuserlistselection;
    property OnURIDropped : TSCEvent_uridropped read FOnuridropped write FOnuridropped;
    property OnDwellStart : TSCEvent_dwellstart read FOndwellstart write FOndwellstart;
    property OnDwellEnd : TSCEvent_dwellend read FOndwellend write FOndwellend;
    property OnZoom : TSCEvent_zoom read FOnzoom write FOnzoom;
    property OnHotSpotClick : TSCEvent_hotspotclick read FOnhotspotclick write FOnhotspotclick;
    property OnHotSpotDoubleClick : TSCEvent_hotspotdoubleclick read FOnhotspotdoubleclick write FOnhotspotdoubleclick;
    property OnCallTipClick : TSCEvent_calltipclick read FOncalltipclick write FOncalltipclick;
    //--EventProperties
    property OnMsgSent : TSCEventMsgSent read FOnMsgSent Write FOnMsgSent;
  public
    constructor Create(AOwner: TComponent); override;
    procedure DefaultHandler(var Message); override;
    procedure LoadFromStream(Stream : TStream);
    procedure SaveToStream(Stream : TStream);
    procedure LoadFromFile(FileName : TFileName);
    procedure SaveToFile(FileName : TFileName);
		procedure GetRange(start,end_ : LongInt;var text : PChar);
		function  GetCurrentLineNumber : LongInt;
		function  GetCaretInLine : LongInt;
		function  RangeIsAllWhiteSpace(start,end_ : LongInt) : Boolean;
    function SPerform(Msg, wParam, lParam : Longint) : LongInt;
//++FuncDef
    procedure AddText(length : LongInt; text : PChar);
    procedure AddStyledText(length : LongInt; c : PChar);
    procedure InsertText(pos : LongInt; text : PChar);
    procedure ClearAll;
    procedure ClearDocumentStyle;
    function GetLength : LongInt;
    function GetCharAt(pos : LongInt) : LongInt;
    function GetCurrentPos : LongInt;
    function GetAnchor : LongInt;
    function GetStyleAt(pos : LongInt) : LongInt;
    procedure Redo;
    procedure SetUndoCollection(collectUndo : LongBool);
    procedure SelectAll;
    procedure SetSavePoint;
    function GetStyledText(tr : PTextRange) : LongInt;
    function CanRedo : LongBool;
    function MarkerLineFromHandle(handle : LongInt) : LongInt;
    procedure MarkerDeleteHandle(handle : LongInt);
    function GetUndoCollection : LongBool;
    function GetViewWS : LongInt;
    procedure SetViewWS(viewWS : LongInt);
    function PositionFromPoint(x : LongInt; y : LongInt) : LongInt;
    function PositionFromPointClose(x : LongInt; y : LongInt) : LongInt;
    procedure GotoLine(line : LongInt);
    procedure GotoPos(pos : LongInt);
    procedure SetAnchor(posAnchor : LongInt);
    function GetCurLine(length : LongInt; text : PChar) : LongInt;
    function GetEndStyled : LongInt;
    procedure ConvertEOLs(eolMode : LongInt);
    function GetEOLMode : LongInt;
    procedure SetEOLMode(eolMode : LongInt);
    procedure StartStyling(pos : LongInt; mask : LongInt);
    procedure SetStyling(length : LongInt; style : LongInt);
    function GetBufferedDraw : LongBool;
    procedure SetBufferedDraw(buffered : LongBool);
    procedure SetTabWidth(tabWidth : LongInt);
    function GetTabWidth : LongInt;
    procedure SetCodePage(codePage : LongInt);
    procedure SetUsePalette(usePalette : LongBool);
    procedure MarkerDefine(markerNumber : LongInt; markerSymbol : LongInt);
    procedure MarkerSetFore(markerNumber : LongInt; fore : LongInt);
    procedure MarkerSetBack(markerNumber : LongInt; back : LongInt);
    function MarkerAdd(line : LongInt; markerNumber : LongInt) : LongInt;
    procedure MarkerDelete(line : LongInt; markerNumber : LongInt);
    procedure MarkerDeleteAll(markerNumber : LongInt);
    function MarkerGet(line : LongInt) : LongInt;
    function MarkerNext(lineStart : LongInt; markerMask : LongInt) : LongInt;
    function MarkerPrevious(lineStart : LongInt; markerMask : LongInt) : LongInt;
    procedure MarkerDefinePixmap(markerNumber : LongInt; pixmap : PChar);
    procedure SetMarginTypeN(margin : LongInt; marginType : LongInt);
    function GetMarginTypeN(margin : LongInt) : LongInt;
    procedure SetMarginWidthN(margin : LongInt; pixelWidth : LongInt);
    function GetMarginWidthN(margin : LongInt) : LongInt;
		procedure SetMarginMaskN(margin : LongInt; mask : LongInt);
    function GetMarginMaskN(margin : LongInt) : LongInt;
    procedure SetMarginSensitiveN(margin : LongInt; sensitive : LongBool);
    function GetMarginSensitiveN(margin : LongInt) : LongBool;
    procedure StyleClearAll;
    procedure StyleSetFore(style : LongInt; fore : LongInt);
    procedure StyleSetBack(style : LongInt; back : LongInt);
    procedure StyleSetBold(style : LongInt; bold : LongBool);
    procedure StyleSetItalic(style : LongInt; italic : LongBool);
    procedure StyleSetSize(style : LongInt; sizePoints : LongInt);
    procedure StyleSetFont(style : LongInt; fontName : PChar);
    procedure StyleSetEOLFilled(style : LongInt; filled : LongBool);
    procedure StyleResetDefault;
    procedure StyleSetUnderline(style : LongInt; underline : LongBool);
    procedure StyleSetCase(style : LongInt; caseForce : LongInt);
    procedure StyleSetCharacterSet(style : LongInt; characterSet : LongInt);
    procedure StyleSetHotSpot(style : LongInt; hotspot : LongBool);
    procedure SetSelFore(useSetting : LongBool; fore : LongInt);
		procedure SetSelBack(useSetting : LongBool; back : LongInt);
		procedure SetCaretFore(fore : TColor);
    procedure AssignCmdKey(km : LongInt; msg : LongInt);
    procedure ClearCmdKey(km : LongInt);
    procedure ClearAllCmdKeys;
    procedure SetStylingEx(length : LongInt; styles : PChar);
    procedure StyleSetVisible(style : LongInt; visible : LongBool);
    function GetCaretPeriod : LongInt;
    procedure SetCaretPeriod(periodMilliseconds : LongInt);
    procedure SetWordChars(characters : PChar);
    procedure BeginUndoAction;
    procedure EndUndoAction;
    procedure IndicSetStyle(indic : LongInt; style : LongInt);
    function IndicGetStyle(indic : LongInt) : LongInt;
    procedure IndicSetFore(indic : LongInt; fore : LongInt);
    function IndicGetFore(indic : LongInt) : LongInt;
    procedure SetWhitespaceFore(useSetting : LongBool; fore : LongInt);
    procedure SetWhitespaceBack(useSetting : LongBool; back : LongInt);
    procedure SetStyleBits(bits : LongInt);
    function GetStyleBits : LongInt;
    procedure SetLineState(line : LongInt; state : LongInt);
    function GetLineState(line : LongInt) : LongInt;
    function GetMaxLineState : LongInt;
    function GetCaretLineVisible : LongBool;
    procedure SetCaretLineVisible(show : LongBool);
    function GetCaretLineBack : TColor;
    procedure SetCaretLineBack(back : TColor);
    procedure StyleSetChangeable(style : LongInt; changeable : LongBool);
    procedure AutoCShow(lenEntered : LongInt; itemList : PChar);
    procedure AutoCCancel;
    function AutoCActive : LongBool;
    function AutoCPosStart : LongInt;
    procedure AutoCComplete;
    procedure AutoCStops(characterSet : PChar);
    procedure AutoCSetSeparator(separatorCharacter : LongInt);
    function AutoCGetSeparator : LongInt;
    procedure AutoCSelect(text : PChar);
    procedure AutoCSetCancelAtStart(cancel : LongBool);
    function AutoCGetCancelAtStart : LongBool;
    procedure AutoCSetFillUps(characterSet : PChar);
    procedure AutoCSetChooseSingle(chooseSingle : LongBool);
    function AutoCGetChooseSingle : LongBool;
    procedure AutoCSetIgnoreCase(ignoreCase : LongBool);
    function AutoCGetIgnoreCase : LongBool;
    procedure UserListShow(listType : LongInt; itemList : PChar);
    procedure AutoCSetAutoHide(autoHide : LongBool);
    function AutoCGetAutoHide : LongBool;
    procedure AutoCSetDropRestOfWord(dropRestOfWord : LongBool);
    function AutoCGetDropRestOfWord : LongBool;
    procedure RegisterImage(type_ : LongInt; xpmData : PChar);
    procedure ClearRegisteredImages;
    function AutoCGetTypeSeparator : LongInt;
    procedure AutoCSetTypeSeparator(separatorCharacter : LongInt);
    procedure SetIndent(indentSize : LongInt);
    function GetIndent : LongInt;
    procedure SetUseTabs(useTabs : LongBool);
    function GetUseTabs : LongBool;
    procedure SetLineIndentation(line : LongInt; indentSize : LongInt);
    function GetLineIndentation(line : LongInt) : LongInt;
    function GetLineIndentPosition(line : LongInt) : LongInt;
    function GetColumn(pos : LongInt) : LongInt;
    procedure SetHScrollBar(show : LongBool);
    function GetHScrollBar : LongBool;
    procedure SetIndentationGuides(show : LongBool);
    function GetIndentationGuides : LongBool;
    procedure SetHighlightGuide(column : LongInt);
    function GetHighlightGuide : LongInt;
    function GetLineEndPosition(line : LongInt) : LongInt;
    function GetCodePage : LongInt;
    function GetCaretFore : TColor;
    function GetUsePalette : LongBool;
    function GetReadOnly : LongBool;
    procedure SetCurrentPos(pos : LongInt);
    procedure SetSelectionStart(pos : LongInt);
    function GetSelectionStart : LongInt;
    procedure SetSelectionEnd(pos : LongInt);
    function GetSelectionEnd : LongInt;
    procedure SetPrintMagnification(magnification : LongInt);
    function GetPrintMagnification : LongInt;
    procedure SetPrintColourMode(mode : LongInt);
    function GetPrintColourMode : LongInt;
    function FindText(flags : LongInt; ft : PTextToFind) : LongInt;
    procedure FormatRange(draw : LongBool; fr : LongInt);
    function GetFirstVisibleLine : LongInt;
    function GetLine(line : LongInt; text : PChar) : LongInt;
    function GetLineCount : LongInt;
    procedure SetMarginLeft(pixelWidth : LongInt);
    function GetMarginLeft : LongInt;
    procedure SetMarginRight(pixelWidth : LongInt);
    function GetMarginRight : LongInt;
    function GetModify : LongBool;
    procedure SetSel(start : LongInt; end_ : LongInt);
    function GetSelText(text : PChar) : LongInt;
    function GetTextRange(tr : PTextRange) : LongInt;
    procedure HideSelection(normal : LongBool);
    function PointXFromPosition(pos : LongInt) : LongInt;
    function PointYFromPosition(pos : LongInt) : LongInt;
    function LineFromPosition(pos : LongInt) : LongInt;
    function PositionFromLine(line : LongInt) : LongInt;
    procedure LineScroll(columns : LongInt; lines : LongInt);
    procedure ScrollCaret;
    procedure ReplaceSel(text : PChar);
    procedure SetReadOnly(readOnly : LongBool);
    procedure Null;
    function CanPaste : LongBool;
    function CanUndo : LongBool;
    procedure EmptyUndoBuffer;
    procedure Undo;
    procedure Cut;
    procedure Copy;
    procedure Paste;
    procedure Clear;
    procedure SetText(text : PChar);
    function GetText(length : LongInt; text : PChar) : LongInt;
    function GetTextLength : LongInt;
    function GetDirectFunction : LongInt;
    function GetDirectPointer : LongInt;
    procedure SetOvertype(overtype : LongBool);
    function GetOvertype : LongBool;
    procedure SetCaretWidth(pixelWidth : LongInt);
    function GetCaretWidth : LongInt;
    procedure SetTargetStart(pos : LongInt);
    function GetTargetStart : LongInt;
    procedure SetTargetEnd(pos : LongInt);
    function GetTargetEnd : LongInt;
    function ReplaceTarget(length : LongInt; text : PChar) : LongInt;
    function ReplaceTargetRE(length : LongInt; text : PChar) : LongInt;
    function SearchInTarget(length : LongInt; text : PChar) : LongInt;
    procedure SetSearchFlags(flags : LongInt);
    function GetSearchFlags : LongInt;
    procedure CallTipShow(pos : LongInt; definition : PChar);
    procedure CallTipCancel;
    function CallTipActive : LongBool;
    function CallTipPosStart : LongInt;
    procedure CallTipSetHlt(start : LongInt; end_ : LongInt);
    procedure CallTipSetBack(back : LongInt);
    procedure CallTipSetFore(fore : LongInt);
    procedure CallTipSetForeHlt(fore : LongInt);
    function VisibleFromDocLine(line : LongInt) : LongInt;
    function DocLineFromVisible(lineDisplay : LongInt) : LongInt;
    procedure SetFoldLevel(line : LongInt; level : LongInt);
    function GetFoldLevel(line : LongInt) : LongInt;
    function GetLastChild(line : LongInt; level : LongInt) : LongInt;
    function GetFoldParent(line : LongInt) : LongInt;
    procedure ShowLines(lineStart : LongInt; lineEnd : LongInt);
    procedure HideLines(lineStart : LongInt; lineEnd : LongInt);
    function GetLineVisible(line : LongInt) : LongBool;
    procedure SetFoldExpanded(line : LongInt; expanded : LongBool);
    function GetFoldExpanded(line : LongInt) : LongBool;
    procedure ToggleFold(line : LongInt);
    procedure EnsureVisible(line : LongInt);
    procedure SetFoldFlags(flags : LongInt);
    procedure EnsureVisibleEnforcePolicy(line : LongInt);
    procedure SetTabIndents(tabIndents : LongBool);
    function GetTabIndents : LongBool;
    procedure SetBackSpaceUnIndents(bsUnIndents : LongBool);
    function GetBackSpaceUnIndents : LongBool;
    procedure SetMouseDwellTime(periodMilliseconds : LongInt);
    function GetMouseDwellTime : LongInt;
    function WordStartPosition(pos : LongInt; onlyWordCharacters : LongBool) : LongInt;
    function WordEndPosition(pos : LongInt; onlyWordCharacters : LongBool) : LongInt;
    procedure SetWrapMode(mode : LongInt);
    function GetWrapMode : LongInt;
    procedure SetLayoutCache(mode : LongInt);
    function GetLayoutCache : LongInt;
    procedure SetScrollWidth(pixelWidth : LongInt);
    function GetScrollWidth : LongInt;
    function TextWidth(style : LongInt; text : PChar) : LongInt;
    procedure SetEndAtLastLine(endAtLastLine : LongBool);
    function GetEndAtLastLine : LongInt;
    function TextHeight(line : LongInt) : LongInt;
    procedure SetVScrollBar(show : LongBool);
    function GetVScrollBar : LongBool;
    procedure AppendText(length : LongInt; text : PChar);
    function GetTwoPhaseDraw : LongBool;
    procedure SetTwoPhaseDraw(twoPhase : LongBool);
    procedure TargetFromSelection;
    procedure LinesJoin;
    procedure LinesSplit(pixelWidth : LongInt);
    procedure SetFoldMarginColour(useSetting : LongBool; back : LongInt);
    procedure SetFoldMarginHiColour(useSetting : LongBool; fore : LongInt);
    procedure LineDown;
    procedure LineDownExtend;
    procedure LineUp;
    procedure LineUpExtend;
    procedure CharLeft;
    procedure CharLeftExtend;
    procedure CharRight;
    procedure CharRightExtend;
    procedure WordLeft;
    procedure WordLeftExtend;
    procedure WordRight;
    procedure WordRightExtend;
    procedure Home;
    procedure HomeExtend;
    procedure LineEnd;
    procedure LineEndExtend;
    procedure DocumentStart;
    procedure DocumentStartExtend;
    procedure DocumentEnd;
    procedure DocumentEndExtend;
    procedure PageUp;
    procedure PageUpExtend;
    procedure PageDown;
    procedure PageDownExtend;
    procedure EditToggleOvertype;
    procedure Cancel;
    procedure DeleteBack;
    procedure Tab;
    procedure BackTab;
    procedure NewLine;
    procedure FormFeed;
    procedure VCHome;
    procedure VCHomeExtend;
    procedure ZoomIn;
    procedure ZoomOut;
    procedure DelWordLeft;
    procedure DelWordRight;
    procedure LineCut;
    procedure LineDelete;
    procedure LineTranspose;
    procedure LineDuplicate;
    procedure LowerCase;
    procedure UpperCase;
    procedure LineScrollDown;
    procedure LineScrollUp;
    procedure DeleteBackNotLine;
    procedure HomeDisplay;
    procedure HomeDisplayExtend;
    procedure LineEndDisplay;
    procedure LineEndDisplayExtend;
    procedure HomeWrap;
    procedure HomeWrapExtend;
    procedure LineEndWrap;
    procedure LineEndWrapExtend;
    procedure VCHomeWrap;
    procedure VCHomeWrapExtend;
    procedure LineCopy;
    procedure MoveCaretInsideView;
    function LineLength(line : LongInt) : LongInt;
    procedure BraceHighlight(pos1 : LongInt; pos2 : LongInt);
    procedure BraceBadLight(pos : LongInt);
    function BraceMatch(pos : LongInt) : LongInt;
    function GetViewEOL : LongBool;
    procedure SetViewEOL(visible : LongBool);
    function GetDocPointer : LongInt;
    procedure SetDocPointer(pointer : LongInt);
    procedure SetModEventMask(mask : LongInt);
    function GetEdgeColumn : LongInt;
    procedure SetEdgeColumn(column : LongInt);
    function GetEdgeMode : LongInt;
    procedure SetEdgeMode(mode : LongInt);
    function GetEdgeColour : LongInt;
    procedure SetEdgeColour(edgeColour : LongInt);
    procedure SearchAnchor;
    function SearchNext(flags : LongInt; text : PChar) : LongInt;
    function SearchPrev(flags : LongInt; text : PChar) : LongInt;
    function LinesOnScreen : LongInt;
    procedure UsePopUp(allowPopUp : LongBool);
    function SelectionIsRectangle : LongBool;
    procedure SetZoom(zoom : LongInt);
    function GetZoom : LongInt;
    function CreateDocument : LongInt;
    procedure AddRefDocument(doc : LongInt);
    procedure ReleaseDocument(doc : LongInt);
    function GetModEventMask : LongInt;
    procedure SetFocusEx(focus : LongBool);
    function GetFocus : LongBool;
    procedure SetStatus(statusCode : LongInt);
    function GetStatus : LongInt;
    procedure SetMouseDownCaptures(captures : LongBool);
    function GetMouseDownCaptures : LongBool;
    procedure SetCursor(cursorType : LongInt);
    function GetCursor : LongInt;
    procedure SetControlCharSymbol(symbol : LongInt);
    function GetControlCharSymbol : LongInt;
    procedure WordPartLeft;
    procedure WordPartLeftExtend;
    procedure WordPartRight;
    procedure WordPartRightExtend;
    procedure SetVisiblePolicy(visiblePolicy : LongInt; visibleSlop : LongInt);
    procedure DelLineLeft;
    procedure DelLineRight;
    procedure SetXOffset(newOffset : LongInt);
    function GetXOffset : LongInt;
    procedure ChooseCaretX;
    procedure GrabFocus;
    procedure SetXCaretPolicy(caretPolicy : LongInt; caretSlop : LongInt);
    procedure SetYCaretPolicy(caretPolicy : LongInt; caretSlop : LongInt);
    procedure SetPrintWrapMode(mode : LongInt);
    function GetPrintWrapMode : LongInt;
    procedure SetHotspotActiveFore(useSetting : LongBool; fore : LongInt);
    procedure SetHotspotActiveBack(useSetting : LongBool; back : LongInt);
    procedure SetHotspotActiveUnderline(underline : LongBool);
    procedure SetHotspotSingleLine(singleLine : LongBool);
    procedure ParaDown;
    procedure ParaDownExtend;
    procedure ParaUp;
    procedure ParaUpExtend;
    function PositionBefore(pos : LongInt) : LongInt;
    function PositionAfter(pos : LongInt) : LongInt;
    procedure CopyRange(start : LongInt; end_ : LongInt);
    procedure CopyText(length : LongInt; text : PChar);
    procedure SetSelectionMode(mode : LongInt);
    function GetSelectionMode : LongInt;
    function GetLineSelStartPosition(line : LongInt) : LongInt;
    function GetLineSelEndPosition(line : LongInt) : LongInt;
    procedure LineDownRectExtend;
    procedure LineUpRectExtend;
    procedure CharLeftRectExtend;
    procedure CharRightRectExtend;
    procedure HomeRectExtend;
    procedure VCHomeRectExtend;
    procedure LineEndRectExtend;
    procedure PageUpRectExtend;
    procedure PageDownRectExtend;
    procedure StartRecord;
    procedure StopRecord;
    procedure SetLexer(lexer : LongInt);
    function GetLexer : LongInt;
    procedure Colourise(start : LongInt; end_ : LongInt);
    procedure SetProperty(key : PChar; value : PChar);
    procedure SetKeyWords(keywordSet : LongInt; keyWords : PChar);
    procedure SetLexerLanguage(language : PChar);
    procedure LoadLexerLibrary(path : PChar);
//--FuncDef
    property Dummy : Boolean read FDummy Write SetDummy;
//  Added by KV
  private
    fMargin0: TMargin;
    fMargin1: TMargin;
    fMargin2: TMargin;
    FLines: TStrings;
    fHighlighter : TSciSynLexer;
    fKeepIndent : Boolean;
    fCodeFolding : Boolean;
    FBraceHilite : Boolean;
    fStateStream : TMemoryStream;
    fKeyCommands : TSciKeyCommandCollection;
    function GetSelection: string;
    procedure SetSelection(const Value: string);
    procedure SetLines(Const Value : TStrings);
    function GetUseUnicode: Boolean;
    procedure SetUseUnicode(const Value: Boolean);
    procedure SetModified(const Value: LongBool);
    procedure SetMargins(const Index: Integer; const Value: TMargin);
    function GetWordWrap: Boolean;
    procedure SetWordWrap(const Value: Boolean);
    function GetEOLStyle: TEOLStyle;
    procedure SetEOLStyle(const Value: TEOLStyle);
    procedure SetHighlighter(const Value : TSciSynLexer);
    procedure SetKeyCommands(const Value : TSciKeyCommandCollection);
    procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
    procedure CMColorChanged(var Message: TMessage); message CM_COLORCHANGED;
  protected
    procedure Loaded; override;
    procedure CharAdded(ch : integer); virtual;
    procedure SetCodeFolding(const Value: Boolean); virtual;
    procedure Expand(var line: integer; doExpand : Boolean;
            force: Boolean = false; visLevels: integer = 0; level : integer=-1);
    procedure ProcessBraces; virtual;
  public
    destructor Destroy; override;
    procedure FoldAll;
      { Fold all code blocks }
    procedure EnsureRangeVisible(PosStart, PosEnd: integer);
      { Ensure a text range is visible - make visible if necessary }
    function ExecuteAction(Action: TBasicAction): boolean; override;
      { Standard Delphi edit action support }
    function UpdateAction(Action: TBasicAction): boolean; override;
      { Standard Delphi edit action support }
    procedure ExportToHTML(Stream : TStream; Title : string);
      { Export text to HTML including highlighting }
    procedure FindMatchingBracePosition(var braceAtCaret : integer;
             var braceOpposite : integer; var IsInside : boolean; sloppy : boolean=true);
      { Used for brace matching and highlighting }
    procedure GoMatchingBrace(Select : boolean; Sloppy : boolean);
      { Move carret to matching brace }
    property Selection : string read GetSelection write SetSelection;
      { Get or set the selected text }
    property Modified : LongBool read GetModify write SetModified;
      { Flag to indicate whether the text buffer has been modified }
  published
    property Color;
    property Font;
    property PopupMenu;
    property BraceHilite : boolean read FBraceHilite write FBraceHilite;
      { Enable or disable brace highlighting }
		property CodeFolding : Boolean read fCodeFolding write SetCodeFolding;
      { Enable or disable code folding if supported by the highlighter }
    property Highlighter : TSciSynLexer read fHighlighter write SetHighlighter;
      { Get or set the Syntax highlighter }
    property EOLStyle : TEOLStyle read GetEOLStyle write SetEOLStyle;
      { Get or set the EOF style: EOL_CRLF, EOL_CR, EOL_LF }
    property Indentation : TIndentationOptions read GetIndentation write SetIndentation;
      {
        Get or set indentation options:
           - KeepIndent,
           - TabIndents,
           - BackSpaceUnIndents,
           - IndentationGuides
      }
    property IndentWidth : integer read GetIndent write SetIndent;
      {
        Number of characters for code (un)indending
				If set to zero then the TabWidth is used instead
			}
		property CaretColor : TColor read GetCaretFore write SetCaretFore;
		property CaretWidth : Longint read GetCaretWidth Write SetCaretWidth;
    property Gutter0 : TMargin  index 0 read fMargin0 write SetMargins;
      {
        Set the type of Gutter(margin) 1
         GUT_SYMBOL = 0,
         GUT_LINENUMBER = 1
      }
    property Gutter1 : TMargin index 1 read fMargin1 write SetMargins;
      {
        Set the type of Gutter(margin) 1
         GUT_SYMBOL = 0,
         GUT_LINENUMBER = 1
      }
    property Gutter2 : TMargin index 2 read fMargin2 write SetMargins;
      {
        Set the type of Gutter(margin) 2
         GUT_SYMBOL = 0,
         GUT_LINENUMBER = 1
      }
    property KeyCommands : TSciKeyCommandCollection read FKeyCommands write SetKeyCommands;
      {
         Property for customising and saving the keyboard commands
      }
    property MarginLeft : LongInt read GetMarginLeft write SetMarginLeft;
      {  Left Margin in pixels }
    property MarginRight : LongInt read GetMarginRight write SetMarginRight;
      {  Right Margin in pixels }
    property TabWidth : integer read GetTabWidth write SetTabWidth default 8;
      {  Tab width in characters }
    property ReadOnly : LongBool read GetReadOnly write SetReadOnly default false;
      {  Make the text buffer read-only }
    property UseTabs : LongBool read GetUseTabs write SetUseTabs default true;
      {  If false tab characters are replaced by spaces }
    property UseUnicode : Boolean read GetUseUnicode write SetUseUnicode default false;
      {
          Setting to true allows the use of multiple language in the same document
          If true all text in and out of the control is interpreted as UTF8
      }
    property WordWrap : Boolean read GetWordWrap write SetWordWrap default False;
      { Enable/disable word wrap }
    property Lines: TStrings read FLines write SetLines;
      {  Provides Delphi like access to the text buffer }
  end;

var
  fMsgSentDummyProc : TSCEventMsgSent;

implementation
Uses
  Math;

//The Python generator will insert the function definitions below this line...
//++FuncImp
procedure TScintilla.AddText(length : LongInt; text : PChar);
begin
  SPerform(SCI_ADDTEXT, length, LongInt(text));
end;

procedure TScintilla.AddStyledText(length : LongInt; c : PChar);
begin
  SPerform(SCI_ADDSTYLEDTEXT, length, LongInt(c));
end;

procedure TScintilla.InsertText(pos : LongInt; text : PChar);
begin
  SPerform(SCI_INSERTTEXT, pos, LongInt(text));
end;

procedure TScintilla.ClearAll;
begin
  SPerform(SCI_CLEARALL, 0, 0);
end;

procedure TScintilla.ClearDocumentStyle;
begin
  SPerform(SCI_CLEARDOCUMENTSTYLE, 0, 0);
end;

function TScintilla.GetLength : LongInt;
begin
  result := SPerform(SCI_GETLENGTH, 0, 0);
end;

function TScintilla.GetCharAt(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETCHARAT, pos, 0);
end;

function TScintilla.GetCurrentPos : LongInt;
begin
  result := SPerform(SCI_GETCURRENTPOS, 0, 0);
end;

function TScintilla.GetAnchor : LongInt;
begin
  result := SPerform(SCI_GETANCHOR, 0, 0);
end;

function TScintilla.GetStyleAt(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETSTYLEAT, pos, 0);
end;

procedure TScintilla.Redo;
begin
  SPerform(SCI_REDO, 0, 0);
end;

procedure TScintilla.SetUndoCollection(collectUndo : LongBool);
begin
  SPerform(SCI_SETUNDOCOLLECTION, LongInt(collectUndo), 0);
end;

procedure TScintilla.SelectAll;
begin
  SPerform(SCI_SELECTALL, 0, 0);
end;

procedure TScintilla.SetSavePoint;
begin
  SPerform(SCI_SETSAVEPOINT, 0, 0);
end;

function TScintilla.GetStyledText(tr : PTextRange) : LongInt;
begin
  result := SPerform(SCI_GETSTYLEDTEXT, 0, LongInt(tr));
end;

function TScintilla.CanRedo : LongBool;
begin
  result := LongBool(SPerform(SCI_CANREDO, 0, 0));
end;

function TScintilla.MarkerLineFromHandle(handle : LongInt) : LongInt;
begin
  result := SPerform(SCI_MARKERLINEFROMHANDLE, handle, 0);
end;

procedure TScintilla.MarkerDeleteHandle(handle : LongInt);
begin
  SPerform(SCI_MARKERDELETEHANDLE, handle, 0);
end;

function TScintilla.GetUndoCollection : LongBool;
begin
  result := LongBool(SPerform(SCI_GETUNDOCOLLECTION, 0, 0));
end;

function TScintilla.GetViewWS : LongInt;
begin
  result := SPerform(SCI_GETVIEWWS, 0, 0);
end;

procedure TScintilla.SetViewWS(viewWS : LongInt);
begin
  SPerform(SCI_SETVIEWWS, viewWS, 0);
end;

function TScintilla.PositionFromPoint(x : LongInt; y : LongInt) : LongInt;
begin
  result := SPerform(SCI_POSITIONFROMPOINT, x, y);
end;

function TScintilla.PositionFromPointClose(x : LongInt; y : LongInt) : LongInt;
begin
  result := SPerform(SCI_POSITIONFROMPOINTCLOSE, x, y);
end;

procedure TScintilla.GotoLine(line : LongInt);
begin
  SPerform(SCI_GOTOLINE, line, 0);
end;

procedure TScintilla.GotoPos(pos : LongInt);
begin
  SPerform(SCI_GOTOPOS, pos, 0);
end;

procedure TScintilla.SetAnchor(posAnchor : LongInt);
begin
  SPerform(SCI_SETANCHOR, posAnchor, 0);
end;

function TScintilla.GetCurLine(length : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_GETCURLINE, length, LongInt(text));
end;

function TScintilla.GetEndStyled : LongInt;
begin
  result := SPerform(SCI_GETENDSTYLED, 0, 0);
end;

procedure TScintilla.ConvertEOLs(eolMode : LongInt);
begin
  SPerform(SCI_CONVERTEOLS, eolMode, 0);
end;

function TScintilla.GetEOLMode : LongInt;
begin
  result := SPerform(SCI_GETEOLMODE, 0, 0);
end;

procedure TScintilla.SetEOLMode(eolMode : LongInt);
begin
  SPerform(SCI_SETEOLMODE, eolMode, 0);
end;

procedure TScintilla.StartStyling(pos : LongInt; mask : LongInt);
begin
  SPerform(SCI_STARTSTYLING, pos, mask);
end;

procedure TScintilla.SetStyling(length : LongInt; style : LongInt);
begin
  SPerform(SCI_SETSTYLING, length, style);
end;

function TScintilla.GetBufferedDraw : LongBool;
begin
  result := LongBool(SPerform(SCI_GETBUFFEREDDRAW, 0, 0));
end;

procedure TScintilla.SetBufferedDraw(buffered : LongBool);
begin
  SPerform(SCI_SETBUFFEREDDRAW, LongInt(buffered), 0);
end;

procedure TScintilla.SetTabWidth(tabWidth : LongInt);
begin
  SPerform(SCI_SETTABWIDTH, tabWidth, 0);
end;

function TScintilla.GetTabWidth : LongInt;
begin
  result := SPerform(SCI_GETTABWIDTH, 0, 0);
end;

procedure TScintilla.SetCodePage(codePage : LongInt);
begin
  SPerform(SCI_SETCODEPAGE, codePage, 0);
end;

procedure TScintilla.SetUsePalette(usePalette : LongBool);
begin
  SPerform(SCI_SETUSEPALETTE, LongInt(usePalette), 0);
end;

procedure TScintilla.MarkerDefine(markerNumber : LongInt; markerSymbol : LongInt);
begin
  SPerform(SCI_MARKERDEFINE, markerNumber, markerSymbol);
end;

procedure TScintilla.MarkerSetFore(markerNumber : LongInt; fore : LongInt);
begin
  SPerform(SCI_MARKERSETFORE, markerNumber, fore);
end;

procedure TScintilla.MarkerSetBack(markerNumber : LongInt; back : LongInt);
begin
  SPerform(SCI_MARKERSETBACK, markerNumber, back);
end;

function TScintilla.MarkerAdd(line : LongInt; markerNumber : LongInt) : LongInt;
begin
  result := SPerform(SCI_MARKERADD, line, markerNumber);
end;

procedure TScintilla.MarkerDelete(line : LongInt; markerNumber : LongInt);
begin
  SPerform(SCI_MARKERDELETE, line, markerNumber);
end;

procedure TScintilla.MarkerDeleteAll(markerNumber : LongInt);
begin
  SPerform(SCI_MARKERDELETEALL, markerNumber, 0);
end;

function TScintilla.MarkerGet(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_MARKERGET, line, 0);
end;

function TScintilla.MarkerNext(lineStart : LongInt; markerMask : LongInt) : LongInt;
begin
  result := SPerform(SCI_MARKERNEXT, lineStart, markerMask);
end;

function TScintilla.MarkerPrevious(lineStart : LongInt; markerMask : LongInt) : LongInt;
begin
  result := SPerform(SCI_MARKERPREVIOUS, lineStart, markerMask);
end;

procedure TScintilla.MarkerDefinePixmap(markerNumber : LongInt; pixmap : PChar);
begin
  SPerform(SCI_MARKERDEFINEPIXMAP, markerNumber, LongInt(pixmap));
end;

procedure TScintilla.SetMarginTypeN(margin : LongInt; marginType : LongInt);
begin
  SPerform(SCI_SETMARGINTYPEN, margin, marginType);
end;

function TScintilla.GetMarginTypeN(margin : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETMARGINTYPEN, margin, 0);
end;

procedure TScintilla.SetMarginWidthN(margin : LongInt; pixelWidth : LongInt);
begin
  SPerform(SCI_SETMARGINWIDTHN, margin, pixelWidth);
end;

function TScintilla.GetMarginWidthN(margin : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETMARGINWIDTHN, margin, 0);
end;

procedure TScintilla.SetMarginMaskN(margin : LongInt; mask : LongInt);
begin
  SPerform(SCI_SETMARGINMASKN, margin, mask);
end;

function TScintilla.GetMarginMaskN(margin : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETMARGINMASKN, margin, 0);
end;

procedure TScintilla.SetMarginSensitiveN(margin : LongInt; sensitive : LongBool);
begin
  SPerform(SCI_SETMARGINSENSITIVEN, margin, LongInt(sensitive));
end;

function TScintilla.GetMarginSensitiveN(margin : LongInt) : LongBool;
begin
  result := LongBool(SPerform(SCI_GETMARGINSENSITIVEN, margin, 0));
end;

procedure TScintilla.StyleClearAll;
begin
  SPerform(SCI_STYLECLEARALL, 0, 0);
end;

procedure TScintilla.StyleSetFore(style : LongInt; fore : LongInt);
begin
  SPerform(SCI_STYLESETFORE, style, fore);
end;

procedure TScintilla.StyleSetBack(style : LongInt; back : LongInt);
begin
  SPerform(SCI_STYLESETBACK, style, back);
end;

procedure TScintilla.StyleSetBold(style : LongInt; bold : LongBool);
begin
  SPerform(SCI_STYLESETBOLD, style, LongInt(bold));
end;

procedure TScintilla.StyleSetItalic(style : LongInt; italic : LongBool);
begin
  SPerform(SCI_STYLESETITALIC, style, LongInt(italic));
end;

procedure TScintilla.StyleSetSize(style : LongInt; sizePoints : LongInt);
begin
  SPerform(SCI_STYLESETSIZE, style, sizePoints);
end;

procedure TScintilla.StyleSetFont(style : LongInt; fontName : PChar);
begin
  SPerform(SCI_STYLESETFONT, style, LongInt(fontName));
end;

procedure TScintilla.StyleSetEOLFilled(style : LongInt; filled : LongBool);
begin
  SPerform(SCI_STYLESETEOLFILLED, style, LongInt(filled));
end;

procedure TScintilla.StyleResetDefault;
begin
  SPerform(SCI_STYLERESETDEFAULT, 0, 0);
end;

procedure TScintilla.StyleSetUnderline(style : LongInt; underline : LongBool);
begin
  SPerform(SCI_STYLESETUNDERLINE, style, LongInt(underline));
end;

procedure TScintilla.StyleSetCase(style : LongInt; caseForce : LongInt);
begin
  SPerform(SCI_STYLESETCASE, style, caseForce);
end;

procedure TScintilla.StyleSetCharacterSet(style : LongInt; characterSet : LongInt);
begin
  SPerform(SCI_STYLESETCHARACTERSET, style, characterSet);
end;

procedure TScintilla.StyleSetHotSpot(style : LongInt; hotspot : LongBool);
begin
  SPerform(SCI_STYLESETHOTSPOT, style, LongInt(hotspot));
end;

procedure TScintilla.SetSelFore(useSetting : LongBool; fore : LongInt);
begin
  SPerform(SCI_SETSELFORE, LongInt(useSetting), fore);
end;

procedure TScintilla.SetSelBack(useSetting : LongBool; back : LongInt);
begin
  SPerform(SCI_SETSELBACK, LongInt(useSetting), back);
end;

procedure TScintilla.SetCaretFore(fore : TColor);
begin
	SPerform(SCI_SETCARETFORE, ColorToRGB(fore), 0);
end;

procedure TScintilla.AssignCmdKey(km : LongInt; msg : LongInt);
begin
  SPerform(SCI_ASSIGNCMDKEY, km, msg);
end;

procedure TScintilla.ClearCmdKey(km : LongInt);
begin
  SPerform(SCI_CLEARCMDKEY, km, 0);
end;

procedure TScintilla.ClearAllCmdKeys;
begin
  SPerform(SCI_CLEARALLCMDKEYS, 0, 0);
end;

procedure TScintilla.SetStylingEx(length : LongInt; styles : PChar);
begin
  SPerform(SCI_SETSTYLINGEX, length, LongInt(styles));
end;

procedure TScintilla.StyleSetVisible(style : LongInt; visible : LongBool);
begin
  SPerform(SCI_STYLESETVISIBLE, style, LongInt(visible));
end;

function TScintilla.GetCaretPeriod : LongInt;
begin
  result := SPerform(SCI_GETCARETPERIOD, 0, 0);
end;

procedure TScintilla.SetCaretPeriod(periodMilliseconds : LongInt);
begin
  SPerform(SCI_SETCARETPERIOD, periodMilliseconds, 0);
end;

procedure TScintilla.SetWordChars(characters : PChar);
begin
  SPerform(SCI_SETWORDCHARS, 0, LongInt(characters));
end;

procedure TScintilla.BeginUndoAction;
begin
  SPerform(SCI_BEGINUNDOACTION, 0, 0);
end;

procedure TScintilla.EndUndoAction;
begin
  SPerform(SCI_ENDUNDOACTION, 0, 0);
end;

procedure TScintilla.IndicSetStyle(indic : LongInt; style : LongInt);
begin
  SPerform(SCI_INDICSETSTYLE, indic, style);
end;

function TScintilla.IndicGetStyle(indic : LongInt) : LongInt;
begin
  result := SPerform(SCI_INDICGETSTYLE, indic, 0);
end;

procedure TScintilla.IndicSetFore(indic : LongInt; fore : LongInt);
begin
  SPerform(SCI_INDICSETFORE, indic, fore);
end;

function TScintilla.IndicGetFore(indic : LongInt) : LongInt;
begin
  result := SPerform(SCI_INDICGETFORE, indic, 0);
end;

procedure TScintilla.SetWhitespaceFore(useSetting : LongBool; fore : LongInt);
begin
  SPerform(SCI_SETWHITESPACEFORE, LongInt(useSetting), fore);
end;

procedure TScintilla.SetWhitespaceBack(useSetting : LongBool; back : LongInt);
begin
  SPerform(SCI_SETWHITESPACEBACK, LongInt(useSetting), back);
end;

procedure TScintilla.SetStyleBits(bits : LongInt);
begin
  SPerform(SCI_SETSTYLEBITS, bits, 0);
end;

function TScintilla.GetStyleBits : LongInt;
begin
  result := SPerform(SCI_GETSTYLEBITS, 0, 0);
end;

procedure TScintilla.SetLineState(line : LongInt; state : LongInt);
begin
  SPerform(SCI_SETLINESTATE, line, state);
end;

function TScintilla.GetLineState(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETLINESTATE, line, 0);
end;

function TScintilla.GetMaxLineState : LongInt;
begin
  result := SPerform(SCI_GETMAXLINESTATE, 0, 0);
end;

function TScintilla.GetCaretLineVisible : LongBool;
begin
  result := LongBool(SPerform(SCI_GETCARETLINEVISIBLE, 0, 0));
end;

procedure TScintilla.SetCaretLineVisible(show : LongBool);
begin
  SPerform(SCI_SETCARETLINEVISIBLE, LongInt(show), 0);
end;

function TScintilla.GetCaretLineBack : TColor;
begin
	result := TColor(SPerform(SCI_GETCARETLINEBACK, 0, 0));
end;

procedure TScintilla.SetCaretLineBack(back : TColor);
begin
	SPerform(SCI_SETCARETLINEBACK, ColorToRGB(back), 0);
end;

procedure TScintilla.StyleSetChangeable(style : LongInt; changeable : LongBool);
begin
	SPerform(SCI_STYLESETCHANGEABLE, style, LongInt(changeable));
end;

procedure TScintilla.AutoCShow(lenEntered : LongInt; itemList : PChar);
begin
  SPerform(SCI_AUTOCSHOW, lenEntered, LongInt(itemList));
end;

procedure TScintilla.AutoCCancel;
begin
  SPerform(SCI_AUTOCCANCEL, 0, 0);
end;

function TScintilla.AutoCActive : LongBool;
begin
  result := LongBool(SPerform(SCI_AUTOCACTIVE, 0, 0));
end;

function TScintilla.AutoCPosStart : LongInt;
begin
  result := SPerform(SCI_AUTOCPOSSTART, 0, 0);
end;

procedure TScintilla.AutoCComplete;
begin
  SPerform(SCI_AUTOCCOMPLETE, 0, 0);
end;

procedure TScintilla.AutoCStops(characterSet : PChar);
begin
  SPerform(SCI_AUTOCSTOPS, 0, LongInt(characterSet));
end;

procedure TScintilla.AutoCSetSeparator(separatorCharacter : LongInt);
begin
  SPerform(SCI_AUTOCSETSEPARATOR, separatorCharacter, 0);
end;

function TScintilla.AutoCGetSeparator : LongInt;
begin
  result := SPerform(SCI_AUTOCGETSEPARATOR, 0, 0);
end;

procedure TScintilla.AutoCSelect(text : PChar);
begin
  SPerform(SCI_AUTOCSELECT, 0, LongInt(text));
end;

procedure TScintilla.AutoCSetCancelAtStart(cancel : LongBool);
begin
  SPerform(SCI_AUTOCSETCANCELATSTART, LongInt(cancel), 0);
end;

function TScintilla.AutoCGetCancelAtStart : LongBool;
begin
  result := LongBool(SPerform(SCI_AUTOCGETCANCELATSTART, 0, 0));
end;

procedure TScintilla.AutoCSetFillUps(characterSet : PChar);
begin
  SPerform(SCI_AUTOCSETFILLUPS, 0, LongInt(characterSet));
end;

procedure TScintilla.AutoCSetChooseSingle(chooseSingle : LongBool);
begin
  SPerform(SCI_AUTOCSETCHOOSESINGLE, LongInt(chooseSingle), 0);
end;

function TScintilla.AutoCGetChooseSingle : LongBool;
begin
  result := LongBool(SPerform(SCI_AUTOCGETCHOOSESINGLE, 0, 0));
end;

procedure TScintilla.AutoCSetIgnoreCase(ignoreCase : LongBool);
begin
  SPerform(SCI_AUTOCSETIGNORECASE, LongInt(ignoreCase), 0);
end;

function TScintilla.AutoCGetIgnoreCase : LongBool;
begin
  result := LongBool(SPerform(SCI_AUTOCGETIGNORECASE, 0, 0));
end;

procedure TScintilla.UserListShow(listType : LongInt; itemList : PChar);
begin
  SPerform(SCI_USERLISTSHOW, listType, LongInt(itemList));
end;

procedure TScintilla.AutoCSetAutoHide(autoHide : LongBool);
begin
  SPerform(SCI_AUTOCSETAUTOHIDE, LongInt(autoHide), 0);
end;

function TScintilla.AutoCGetAutoHide : LongBool;
begin
  result := LongBool(SPerform(SCI_AUTOCGETAUTOHIDE, 0, 0));
end;

procedure TScintilla.AutoCSetDropRestOfWord(dropRestOfWord : LongBool);
begin
  SPerform(SCI_AUTOCSETDROPRESTOFWORD, LongInt(dropRestOfWord), 0);
end;

function TScintilla.AutoCGetDropRestOfWord : LongBool;
begin
  result := LongBool(SPerform(SCI_AUTOCGETDROPRESTOFWORD, 0, 0));
end;

procedure TScintilla.RegisterImage(type_ : LongInt; xpmData : PChar);
begin
  SPerform(SCI_REGISTERIMAGE, type_, LongInt(xpmData));
end;

procedure TScintilla.ClearRegisteredImages;
begin
  SPerform(SCI_CLEARREGISTEREDIMAGES, 0, 0);
end;

function TScintilla.AutoCGetTypeSeparator : LongInt;
begin
  result := SPerform(SCI_AUTOCGETTYPESEPARATOR, 0, 0);
end;

procedure TScintilla.AutoCSetTypeSeparator(separatorCharacter : LongInt);
begin
  SPerform(SCI_AUTOCSETTYPESEPARATOR, separatorCharacter, 0);
end;

procedure TScintilla.SetIndent(indentSize : LongInt);
begin
  SPerform(SCI_SETINDENT, indentSize, 0);
end;

function TScintilla.GetIndent : LongInt;
begin
  result := SPerform(SCI_GETINDENT, 0, 0);
end;

procedure TScintilla.SetUseTabs(useTabs : LongBool);
begin
  SPerform(SCI_SETUSETABS, LongInt(useTabs), 0);
end;

function TScintilla.GetUseTabs : LongBool;
begin
  result := LongBool(SPerform(SCI_GETUSETABS, 0, 0));
end;

procedure TScintilla.SetLineIndentation(line : LongInt; indentSize : LongInt);
begin
  SPerform(SCI_SETLINEINDENTATION, line, indentSize);
end;

function TScintilla.GetLineIndentation(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETLINEINDENTATION, line, 0);
end;

function TScintilla.GetLineIndentPosition(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETLINEINDENTPOSITION, line, 0);
end;

function TScintilla.GetColumn(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETCOLUMN, pos, 0);
end;

procedure TScintilla.SetHScrollBar(show : LongBool);
begin
  SPerform(SCI_SETHSCROLLBAR, LongInt(show), 0);
end;

function TScintilla.GetHScrollBar : LongBool;
begin
  result := LongBool(SPerform(SCI_GETHSCROLLBAR, 0, 0));
end;

procedure TScintilla.SetIndentationGuides(show : LongBool);
begin
  SPerform(SCI_SETINDENTATIONGUIDES, LongInt(show), 0);
end;

function TScintilla.GetIndentationGuides : LongBool;
begin
  result := LongBool(SPerform(SCI_GETINDENTATIONGUIDES, 0, 0));
end;

procedure TScintilla.SetHighlightGuide(column : LongInt);
begin
  SPerform(SCI_SETHIGHLIGHTGUIDE, column, 0);
end;

function TScintilla.GetHighlightGuide : LongInt;
begin
  result := SPerform(SCI_GETHIGHLIGHTGUIDE, 0, 0);
end;

function TScintilla.GetLineEndPosition(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETLINEENDPOSITION, line, 0);
end;

function TScintilla.GetCodePage : LongInt;
begin
  result := SPerform(SCI_GETCODEPAGE, 0, 0);
end;

function TScintilla.GetCaretFore : TColor;
begin
  result := TColor(SPerform(SCI_GETCARETFORE, 0, 0));
end;

function TScintilla.GetUsePalette : LongBool;
begin
  result := LongBool(SPerform(SCI_GETUSEPALETTE, 0, 0));
end;

function TScintilla.GetReadOnly : LongBool;
begin
  result := LongBool(SPerform(SCI_GETREADONLY, 0, 0));
end;

procedure TScintilla.SetCurrentPos(pos : LongInt);
begin
  SPerform(SCI_SETCURRENTPOS, pos, 0);
end;

procedure TScintilla.SetSelectionStart(pos : LongInt);
begin
  SPerform(SCI_SETSELECTIONSTART, pos, 0);
end;

function TScintilla.GetSelectionStart : LongInt;
begin
  result := SPerform(SCI_GETSELECTIONSTART, 0, 0);
end;

procedure TScintilla.SetSelectionEnd(pos : LongInt);
begin
  SPerform(SCI_SETSELECTIONEND, pos, 0);
end;

function TScintilla.GetSelectionEnd : LongInt;
begin
  result := SPerform(SCI_GETSELECTIONEND, 0, 0);
end;

procedure TScintilla.SetPrintMagnification(magnification : LongInt);
begin
  SPerform(SCI_SETPRINTMAGNIFICATION, magnification, 0);
end;

function TScintilla.GetPrintMagnification : LongInt;
begin
  result := SPerform(SCI_GETPRINTMAGNIFICATION, 0, 0);
end;

procedure TScintilla.SetPrintColourMode(mode : LongInt);
begin
  SPerform(SCI_SETPRINTCOLOURMODE, mode, 0);
end;

function TScintilla.GetPrintColourMode : LongInt;
begin
  result := SPerform(SCI_GETPRINTCOLOURMODE, 0, 0);
end;

function TScintilla.FindText(flags : LongInt; ft : PTextToFind) : LongInt;
begin
  result := SPerform(SCI_FINDTEXT, flags, LongInt(ft));
end;

procedure TScintilla.FormatRange(draw : LongBool; fr : LongInt);
begin
  SPerform(SCI_FORMATRANGE, LongInt(draw), fr);
end;

function TScintilla.GetFirstVisibleLine : LongInt;
begin
  result := SPerform(SCI_GETFIRSTVISIBLELINE, 0, 0);
end;

function TScintilla.GetLine(line : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_GETLINE, line, LongInt(text));
end;

function TScintilla.GetLineCount : LongInt;
begin
  result := SPerform(SCI_GETLINECOUNT, 0, 0);
end;

procedure TScintilla.SetMarginLeft(pixelWidth : LongInt);
begin
  SPerform(SCI_SETMARGINLEFT, 0, pixelWidth);
end;

function TScintilla.GetMarginLeft : LongInt;
begin
  result := SPerform(SCI_GETMARGINLEFT, 0, 0);
end;

procedure TScintilla.SetMarginRight(pixelWidth : LongInt);
begin
  SPerform(SCI_SETMARGINRIGHT, 0, pixelWidth);
end;

function TScintilla.GetMarginRight : LongInt;
begin
  result := SPerform(SCI_GETMARGINRIGHT, 0, 0);
end;

function TScintilla.GetModify : LongBool;
begin
  result := LongBool(SPerform(SCI_GETMODIFY, 0, 0));
end;

procedure TScintilla.SetSel(start : LongInt; end_ : LongInt);
begin
  SPerform(SCI_SETSEL, start, end_);
end;

function TScintilla.GetSelText(text : PChar) : LongInt;
begin
  result := SPerform(SCI_GETSELTEXT, 0, LongInt(text));
end;

function TScintilla.GetTextRange(tr : PTextRange) : LongInt;
begin
  result := SPerform(SCI_GETTEXTRANGE, 0, LongInt(tr));
end;

procedure TScintilla.HideSelection(normal : LongBool);
begin
  SPerform(SCI_HIDESELECTION, LongInt(normal), 0);
end;

function TScintilla.PointXFromPosition(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_POINTXFROMPOSITION, 0, pos);
end;

function TScintilla.PointYFromPosition(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_POINTYFROMPOSITION, 0, pos);
end;

function TScintilla.LineFromPosition(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_LINEFROMPOSITION, pos, 0);
end;

function TScintilla.PositionFromLine(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_POSITIONFROMLINE, line, 0);
end;

procedure TScintilla.LineScroll(columns : LongInt; lines : LongInt);
begin
  SPerform(SCI_LINESCROLL, columns, lines);
end;

procedure TScintilla.ScrollCaret;
begin
  SPerform(SCI_SCROLLCARET, 0, 0);
end;

procedure TScintilla.ReplaceSel(text : PChar);
begin
  SPerform(SCI_REPLACESEL, 0, LongInt(text));
end;

procedure TScintilla.SetReadOnly(readOnly : LongBool);
begin
  SPerform(SCI_SETREADONLY, LongInt(readOnly), 0);
end;

procedure TScintilla.Null;
begin
  SPerform(SCI_NULL, 0, 0);
end;

function TScintilla.CanPaste : LongBool;
begin
  result := LongBool(SPerform(SCI_CANPASTE, 0, 0));
end;

function TScintilla.CanUndo : LongBool;
begin
  result := LongBool(SPerform(SCI_CANUNDO, 0, 0));
end;

procedure TScintilla.EmptyUndoBuffer;
begin
  SPerform(SCI_EMPTYUNDOBUFFER, 0, 0);
end;

procedure TScintilla.Undo;
begin
  SPerform(SCI_UNDO, 0, 0);
end;

procedure TScintilla.Cut;
begin
  SPerform(SCI_CUT, 0, 0);
end;

procedure TScintilla.Copy;
begin
  SPerform(SCI_COPY, 0, 0);
end;

procedure TScintilla.Paste;
begin
  SPerform(SCI_PASTE, 0, 0);
end;

procedure TScintilla.Clear;
begin
  SPerform(SCI_CLEAR, 0, 0);
end;

procedure TScintilla.SetText(text : PChar);
begin
  SPerform(SCI_SETTEXT, 0, LongInt(text));
end;

function TScintilla.GetText(length : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_GETTEXT, length, LongInt(text));
end;

function TScintilla.GetTextLength : LongInt;
begin
  result := SPerform(SCI_GETTEXTLENGTH, 0, 0);
end;

function TScintilla.GetDirectFunction : LongInt;
begin
  result := SPerform(SCI_GETDIRECTFUNCTION, 0, 0);
end;

function TScintilla.GetDirectPointer : LongInt;
begin
  result := SPerform(SCI_GETDIRECTPOINTER, 0, 0);
end;

procedure TScintilla.SetOvertype(overtype : LongBool);
begin
  SPerform(SCI_SETOVERTYPE, LongInt(overtype), 0);
end;

function TScintilla.GetOvertype : LongBool;
begin
  result := LongBool(SPerform(SCI_GETOVERTYPE, 0, 0));
end;

procedure TScintilla.SetCaretWidth(pixelWidth : LongInt);
begin
  SPerform(SCI_SETCARETWIDTH, pixelWidth, 0);
end;

function TScintilla.GetCaretWidth : LongInt;
begin
  result := SPerform(SCI_GETCARETWIDTH, 0, 0);
end;

procedure TScintilla.SetTargetStart(pos : LongInt);
begin
  SPerform(SCI_SETTARGETSTART, pos, 0);
end;

function TScintilla.GetTargetStart : LongInt;
begin
  result := SPerform(SCI_GETTARGETSTART, 0, 0);
end;

procedure TScintilla.SetTargetEnd(pos : LongInt);
begin
  SPerform(SCI_SETTARGETEND, pos, 0);
end;

function TScintilla.GetTargetEnd : LongInt;
begin
  result := SPerform(SCI_GETTARGETEND, 0, 0);
end;

function TScintilla.ReplaceTarget(length : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_REPLACETARGET, length, LongInt(text));
end;

function TScintilla.ReplaceTargetRE(length : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_REPLACETARGETRE, length, LongInt(text));
end;

function TScintilla.SearchInTarget(length : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_SEARCHINTARGET, length, LongInt(text));
end;

procedure TScintilla.SetSearchFlags(flags : LongInt);
begin
  SPerform(SCI_SETSEARCHFLAGS, flags, 0);
end;

function TScintilla.GetSearchFlags : LongInt;
begin
  result := SPerform(SCI_GETSEARCHFLAGS, 0, 0);
end;

procedure TScintilla.CallTipShow(pos : LongInt; definition : PChar);
begin
  SPerform(SCI_CALLTIPSHOW, pos, LongInt(definition));
end;

procedure TScintilla.CallTipCancel;
begin
  SPerform(SCI_CALLTIPCANCEL, 0, 0);
end;

function TScintilla.CallTipActive : LongBool;
begin
  result := LongBool(SPerform(SCI_CALLTIPACTIVE, 0, 0));
end;

function TScintilla.CallTipPosStart : LongInt;
begin
  result := SPerform(SCI_CALLTIPPOSSTART, 0, 0);
end;

procedure TScintilla.CallTipSetHlt(start : LongInt; end_ : LongInt);
begin
  SPerform(SCI_CALLTIPSETHLT, start, end_);
end;

procedure TScintilla.CallTipSetBack(back : LongInt);
begin
  SPerform(SCI_CALLTIPSETBACK, back, 0);
end;

procedure TScintilla.CallTipSetFore(fore : LongInt);
begin
  SPerform(SCI_CALLTIPSETFORE, fore, 0);
end;

procedure TScintilla.CallTipSetForeHlt(fore : LongInt);
begin
  SPerform(SCI_CALLTIPSETFOREHLT, fore, 0);
end;

function TScintilla.VisibleFromDocLine(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_VISIBLEFROMDOCLINE, line, 0);
end;

function TScintilla.DocLineFromVisible(lineDisplay : LongInt) : LongInt;
begin
  result := SPerform(SCI_DOCLINEFROMVISIBLE, lineDisplay, 0);
end;

procedure TScintilla.SetFoldLevel(line : LongInt; level : LongInt);
begin
  SPerform(SCI_SETFOLDLEVEL, line, level);
end;

function TScintilla.GetFoldLevel(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETFOLDLEVEL, line, 0);
end;

function TScintilla.GetLastChild(line : LongInt; level : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETLASTCHILD, line, level);
end;

function TScintilla.GetFoldParent(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETFOLDPARENT, line, 0);
end;

procedure TScintilla.ShowLines(lineStart : LongInt; lineEnd : LongInt);
begin
  SPerform(SCI_SHOWLINES, lineStart, lineEnd);
end;

procedure TScintilla.HideLines(lineStart : LongInt; lineEnd : LongInt);
begin
  SPerform(SCI_HIDELINES, lineStart, lineEnd);
end;

function TScintilla.GetLineVisible(line : LongInt) : LongBool;
begin
  result := LongBool(SPerform(SCI_GETLINEVISIBLE, line, 0));
end;

procedure TScintilla.SetFoldExpanded(line : LongInt; expanded : LongBool);
begin
  SPerform(SCI_SETFOLDEXPANDED, line, LongInt(expanded));
end;

function TScintilla.GetFoldExpanded(line : LongInt) : LongBool;
begin
  result := LongBool(SPerform(SCI_GETFOLDEXPANDED, line, 0));
end;

procedure TScintilla.ToggleFold(line : LongInt);
begin
  SPerform(SCI_TOGGLEFOLD, line, 0);
end;

procedure TScintilla.EnsureVisible(line : LongInt);
begin
  SPerform(SCI_ENSUREVISIBLE, line, 0);
end;

procedure TScintilla.SetFoldFlags(flags : LongInt);
begin
  SPerform(SCI_SETFOLDFLAGS, flags, 0);
end;

procedure TScintilla.EnsureVisibleEnforcePolicy(line : LongInt);
begin
  SPerform(SCI_ENSUREVISIBLEENFORCEPOLICY, line, 0);
end;

procedure TScintilla.SetTabIndents(tabIndents : LongBool);
begin
  SPerform(SCI_SETTABINDENTS, LongInt(tabIndents), 0);
end;

function TScintilla.GetTabIndents : LongBool;
begin
  result := LongBool(SPerform(SCI_GETTABINDENTS, 0, 0));
end;

procedure TScintilla.SetBackSpaceUnIndents(bsUnIndents : LongBool);
begin
  SPerform(SCI_SETBACKSPACEUNINDENTS, LongInt(bsUnIndents), 0);
end;

function TScintilla.GetBackSpaceUnIndents : LongBool;
begin
  result := LongBool(SPerform(SCI_GETBACKSPACEUNINDENTS, 0, 0));
end;

procedure TScintilla.SetMouseDwellTime(periodMilliseconds : LongInt);
begin
  SPerform(SCI_SETMOUSEDWELLTIME, periodMilliseconds, 0);
end;

function TScintilla.GetMouseDwellTime : LongInt;
begin
  result := SPerform(SCI_GETMOUSEDWELLTIME, 0, 0);
end;

function TScintilla.WordStartPosition(pos : LongInt; onlyWordCharacters : LongBool) : LongInt;
begin
  result := SPerform(SCI_WORDSTARTPOSITION, pos, LongInt(onlyWordCharacters));
end;

function TScintilla.WordEndPosition(pos : LongInt; onlyWordCharacters : LongBool) : LongInt;
begin
  result := SPerform(SCI_WORDENDPOSITION, pos, LongInt(onlyWordCharacters));
end;

procedure TScintilla.SetWrapMode(mode : LongInt);
begin
  SPerform(SCI_SETWRAPMODE, mode, 0);
end;

function TScintilla.GetWrapMode : LongInt;
begin
  result := SPerform(SCI_GETWRAPMODE, 0, 0);
end;

procedure TScintilla.SetLayoutCache(mode : LongInt);
begin
  SPerform(SCI_SETLAYOUTCACHE, mode, 0);
end;

function TScintilla.GetLayoutCache : LongInt;
begin
  result := SPerform(SCI_GETLAYOUTCACHE, 0, 0);
end;

procedure TScintilla.SetScrollWidth(pixelWidth : LongInt);
begin
  SPerform(SCI_SETSCROLLWIDTH, pixelWidth, 0);
end;

function TScintilla.GetScrollWidth : LongInt;
begin
  result := SPerform(SCI_GETSCROLLWIDTH, 0, 0);
end;

function TScintilla.TextWidth(style : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_TEXTWIDTH, style, LongInt(text));
end;

procedure TScintilla.SetEndAtLastLine(endAtLastLine : LongBool);
begin
  SPerform(SCI_SETENDATLASTLINE, LongInt(endAtLastLine), 0);
end;

function TScintilla.GetEndAtLastLine : LongInt;
begin
  result := SPerform(SCI_GETENDATLASTLINE, 0, 0);
end;

function TScintilla.TextHeight(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_TEXTHEIGHT, line, 0);
end;

procedure TScintilla.SetVScrollBar(show : LongBool);
begin
  SPerform(SCI_SETVSCROLLBAR, LongInt(show), 0);
end;

function TScintilla.GetVScrollBar : LongBool;
begin
  result := LongBool(SPerform(SCI_GETVSCROLLBAR, 0, 0));
end;

procedure TScintilla.AppendText(length : LongInt; text : PChar);
begin
  SPerform(SCI_APPENDTEXT, length, LongInt(text));
end;

function TScintilla.GetTwoPhaseDraw : LongBool;
begin
  result := LongBool(SPerform(SCI_GETTWOPHASEDRAW, 0, 0));
end;

procedure TScintilla.SetTwoPhaseDraw(twoPhase : LongBool);
begin
  SPerform(SCI_SETTWOPHASEDRAW, LongInt(twoPhase), 0);
end;

procedure TScintilla.TargetFromSelection;
begin
  SPerform(SCI_TARGETFROMSELECTION, 0, 0);
end;

procedure TScintilla.LinesJoin;
begin
  SPerform(SCI_LINESJOIN, 0, 0);
end;

procedure TScintilla.LinesSplit(pixelWidth : LongInt);
begin
  SPerform(SCI_LINESSPLIT, pixelWidth, 0);
end;

procedure TScintilla.SetFoldMarginColour(useSetting : LongBool; back : LongInt);
begin
  SPerform(SCI_SETFOLDMARGINCOLOUR, LongInt(useSetting), back);
end;

procedure TScintilla.SetFoldMarginHiColour(useSetting : LongBool; fore : LongInt);
begin
  SPerform(SCI_SETFOLDMARGINHICOLOUR, LongInt(useSetting), fore);
end;

procedure TScintilla.LineDown;
begin
  SPerform(SCI_LINEDOWN, 0, 0);
end;

procedure TScintilla.LineDownExtend;
begin
  SPerform(SCI_LINEDOWNEXTEND, 0, 0);
end;

procedure TScintilla.LineUp;
begin
  SPerform(SCI_LINEUP, 0, 0);
end;

procedure TScintilla.LineUpExtend;
begin
  SPerform(SCI_LINEUPEXTEND, 0, 0);
end;

procedure TScintilla.CharLeft;
begin
  SPerform(SCI_CHARLEFT, 0, 0);
end;

procedure TScintilla.CharLeftExtend;
begin
  SPerform(SCI_CHARLEFTEXTEND, 0, 0);
end;

procedure TScintilla.CharRight;
begin
  SPerform(SCI_CHARRIGHT, 0, 0);
end;

procedure TScintilla.CharRightExtend;
begin
  SPerform(SCI_CHARRIGHTEXTEND, 0, 0);
end;

procedure TScintilla.WordLeft;
begin
  SPerform(SCI_WORDLEFT, 0, 0);
end;

procedure TScintilla.WordLeftExtend;
begin
  SPerform(SCI_WORDLEFTEXTEND, 0, 0);
end;

procedure TScintilla.WordRight;
begin
  SPerform(SCI_WORDRIGHT, 0, 0);
end;

procedure TScintilla.WordRightExtend;
begin
  SPerform(SCI_WORDRIGHTEXTEND, 0, 0);
end;

procedure TScintilla.Home;
begin
  SPerform(SCI_HOME, 0, 0);
end;

procedure TScintilla.HomeExtend;
begin
  SPerform(SCI_HOMEEXTEND, 0, 0);
end;

procedure TScintilla.LineEnd;
begin
  SPerform(SCI_LINEEND, 0, 0);
end;

procedure TScintilla.LineEndExtend;
begin
  SPerform(SCI_LINEENDEXTEND, 0, 0);
end;

procedure TScintilla.DocumentStart;
begin
  SPerform(SCI_DOCUMENTSTART, 0, 0);
end;

procedure TScintilla.DocumentStartExtend;
begin
  SPerform(SCI_DOCUMENTSTARTEXTEND, 0, 0);
end;

procedure TScintilla.DocumentEnd;
begin
  SPerform(SCI_DOCUMENTEND, 0, 0);
end;

procedure TScintilla.DocumentEndExtend;
begin
  SPerform(SCI_DOCUMENTENDEXTEND, 0, 0);
end;

procedure TScintilla.PageUp;
begin
  SPerform(SCI_PAGEUP, 0, 0);
end;

procedure TScintilla.PageUpExtend;
begin
  SPerform(SCI_PAGEUPEXTEND, 0, 0);
end;

procedure TScintilla.PageDown;
begin
  SPerform(SCI_PAGEDOWN, 0, 0);
end;

procedure TScintilla.PageDownExtend;
begin
  SPerform(SCI_PAGEDOWNEXTEND, 0, 0);
end;

procedure TScintilla.EditToggleOvertype;
begin
  SPerform(SCI_EDITTOGGLEOVERTYPE, 0, 0);
end;

procedure TScintilla.Cancel;
begin
  SPerform(SCI_CANCEL, 0, 0);
end;

procedure TScintilla.DeleteBack;
begin
  SPerform(SCI_DELETEBACK, 0, 0);
end;

procedure TScintilla.Tab;
begin
  SPerform(SCI_TAB, 0, 0);
end;

procedure TScintilla.BackTab;
begin
  SPerform(SCI_BACKTAB, 0, 0);
end;

procedure TScintilla.NewLine;
begin
  SPerform(SCI_NEWLINE, 0, 0);
end;

procedure TScintilla.FormFeed;
begin
  SPerform(SCI_FORMFEED, 0, 0);
end;

procedure TScintilla.VCHome;
begin
  SPerform(SCI_VCHOME, 0, 0);
end;

procedure TScintilla.VCHomeExtend;
begin
  SPerform(SCI_VCHOMEEXTEND, 0, 0);
end;

procedure TScintilla.ZoomIn;
begin
  SPerform(SCI_ZOOMIN, 0, 0);
end;

procedure TScintilla.ZoomOut;
begin
  SPerform(SCI_ZOOMOUT, 0, 0);
end;

procedure TScintilla.DelWordLeft;
begin
  SPerform(SCI_DELWORDLEFT, 0, 0);
end;

procedure TScintilla.DelWordRight;
begin
  SPerform(SCI_DELWORDRIGHT, 0, 0);
end;

procedure TScintilla.LineCut;
begin
  SPerform(SCI_LINECUT, 0, 0);
end;

procedure TScintilla.LineDelete;
begin
  SPerform(SCI_LINEDELETE, 0, 0);
end;

procedure TScintilla.LineTranspose;
begin
  SPerform(SCI_LINETRANSPOSE, 0, 0);
end;

procedure TScintilla.LineDuplicate;
begin
  SPerform(SCI_LINEDUPLICATE, 0, 0);
end;

procedure TScintilla.LowerCase;
begin
  SPerform(SCI_LOWERCASE, 0, 0);
end;

procedure TScintilla.UpperCase;
begin
  SPerform(SCI_UPPERCASE, 0, 0);
end;

procedure TScintilla.LineScrollDown;
begin
  SPerform(SCI_LINESCROLLDOWN, 0, 0);
end;

procedure TScintilla.LineScrollUp;
begin
  SPerform(SCI_LINESCROLLUP, 0, 0);
end;

procedure TScintilla.DeleteBackNotLine;
begin
  SPerform(SCI_DELETEBACKNOTLINE, 0, 0);
end;

procedure TScintilla.HomeDisplay;
begin
  SPerform(SCI_HOMEDISPLAY, 0, 0);
end;

procedure TScintilla.HomeDisplayExtend;
begin
  SPerform(SCI_HOMEDISPLAYEXTEND, 0, 0);
end;

procedure TScintilla.LineEndDisplay;
begin
  SPerform(SCI_LINEENDDISPLAY, 0, 0);
end;

procedure TScintilla.LineEndDisplayExtend;
begin
  SPerform(SCI_LINEENDDISPLAYEXTEND, 0, 0);
end;

procedure TScintilla.HomeWrap;
begin
  SPerform(SCI_HOMEWRAP, 0, 0);
end;

procedure TScintilla.HomeWrapExtend;
begin
  SPerform(SCI_HOMEWRAPEXTEND, 0, 0);
end;

procedure TScintilla.LineEndWrap;
begin
  SPerform(SCI_LINEENDWRAP, 0, 0);
end;

procedure TScintilla.LineEndWrapExtend;
begin
  SPerform(SCI_LINEENDWRAPEXTEND, 0, 0);
end;

procedure TScintilla.VCHomeWrap;
begin
  SPerform(SCI_VCHOMEWRAP, 0, 0);
end;

procedure TScintilla.VCHomeWrapExtend;
begin
  SPerform(SCI_VCHOMEWRAPEXTEND, 0, 0);
end;

procedure TScintilla.LineCopy;
begin
  SPerform(SCI_LINECOPY, 0, 0);
end;

procedure TScintilla.MoveCaretInsideView;
begin
  SPerform(SCI_MOVECARETINSIDEVIEW, 0, 0);
end;

function TScintilla.LineLength(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_LINELENGTH, line, 0);
end;

procedure TScintilla.BraceHighlight(pos1 : LongInt; pos2 : LongInt);
begin
  SPerform(SCI_BRACEHIGHLIGHT, pos1, pos2);
end;

procedure TScintilla.BraceBadLight(pos : LongInt);
begin
  SPerform(SCI_BRACEBADLIGHT, pos, 0);
end;

function TScintilla.BraceMatch(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_BRACEMATCH, pos, 0);
end;

function TScintilla.GetViewEOL : LongBool;
begin
  result := LongBool(SPerform(SCI_GETVIEWEOL, 0, 0));
end;

procedure TScintilla.SetViewEOL(visible : LongBool);
begin
  SPerform(SCI_SETVIEWEOL, LongInt(visible), 0);
end;

function TScintilla.GetDocPointer : LongInt;
begin
  result := SPerform(SCI_GETDOCPOINTER, 0, 0);
end;

procedure TScintilla.SetDocPointer(pointer : LongInt);
begin
  SPerform(SCI_SETDOCPOINTER, 0, pointer);
end;

procedure TScintilla.SetModEventMask(mask : LongInt);
begin
  SPerform(SCI_SETMODEVENTMASK, mask, 0);
end;

function TScintilla.GetEdgeColumn : LongInt;
begin
  result := SPerform(SCI_GETEDGECOLUMN, 0, 0);
end;

procedure TScintilla.SetEdgeColumn(column : LongInt);
begin
  SPerform(SCI_SETEDGECOLUMN, column, 0);
end;

function TScintilla.GetEdgeMode : LongInt;
begin
  result := SPerform(SCI_GETEDGEMODE, 0, 0);
end;

procedure TScintilla.SetEdgeMode(mode : LongInt);
begin
  SPerform(SCI_SETEDGEMODE, mode, 0);
end;

function TScintilla.GetEdgeColour : LongInt;
begin
  result := SPerform(SCI_GETEDGECOLOUR, 0, 0);
end;

procedure TScintilla.SetEdgeColour(edgeColour : LongInt);
begin
  SPerform(SCI_SETEDGECOLOUR, edgeColour, 0);
end;

procedure TScintilla.SearchAnchor;
begin
  SPerform(SCI_SEARCHANCHOR, 0, 0);
end;

function TScintilla.SearchNext(flags : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_SEARCHNEXT, flags, LongInt(text));
end;

function TScintilla.SearchPrev(flags : LongInt; text : PChar) : LongInt;
begin
  result := SPerform(SCI_SEARCHPREV, flags, LongInt(text));
end;

function TScintilla.LinesOnScreen : LongInt;
begin
  result := SPerform(SCI_LINESONSCREEN, 0, 0);
end;

procedure TScintilla.UsePopUp(allowPopUp : LongBool);
begin
  SPerform(SCI_USEPOPUP, LongInt(allowPopUp), 0);
end;

function TScintilla.SelectionIsRectangle : LongBool;
begin
  result := LongBool(SPerform(SCI_SELECTIONISRECTANGLE, 0, 0));
end;

procedure TScintilla.SetZoom(zoom : LongInt);
begin
  SPerform(SCI_SETZOOM, zoom, 0);
end;

function TScintilla.GetZoom : LongInt;
begin
  result := SPerform(SCI_GETZOOM, 0, 0);
end;

function TScintilla.CreateDocument : LongInt;
begin
  result := SPerform(SCI_CREATEDOCUMENT, 0, 0);
end;

procedure TScintilla.AddRefDocument(doc : LongInt);
begin
  SPerform(SCI_ADDREFDOCUMENT, 0, doc);
end;

procedure TScintilla.ReleaseDocument(doc : LongInt);
begin
  SPerform(SCI_RELEASEDOCUMENT, 0, doc);
end;

function TScintilla.GetModEventMask : LongInt;
begin
  result := SPerform(SCI_GETMODEVENTMASK, 0, 0);
end;

procedure TScintilla.SetFocusEx(focus : LongBool);
begin
  SPerform(SCI_SETFOCUSEX, LongInt(focus), 0);
end;

function TScintilla.GetFocus : LongBool;
begin
  result := LongBool(SPerform(SCI_GETFOCUS, 0, 0));
end;

procedure TScintilla.SetStatus(statusCode : LongInt);
begin
  SPerform(SCI_SETSTATUS, statusCode, 0);
end;

function TScintilla.GetStatus : LongInt;
begin
  result := SPerform(SCI_GETSTATUS, 0, 0);
end;

procedure TScintilla.SetMouseDownCaptures(captures : LongBool);
begin
  SPerform(SCI_SETMOUSEDOWNCAPTURES, LongInt(captures), 0);
end;

function TScintilla.GetMouseDownCaptures : LongBool;
begin
  result := LongBool(SPerform(SCI_GETMOUSEDOWNCAPTURES, 0, 0));
end;

procedure TScintilla.SetCursor(cursorType : LongInt);
begin
  SPerform(SCI_SETCURSOR, cursorType, 0);
end;

function TScintilla.GetCursor : LongInt;
begin
  result := SPerform(SCI_GETCURSOR, 0, 0);
end;

procedure TScintilla.SetControlCharSymbol(symbol : LongInt);
begin
  SPerform(SCI_SETCONTROLCHARSYMBOL, symbol, 0);
end;

function TScintilla.GetControlCharSymbol : LongInt;
begin
  result := SPerform(SCI_GETCONTROLCHARSYMBOL, 0, 0);
end;

procedure TScintilla.WordPartLeft;
begin
  SPerform(SCI_WORDPARTLEFT, 0, 0);
end;

procedure TScintilla.WordPartLeftExtend;
begin
  SPerform(SCI_WORDPARTLEFTEXTEND, 0, 0);
end;

procedure TScintilla.WordPartRight;
begin
  SPerform(SCI_WORDPARTRIGHT, 0, 0);
end;

procedure TScintilla.WordPartRightExtend;
begin
  SPerform(SCI_WORDPARTRIGHTEXTEND, 0, 0);
end;

procedure TScintilla.SetVisiblePolicy(visiblePolicy : LongInt; visibleSlop : LongInt);
begin
  SPerform(SCI_SETVISIBLEPOLICY, visiblePolicy, visibleSlop);
end;

procedure TScintilla.DelLineLeft;
begin
  SPerform(SCI_DELLINELEFT, 0, 0);
end;

procedure TScintilla.DelLineRight;
begin
  SPerform(SCI_DELLINERIGHT, 0, 0);
end;

procedure TScintilla.SetXOffset(newOffset : LongInt);
begin
  SPerform(SCI_SETXOFFSET, newOffset, 0);
end;

function TScintilla.GetXOffset : LongInt;
begin
  result := SPerform(SCI_GETXOFFSET, 0, 0);
end;

procedure TScintilla.ChooseCaretX;
begin
  SPerform(SCI_CHOOSECARETX, 0, 0);
end;

procedure TScintilla.GrabFocus;
begin
  SPerform(SCI_GRABFOCUS, 0, 0);
end;

procedure TScintilla.SetXCaretPolicy(caretPolicy : LongInt; caretSlop : LongInt);
begin
  SPerform(SCI_SETXCARETPOLICY, caretPolicy, caretSlop);
end;

procedure TScintilla.SetYCaretPolicy(caretPolicy : LongInt; caretSlop : LongInt);
begin
  SPerform(SCI_SETYCARETPOLICY, caretPolicy, caretSlop);
end;

procedure TScintilla.SetPrintWrapMode(mode : LongInt);
begin
  SPerform(SCI_SETPRINTWRAPMODE, mode, 0);
end;

function TScintilla.GetPrintWrapMode : LongInt;
begin
  result := SPerform(SCI_GETPRINTWRAPMODE, 0, 0);
end;

procedure TScintilla.SetHotspotActiveFore(useSetting : LongBool; fore : LongInt);
begin
  SPerform(SCI_SETHOTSPOTACTIVEFORE, LongInt(useSetting), fore);
end;

procedure TScintilla.SetHotspotActiveBack(useSetting : LongBool; back : LongInt);
begin
  SPerform(SCI_SETHOTSPOTACTIVEBACK, LongInt(useSetting), back);
end;

procedure TScintilla.SetHotspotActiveUnderline(underline : LongBool);
begin
  SPerform(SCI_SETHOTSPOTACTIVEUNDERLINE, LongInt(underline), 0);
end;

procedure TScintilla.SetHotspotSingleLine(singleLine : LongBool);
begin
  SPerform(SCI_SETHOTSPOTSINGLELINE, LongInt(singleLine), 0);
end;

procedure TScintilla.ParaDown;
begin
  SPerform(SCI_PARADOWN, 0, 0);
end;

procedure TScintilla.ParaDownExtend;
begin
  SPerform(SCI_PARADOWNEXTEND, 0, 0);
end;

procedure TScintilla.ParaUp;
begin
  SPerform(SCI_PARAUP, 0, 0);
end;

procedure TScintilla.ParaUpExtend;
begin
  SPerform(SCI_PARAUPEXTEND, 0, 0);
end;

function TScintilla.PositionBefore(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_POSITIONBEFORE, pos, 0);
end;

function TScintilla.PositionAfter(pos : LongInt) : LongInt;
begin
  result := SPerform(SCI_POSITIONAFTER, pos, 0);
end;

procedure TScintilla.CopyRange(start : LongInt; end_ : LongInt);
begin
  SPerform(SCI_COPYRANGE, start, end_);
end;

procedure TScintilla.CopyText(length : LongInt; text : PChar);
begin
  SPerform(SCI_COPYTEXT, length, LongInt(text));
end;

procedure TScintilla.SetSelectionMode(mode : LongInt);
begin
  SPerform(SCI_SETSELECTIONMODE, mode, 0);
end;

function TScintilla.GetSelectionMode : LongInt;
begin
  result := SPerform(SCI_GETSELECTIONMODE, 0, 0);
end;

function TScintilla.GetLineSelStartPosition(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETLINESELSTARTPOSITION, line, 0);
end;

function TScintilla.GetLineSelEndPosition(line : LongInt) : LongInt;
begin
  result := SPerform(SCI_GETLINESELENDPOSITION, line, 0);
end;

procedure TScintilla.LineDownRectExtend;
begin
  SPerform(SCI_LINEDOWNRECTEXTEND, 0, 0);
end;

procedure TScintilla.LineUpRectExtend;
begin
  SPerform(SCI_LINEUPRECTEXTEND, 0, 0);
end;

procedure TScintilla.CharLeftRectExtend;
begin
  SPerform(SCI_CHARLEFTRECTEXTEND, 0, 0);
end;

procedure TScintilla.CharRightRectExtend;
begin
  SPerform(SCI_CHARRIGHTRECTEXTEND, 0, 0);
end;

procedure TScintilla.HomeRectExtend;
begin
  SPerform(SCI_HOMERECTEXTEND, 0, 0);
end;

procedure TScintilla.VCHomeRectExtend;
begin
  SPerform(SCI_VCHOMERECTEXTEND, 0, 0);
end;

procedure TScintilla.LineEndRectExtend;
begin
  SPerform(SCI_LINEENDRECTEXTEND, 0, 0);
end;

procedure TScintilla.PageUpRectExtend;
begin
  SPerform(SCI_PAGEUPRECTEXTEND, 0, 0);
end;

procedure TScintilla.PageDownRectExtend;
begin
  SPerform(SCI_PAGEDOWNRECTEXTEND, 0, 0);
end;

procedure TScintilla.StartRecord;
begin
  SPerform(SCI_STARTRECORD, 0, 0);
end;

procedure TScintilla.StopRecord;
begin
  SPerform(SCI_STOPRECORD, 0, 0);
end;

procedure TScintilla.SetLexer(lexer : LongInt);
begin
  SPerform(SCI_SETLEXER, lexer, 0);
end;

function TScintilla.GetLexer : LongInt;
begin
  result := SPerform(SCI_GETLEXER, 0, 0);
end;

procedure TScintilla.Colourise(start : LongInt; end_ : LongInt);
begin
  SPerform(SCI_COLOURISE, start, end_);
end;

procedure TScintilla.SetProperty(key : PChar; value : PChar);
begin
  SPerform(SCI_SETPROPERTY, LongInt(key), LongInt(value));
end;

procedure TScintilla.SetKeyWords(keywordSet : LongInt; keyWords : PChar);
begin
  SPerform(SCI_SETKEYWORDS, keywordSet, LongInt(keyWords));
end;

procedure TScintilla.SetLexerLanguage(language : PChar);
begin
  SPerform(SCI_SETLEXERLANGUAGE, 0, LongInt(language));
end;

procedure TScintilla.LoadLexerLibrary(path : PChar);
begin
  SPerform(SCI_LOADLEXERLIBRARY, 0, LongInt(path));
end;

//--FuncImp
// ---------------------------------------------------------------------------------------------------
// End of Generated functions, code below implements the Delphi side of the control.
// ---------------------------------------------------------------------------------------------------

procedure TScintilla.GetRange(start,end_ : LongInt;var text : PChar);
var
range : TTextRange;
prange : PTextRange;
begin
    range.chrg.cpMin := start;
    range.chrg.cpMax := end_;
    range.lpstrText := @text;
	Self.GetTextRange(prange);
end;
procedure TScintilla.SetBorderStyle(Value: TBorderStyle);
begin
  If FBorderStyle <> Value then
  begin
    FBorderStyle := Value;
    RecreateWnd;
  end;
end;

procedure TScintilla.CMCtl3DChanged(var Message: TMessage);
begin
  if NewStyleControls and (FBorderStyle = bsSingle) then
  begin
    RecreateWnd;
  end;
  inherited;
end;

procedure TScintilla.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);

  CreateSubClass(Params, 'Scintilla');

  with Params do
  begin
    Style := WS_CHILD or WS_VSCROLL or WS_HSCROLL or WS_CLIPCHILDREN or WS_CLIPSIBLINGS;
    if NewStyleControls and Ctl3D and (FBorderStyle = bsSingle) then
    begin
      Style := Style and not WS_BORDER;
      ExStyle := ExStyle or WS_EX_CLIENTEDGE;
    end;
    //WindowClass.style := WindowClass.style and not (CS_HREDRAW or CS_VREDRAW);
  end;
end;

//////  Beginning of TScintillaStrings
Type
{ TScintillaStrings }
  TScintillaStrings = class(TStrings)
  private
    Memo: TScintilla;
  protected
    function Get(Index: Integer): string; override;
    function GetCount: Integer; override;
    function GetTextStr: string; override;
    procedure Put(Index: Integer; const S: string); override;
    procedure SetTextStr(const Value: string); override;
    procedure SetUpdateState(Updating: Boolean); override;
  public
    procedure Clear; override;
    procedure Delete(Index: Integer); override;
    procedure Insert(Index: Integer; const S: string); override;
  end;

function TScintillaStrings.GetCount: Integer;
begin
  Result := 0;
  if Memo.HandleAllocated then
  begin
    Result := Memo.GetLineCount;
    if Memo.GetLineEndPosition(Result-1) - Memo.PositionFromLine(Result-1) = 0 then Dec(Result);
  end;
end;

function TScintillaStrings.Get(Index: Integer): string;
var
  S : string;
  Len : integer;
begin
  Len := Memo.GetLineEndPosition(Index)-Memo.PositionFromLine(Index);
  if Len > 0 then begin
    SetLength(S, Len+2);
    Memo.GetLine(Index, PChar(S));
    Result := Copy(S, 1, Len);
  end else
    Result := '';
end;

procedure TScintillaStrings.Put(Index: Integer; const S: string);
var
  SelStart: Integer;
begin
  SelStart := Memo.PositionFromLine(Index);
  if SelStart >= 0 then
  begin
    Memo.SetTargetStart(SelStart);
    Memo.SetTargetEnd(Memo.GetLineEndPosition(Index));
    Memo.ReplaceTarget(-1, PChar(S));
  end;
end;

procedure TScintillaStrings.Insert(Index: Integer; const S: string);
var
  SelStart, LineLen: Integer;
  Line: string;
  EndOfLine : string;
begin
  if Index >= 0 then
  begin
    Case Memo.GetEOLMode of
      SC_EOL_CRLF : EndOfLine := #13#10;
      SC_EOL_CR   : EndOfLine := #13;
      SC_EOL_LF : EndOfLine := #10;
    end;
    SelStart := Memo.PositionFromLine(Index);
    if SelStart >= 0 then Line := S + EndOfLine else
    begin
      SelStart := Memo.PositionFromLine(Index-1);
      if SelStart < 0 then Exit;
      LineLen := Memo.GetLineEndPosition(Index-1) - SelStart;
      if LineLen = 0 then Exit;
      Inc(SelStart, LineLen);
      Line := EndOfLine + s;
    end;
    Memo.SetTargetStart(SelStart);
    Memo.SetTargetEnd(SelStart);
    Memo.ReplaceTarget(-1, PChar(Line));
  end;
end;

procedure TScintillaStrings.Delete(Index: Integer);
const
  Empty: PChar = '';
var
  SelStart, SelEnd: Integer;
begin
  SelStart := Memo.PositionFromLine(Index);
  if SelStart >= 0 then
  begin
    SelEnd := Memo.PositionFromLine(Index+1);
    if SelEnd < 0 then SelEnd := SelStart + Memo.LineLength(Index);
    Memo.SetTargetStart(SelStart);
    Memo.SetTargetEnd(SelEnd);
    Memo.ReplaceTarget(-1, Empty);
  end;
end;

procedure TScintillaStrings.Clear;
begin
  Memo.ClearAll;
end;

procedure TScintillaStrings.SetUpdateState(Updating: Boolean);
begin
  if Memo.HandleAllocated then
  begin
    SendMessage(Memo.Handle, WM_SETREDRAW, Ord(not Updating), 0);
    if not Updating then
    begin   // WM_SETREDRAW causes visibility side effects in memo controls
      Memo.Perform(CM_SHOWINGCHANGED,0,0); // This reasserts the visibility we want
      Memo.Refresh;
    end;
  end;
end;

function TScintillaStrings.GetTextStr: string;
begin
  Result := Memo.Text;
end;

procedure TScintillaStrings.SetTextStr(const Value: string);
var
  NewText: string;
  Style: TTextLineBreakStyle;
begin
  Case Memo.GetEOLMode of
    SC_EOL_CRLF : Style := tlbsCRLF;
    SC_EOL_LF : Style := tlbsLF;
  else
    Style := tlbsCRLF;   // no other line break style available
  end;
  NewText := AdjustLineBreaks(Value, Style);
  if (Length(NewText) <> Memo.GetTextLength) or (NewText <> Memo.Text) then
  begin
    Memo.SetText(PChar(NewText));
    Memo.Perform(CM_TEXTCHANGED, 0, 0);
  end;
end;

//////  End of TScintillaStrings
function  TScintilla.RangeIsAllWhiteSpace(start,end_ : LongInt) : Boolean;
	var
	i : LongInt;
	ch : Char;
begin
	for i:=start to (end_-1) do
	begin
		ch:=Char(GetCharAt(i));
		if ((ch <> ' ') and (ch <> '\t')) then
		begin
			result:=false;
			Exit;
		end;
	end;
	result:=true;
end;

function  TScintilla.GetCaretInLine : LongInt;
var
caret : LongInt;
line : LongInt;
lineStart : LongInt;
begin
	caret := GetCurrentPos;
	line := LineFromPosition(caret);
	lineStart := PositionFromLine(line);
	result := caret - lineStart;

end;
function  TScintilla.GetCurrentLineNumber : LongInt;
begin
	result :=LineFromPosition(GetCurrentPos());
end;
constructor TScintilla.Create(AOwner : TComponent);
//const
//  EditStyle = [csClickEvents, csSetCaption, csDoubleClicks];
begin
//  if NewStyleControls then
//    ControlStyle := EditStyle else
//  ControlStyle := EditStyle + [csFramed];

  //  Check whether Scintilla.DLL is available
  if scmod = 0 then
    Raise Exception.Create('"Scintilla.DLL" is not availabe.  '#13#10+
                           'Please make sure is located on the System Path');
  inherited;
  Width := 185;
  Height := 89;
  AutoSize := False;
  TabStop := True;
  FBorderStyle := bsSingle;
  FWantTabs := True;
  FWantReturns := True;
  FCodeFolding := False;
  FBraceHilite := True;
  ParentFont := False;
  ParentColor := False;
  ParentShowHint := True;
  ParentBiDiMode := False;
  FLines := TScintillaStrings.Create;
  TScintillaStrings(FLines).Memo := Self;
  fMargin0 := TMargin.Create(Self, 0);
  fMargin1:= TMargin.Create(Self, 1);
  fMargin2:= TMargin.Create(Self, 2);
  fHighlighter := TSciSynLexer.Create(Self);
  fKeyCommands := TSciKeyCommandCollection.Create(Self);
end;

destructor TScintilla.Destroy;
begin
  FLines.Free;
  fMargin0.Free;
  fMargin1.Free;
  fMargin2.Free;
  fHighlighter.Free;
  if Assigned(FStateStream) then FreeAndNil(FStateStream);
  inherited;
end;

procedure TScintilla.CreateWnd;
begin
  FCreating := True;
  try
    inherited CreateWnd;
  finally
    FCreating := False;
  end;
  //UpdateHeight;
  // Kiriakos
  //if (ComponentState * [csDesigning] = []) then
  //begin
    @SCPerform := Pointer( SendMessage(WindowHandle, SCI_GETDIRECTFUNCTION,0,0) );
    sccmdctr := Pointer( SendMessage(WindowHandle, SCI_GETDIRECTPOINTER,0,0) );
  //end;
  if (ComponentState * [csLoading, csReading] = []) and assigned(FStateStream) then begin
    fStateStream.Position := 0;
    fStateStream.ReadComponent(Self);
    FreeAndNil(fStateStream);
    Perform(CM_FONTCHANGED, 0, 0);
  end;
end;

procedure TScintilla.DestroyWnd;
begin
  if not (csDestroying in ComponentState) then begin
    if Assigned(FStateStream) then
      FStateStream.Position := 0
    else
      FStateStream := TMemoryStream.Create;
    FStateStream.WriteComponent(Self);
  end;
  inherited DestroyWnd;
end;

procedure TScintilla.DefaultHandler(var Message);
begin
  case TMessage(Message).Msg of
    WM_SETFOCUS:
      if (Win32Platform = VER_PLATFORM_WIN32_WINDOWS) and
        not IsWindow(TWMSetFocus(Message).FocusedWnd) then
        TWMSetFocus(Message).FocusedWnd := 0;
  end;
  inherited;
end;

procedure TScintilla.WMGetDlgCode(var Message: TWMGetDlgCode);
begin
  inherited;
  if FWantTabs then Message.Result := Message.Result or DLGC_WANTTAB
  else Message.Result := Message.Result and not DLGC_WANTTAB;
  if not FWantReturns then
    Message.Result := Message.Result and not DLGC_WANTALLKEYS;
  Message.Result := Message.Result or DLGC_WANTARROWS;
end;

procedure TScintilla.WMNCDestroy(var Message: TWMNCDestroy);
begin
  inherited;
end;

procedure TScintilla.WMNotify(var Message: TWMNotify);
var nmh : PNMHdr;
  scn : PSCNotification;
  // For Code Folding
  LineClick,
  LevelClick : integer;
begin
  //
  nmh := Message.NMHdr;

  if (nmh^.hwndFrom = Handle) then
  begin
    scn := PSCNotification(TMessage(Message).LParam);
    case nmh^.code of
      0 : ;
    //++EventImpl
      2000 : if assigned(FOnstyleneeded) then FOnstyleneeded(Self, scn^.position);
      2001 : begin
               CharAdded(scn^.ch);
               if assigned(FOncharadded) then FOncharadded(Self, scn^.ch);
             end;
      2002 : if assigned(FOnsavepointreached) then FOnsavepointreached(Self);
      2003 : if assigned(FOnsavepointleft) then FOnsavepointleft(Self);
      2004 : if assigned(FOnmodifyattemptro) then FOnmodifyattemptro(Self);
      2005 : if assigned(FOnkey) then FOnkey(Self, scn^.ch, scn^.modifiers);
      2006 : if assigned(FOndoubleclick) then FOndoubleclick(Self);
      2007 :
        begin
          if FBraceHilite then ProcessBraces;
          if assigned(FOnupdateui) then FOnupdateui(Self);
        end;
      2008 :
        with scn^ do begin
          if (modificationType and SC_MOD_CHANGEFOLD) <> 0 then begin
            if (foldLevelNow and SC_FOLDLEVELHEADERFLAG) <> 0 then begin
              if (foldLevelPrev and SC_FOLDLEVELHEADERFLAG) = 0 then
                SetFoldExpanded(line, True);
            end else if (foldLevelPrev and SC_FOLDLEVELHEADERFLAG) <> 0 then begin
              if not GetFoldExpanded(line) then
                // Removing the fold from one that has been contracted so should expand
                // otherwise lines are left invisible with no way to make them visible
                Expand(line, true, false, 0, foldLevelPrev);
            end;
          end;
          if assigned(FOnmodified) then FOnmodified(Self, position, modificationType, text, length, linesAdded, line, foldLevelNow, foldLevelPrev);
        end;
      2009 : if assigned(FOnmacrorecord) then FOnmacrorecord(Self, scn^.message, scn^.wParam, scn^.lParam);
      2010 :
        begin
          if FCodeFolding and (scn^.Margin = 2) then with scn^ do begin
            LineClick := LineFromPosition(Position);
            if (Modifiers and SCMOD_SHIFT <> 0) and (Modifiers and SCMOD_CTRL <> 0) then
              FoldAll
            else begin
              LevelClick := GetFoldLevel(LineClick);
              if (LevelClick and SC_FOLDLEVELHEADERFLAG) <> 0 then begin
                if (modifiers and SCMOD_SHIFT) <> 0 then begin
                  // Ensure all children visible
                  SetFoldExpanded(LineClick, True);
                  Expand(lineClick, true, true, 100, levelClick);
                end else if (modifiers and SCMOD_CTRL) <> 0 then begin
                  if GetFoldExpanded(lineClick) then begin
                    // Contract this line and all children
                    SetFoldExpanded(LineClick, False);
                    Expand(lineClick, false, true, 0, levelClick);
                  end else begin
                    // Expand this line and all children
                    SetFoldExpanded(LineClick, True);
                    Expand(lineClick, true, true, 100, levelClick);
                  end;
                end else begin
                  // Toggle this line
                  ToggleFold(LineClick);
                end;
              end;
            end;
          end;
          if assigned(FOnmarginclick) then FOnmarginclick(Self, scn^.modifiers, scn^.position, scn^.margin);
        end;
      2011 : if assigned(FOnneedshown) then FOnneedshown(Self, scn^.position, scn^.length);
      2013 : if assigned(FOnpainted) then FOnpainted(Self);
      2014 : if assigned(FOnuserlistselection) then FOnuserlistselection(Self, scn^.listType, scn^.text);
      2015 : if assigned(FOnuridropped) then FOnuridropped(Self, scn^.text);
      2016 : if assigned(FOndwellstart) then FOndwellstart(Self, scn^.position);
      2017 : if assigned(FOndwellend) then FOndwellend(Self, scn^.position);
      2018 : if assigned(FOnzoom) then FOnzoom(Self);
      2019 : if assigned(FOnhotspotclick) then FOnhotspotclick(Self, scn^.modifiers, scn^.position);
      2020 : if assigned(FOnhotspotdoubleclick) then FOnhotspotdoubleclick(Self, scn^.modifiers, scn^.position);
      2021 : if assigned(FOncalltipclick) then FOncalltipclick(Self, scn^.position);
    //--EventImpl
    end;
  end;
  inherited;
end;

////////////////////////////////////////////////////////////////////////////////

const bufSize = 131072;


procedure TScintilla.LoadFromStream(Stream: TStream);
{
  Load ANSI text. We need a separate functions to load UTF8 or WideChars
  Alternatively the Lines.Text property allows to load UTF8 if needed (when
  UseUnicode is true)
}
var
  buf : array[0..bufSize] of Char;
  read : Longint;
  OldUseUnicode : Boolean;
begin
  // Use the SCI_ADDTEXT method to add text to the control
  // from a file, having cleared it first!
  ClearAll;
  //  With UseUnicode option Scintilla expects UTF8 and not ANSI
  OldUseUnicode := UseUnicode;
  if OldUseUnicode then begin
    UseUnicode := False;
  end;

  read := Stream.read(buf, SizeOf(buf));
  while (read > 0) do
  begin
    AddText(read, buf);
    read := Stream.Read(buf, SizeOf(buf));
  end;

  // Restore Unicode
  if OldUseUnicode then UseUnicode := True;

  EmptyUndoBuffer;
  SetSavePoint;
  GotoPos(0);
end;

procedure TScintilla.SaveToStream(Stream: TStream);
{
  Saves ANSI text. We would need separate functions to save as UTF8 or WideChars
  Alternatively the Lines.Text property would give us raw UTF8 if needed (when
  UseUnicode is true)
}
var
  buf : array[0..bufSize+1] of Char;
  lengthdoc : Cardinal;
  i         : Cardinal;
  grabsize  : Cardinal;
  range     : TTextRange;
  prange    : PTextRange;
  OldUseUnicode : Boolean;
begin
  //  With UseUnicode option Scintilla will give us UTF8 and not ANSI
  OldUseUnicode := UseUnicode;
  if OldUseUnicode then begin
    UseUnicode := False;
  end;

  prange := @range;
  lengthdoc := Self.GetLength;
  if lengthdoc = 0 then Exit;
  i := 0;
  while i < lengthdoc do
  begin
    grabsize := lengthdoc - i;
    if grabsize > bufSize then
      grabsize := bufSize;
    range.chrg.cpMin := i;
    range.chrg.cpMax := i + grabsize;
    range.lpstrText := @buf;
    Self.GetTextRange(prange);
    Stream.Write(buf, grabsize);
    i := i + bufSize;
  end;

 // Restore Unicode
  if OldUseUnicode then UseUnicode := True;

  SetSavePoint;
  { TODO -oSimon -cEditorFunctionality : Add option to clear undo stack at this point. }
end;

procedure TScintilla.LoadFromFile(FileName: TFileName);
var
  op   : TFileStream;
begin
  ClearAll;
  op := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  try
    LoadFromStream(op);
  finally
    op.Free;
  end;
end;

procedure TScintilla.SaveToFile(FileName: TFileName);
var
  sv : TFileStream;
begin
  sv := TFileStream.Create(FileName, fmCreate or fmShareExclusive);
  try
    SaveToStream(sv);
  finally
    sv.Free;
  end;
end;

function TScintilla.SPerform(Msg, wParam, lParam: Integer) : LongInt;
begin
  HandleNeeded;  // KV
  Result := SCPerform(sccmdctr, Msg, wParam, lParam);
end;

procedure TScintilla.WMEraseBkgnd(var Message: TWMEraseBkgnd);

begin
	// If we don't do this, then in design mode we'll look really ugly...
	if ((csDesigning in ComponentState) and not (TMessage(Message).wParam = TMessage(Message).lParam)) then
        FillRect(Message.DC, ClientRect, GetStockObject(WHITE_BRUSH));

    Message.Result := 1;
end;

// The following code is used to allow an external object to receive all the
// calls to the scintilla control - instead of calling scintilla we just pass
// on the messages. To enable this, set up a OnMsgSent handler _FIRST_, and then
// set Dummy to true. This cannot be un-toggled!

function dummySCPerform(ptr: Pointer; Msg, wParam,
  lParam: Integer): Longint; cdecl;
begin
  if Assigned(fMsgSentDummyProc) then
    fMsgSentDummyProc(nil, Msg, wParam, lParam);
  Result := 0;
end;

procedure TScintilla.SetDummy(Value: Boolean);
begin
  SCPerform := @dummySCPerform;
  fMsgSentDummyProc := FOnMsgSent;
  FDummy := True;
end;

procedure TScintilla.SetLines(Const Value : TStrings);
begin
  FLines.Assign(Value);
end;

function TScintilla.GetUseUnicode: Boolean;
begin
  Result := GetCodePage = SC_CP_UTF8;
end;

procedure TScintilla.SetUseUnicode(const Value: Boolean);
begin
  if Value then
    SetCodePage(SC_CP_UTF8)
  else
    SetCodePage(0);
end;

procedure TScintilla.CMFontChanged(var Message: TMessage);
begin
  inherited;
  StyleSetFont(STYLE_DEFAULT, PChar(Font.Name));
  StyleSetSize(STYLE_DEFAULT, Font.Size);
  StyleSetCharacterSet(STYLE_DEFAULT, Font.Charset);
  StyleSetItalic(STYLE_DEFAULT, fsItalic in Font.Style);
  StyleSetBold(STYLE_DEFAULT, fsBold in Font.Style);
  StyleSetUnderline(STYLE_DEFAULT, fsUnderline in Font.Style);
  StyleSetFore(STYLE_DEFAULT, ColorToRGB(Font.Color));
  StyleClearAll;
  Highlighter.Update;
end;

procedure TScintilla.CMColorChanged(var Message: TMessage);
begin
  inherited;
  Self.StyleSetBack(STYLE_DEFAULT, ColorToRGB(Color));
  StyleClearAll;
  Highlighter.Update;
end;

procedure TScintilla.SetModified(const Value: LongBool);
begin
  if not Value then SetSavePoint;  // is there a way to tell Scintilla the buffer is modified?
end;

function TScintilla.ExecuteAction(Action: TBasicAction): boolean;
begin
  if Action is TEditAction then
  begin
    Result := TRUE;
    if Action is TEditCut then
      Cut
    else if Action is TEditCopy then
      Copy
    else if Action is TEditPaste then
      Paste
    else if Action is TEditDelete then
      Clear
    else if Action is TEditUndo then
      Undo
    else if Action is TEditSelectAll then
      SelectAll;
  end else
    Result := inherited ExecuteAction(Action);
end;

function TScintilla.UpdateAction(Action: TBasicAction): boolean;
begin
  if Action is TEditAction then
  begin
    Result := Focused;
    if Result then
    begin
      if (Action is TEditCut) or (Action is TEditCopy) then
        TEditAction(Action).Enabled := (GETSELECTIONSTART-GETSELECTIONEND) <> 0
      else if Action is TEditPaste then
        TEditAction(Action).Enabled := CanPaste
      else if Action is TEditDelete then
        TEditAction(Action).Enabled := TRUE
      else if Action is TEditUndo then
        TEditAction(Action).Enabled := CanUndo
      else if Action is TEditSelectAll then
        TEditAction(Action).Enabled := TRUE;
    end;
  end else
    Result := inherited UpdateAction(Action);
end;

procedure TScintilla.Loaded;
begin
  inherited;
  Self.SetSavePoint;
end;


{ TMargin }

procedure TMargin.Assign(Source: TPersistent);
begin
  if Source is TMargin then begin
    MarginType := TMargin(Source).MarginType;
    Width := TMargin(Source).Width;
  end else
    inherited;
end;

constructor TMargin.Create(Scintilla: TScintilla; Number : integer);
begin
  fScintilla := Scintilla;
  fNumber := Number;
end;

function TMargin.GetMarginType: TMarginType;
begin
  Result := TMarginType(fScintilla.GetMarginTypeN(fNumber))
end;

function TMargin.GetWidth: integer;
begin
  Result := fScintilla.GetMarginWidthN(fNumber)
end;

procedure TMargin.SetMarginType(const Value: TMarginType);
begin
  fScintilla.SetMarginTypeN(fNumber, Ord(Value));
end;

procedure TMargin.SetWidth(const Value: integer);
begin
  fScintilla.SetMarginWidthN(fNumber, Value)
end;

procedure TScintilla.SetMargins(const Index: Integer; const Value: TMargin);
begin
  case Index of
    0 : fMargin0.Assign(Value);
    1 : fMargin1.Assign(Value);
    2 : fMargin2.Assign(Value);
  end;
end;

function TScintilla.GetWordWrap: Boolean;
begin
  Result := Self.GetWrapMode <> SC_WRAP_NONE;
end;

procedure TScintilla.SetWordWrap(const Value: Boolean);
begin
  if Value then
    SetWrapMode(SC_WRAP_WORD)
  else
    SetWrapMode(SC_WRAP_NONE);
end;

function TScintilla.GetIndentation: TIndentationOptions;
begin
  Result := [];
  if fKeepIndent then Result := [KeepIndent];
  if GetTabIndents then Result := Result + [TabIndents];
  if GetBackSpaceUnIndents then Result := Result + [BackSpaceUnIndents];
  if GetIndentationGuides then Result := Result + [IndentationGuides];
end;

procedure TScintilla.SetIndentation(const Value: TIndentationOptions);
begin
  fKeepIndent := KeepIndent in Value;
  SetTabIndents(TabIndents in Value);
  SetBackSpaceUnIndents(BackSpaceUnIndents in Value);
  SetIndentationGuides(IndentationGuides in Value);
end;

procedure TScintilla.CharAdded(ch : integer);
Var
  eolMode : integer;
  curLine : integer;
  lastLine : integer;
  indentAmount : integer;
begin
  if fKeepIndent then begin
    eolMode := GetEOLMode;
    curLine := LineFromPosition(GetCurrentPos);
    lastLine := curLine - 1;
    indentAmount := 0;

    if (((eolMode = SC_EOL_CRLF) or (eolMode = SC_EOL_LF)) and (ch = 10)) or
             ((eolMode = SC_EOL_CR) and (ch = 13)) then begin
      while (lastLine >= 0) and
            (GetLineEndPosition(lastLine) - PositionFromLine(lastline) = 0) do
        Dec(lastLine);
      if (lastLine >= 0) then
              indentAmount := GetLineIndentation(lastLine);
      if (indentAmount > 0) then begin
        SetLineIndentation(curLine, indentAmount);
        SetCurrentPos(Self.GetLineIndentPosition(curLine));
        Self.SetSel(GetCurrentPos, GetCurrentPos);
      end;
    end;
  end;
end;

function TScintilla.GetEOLStyle: TEOLStyle;
begin
  Result := TEOLStyle(GETEOLMode);
end;

procedure TScintilla.SetEOLStyle(const Value: TEOLStyle);
begin
  SetEOLMode(Ord(Value));
  Self.ConvertEOLs(Ord(Value));
end;

procedure TScintilla.SetHighlighter(const Value: TSciSynLexer);
begin
  fHighlighter.Assign(Value);
end;

function TScintilla.GetSelection: string;
Var
  L : integer;
begin
  L := GetSelectionEnd - GetSelectionStart;
  if L > 0 then begin
    //SetLength(Result, L);
    // bug in Scintilla >= 1.54
    // was introduced sometime after v1.49
    SetLength(Result, L+1);
    GetSelText(Pchar(Result));
    Result := System.Copy(Result, 1, L);
  end else
    Result := '';
end;

procedure TScintilla.SetSelection(const Value: string);
begin
  ReplaceSel(PChar(Value));
end;

procedure TScintilla.ExportToHTML(Stream: TStream; Title : string);
Var
  StyleIsUsed  : array [0..STYLE_MAX+1] of boolean;

  procedure WriteS(const S : String);
  begin
    Stream.Write(S[1], Length(S));
  end;

  function ColorToHTMLColor(Color : TColor): string;
  var
    TempS : string;
  begin
    if ColorToIdent(Color, Result) then
      Delete(Result, 1, 2)
    else begin
      FmtStr(Result, '%s%.6x', ['#', Color]);
      // Now swap Blue and Red
      TempS := Result;
      Result[2] := TempS[6];
      Result[3] := TempS[7];
      Result[6] := TempS[2];
      Result[7] := TempS[3];
    end;
  end;

  procedure WriteStyle(const Style : TSciStyle);
  begin
    with Style do begin
      if not StyleIsUsed[StyleNumber] then exit;
      WriteS('.S'+IntToStr(StyleNumber)+ ' {'#13#10);
      if FontName <> '' then
        WriteS(#9'font-family:' + FontName + ';'#13#10);
      if FontSize <> 0 then
        WriteS(#9'font-size:' + IntToStr(Fontsize)+ 'pt' + ';'#13#10);
      if fsItalic in FontStyles then
        WriteS(#9'font-style: italic;'#13#10)
      else
        WriteS(#9'font-style: normal;'#13#10);
      if fsBold in FontStyles then
        WriteS(#9'font-weight: 700;'#13#10)
      else
        WriteS(#9'font-weight: 400;'#13#10);
      if fsUnderline in FontStyles then
         WriteS(#9'text-decoration:underline;'#13#10)
      else
         WriteS(#9'text-decoration:none;'#13#10);
      WriteS(#9'color: ' +  ColorToHTMLColor(ForeColor) +';'#13#10);
      WriteS(#9'tbackground: ' +  ColorToHTMLColor(ForeColor) +';'#13#10);
			WriteS('}'#13#10);
    end;
  end;

Var
  i, itab : integer;
  TabSize : integer;
  Style, StyleCurrent, LengthDoc : integer;
  ch : char;
begin
  Colourise(0,-1);
  TabSize := TabWidth;
  if TabSize = 0 then
    TabSize := 4;

  LengthDoc := GetLength;
  for i := 0 to STYLE_MAX + 1 do
    StyleIsUsed[i] := false;
  // check the used styles
  for i := 0 to LengthDoc do
    StyleIsUsed[GetStyleAt(i)] := true;
  StyleIsUsed[STYLE_DEFAULT] := true;

  WriteS('<!DOCTYPE html  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-strict.dtd">'#13#10);
  WriteS('<html xmlns="http://www.w3.org/1999/xhtml">'#13#10);
  WriteS('<head>'#13#10);
  WriteS('<title>'+Title+'</title>'#13#10);
  WriteS('<meta name="GENERATOR" content="SciTE - www.Scintilla.org" />'#13#10);
  if UseUnicode then
    WriteS('<meta http-equiv="Content-Type" content="text/html; charset=utf-8">' + #13#10);
  WriteS('<style type="text/css">'#13#10);

  // Write default style
  WriteS('span {'#13#10);
  WriteS(#9'font-family:' + Font.Name + ';'#13#10);
  WriteS(#9'font-size:' + IntToStr(Font.Size)+ 'pt' + ';'#13#10);
  if fsItalic in Font.Style then
    WriteS(#9'font-style: italic;'#13#10)
  else
    WriteS(#9'font-style: normal;'#13#10);
  if fsBold in Font.Style then
    WriteS(#9'font-weight: 700;'#13#10)
  else
    WriteS(#9'font-weight: 400;'#13#10);
  if fsUnderline in Font.Style then
     WriteS(#9'text-decoration:underline;'#13#10)
  else
     WriteS(#9'text-decoration:none;'#13#10);
  WriteS(#9'color: ' +  ColorToHTMLColor(Font.Color) +';'#13#10);
  WriteS(#9'background: ' +  ColorToHTMLColor(Color) +';'#13#10);
  WriteS('}'#13#10);
  // Write all styles
  for i := 0 to Highlighter.StyleList.Count - 1 do
    WriteStyle(Highlighter.StyleList.Items[i] as TSciStyle);

  WriteS('</style>'#13#10);
  WriteS('</head>'#13#10);
	if (Color <> clWhite) or (Color <> clWindow) then
		WriteS('<body bgcolor=' + ColorToHTMLColor(Color) + '>'#13#10)
	else
		WriteS('<body>'#13#10);

  StyleCurrent := GetStyleAt(0);
//  Line = Self.GetLine(0);
//	Level = (acc.LevelAt(line) & SC_FOLDLEVELNUMBERMASK) - SC_FOLDLEVELBASE;

  WriteS('<span>');
 	WriteS('&nbsp;&nbsp;');
	WriteS('<span class="S'+ IntToStr(styleCurrent) + '">');
	for i := 0 to lengthDoc -1 do begin
		ch := Char(GetCharAt(i) and $FF);
    Style := GetStyleAt(i);
  	if Style <> StyleCurrent then begin
  		WriteS('</span>');
			WriteS('<span class="S'+ IntToStr(styleCurrent) + '">');
			styleCurrent := style;
	  end;
		Case Ord(ch) of
      Ord(' ') :
        begin
          if (Char(GetCharAt(i+1) and $FF) <> ' ') or (i+1 >= LengthDoc) then
            // Single space, kept as is
            WriteS(' ')
          else
            WriteS('&nbsp;');
        end;
      $9 :  //Tab
        for itab := 1 to TabSize do WriteS('&nbsp;');
      $D, $A :
        begin
  				if not ((ch = #13) and (GetCharAt(i+1) = $A)) then begin
	  				WriteS('<br/>');
            WriteS('</span>');
            StyleCurrent := GetStyleAt(i + 1);
            WriteS(#13#10);
            // we know it's the correct next style
            WriteS('<span class="S'+ IntToStr(styleCurrent) + '">');
          end;
			  end;
      Ord('<') : WriteS('&lt;');
      Ord('>') : WriteS('&gt;');
      Ord('&') : WriteS('&amp;');
    else
      WriteS(ch);
    end;
  end;
  WriteS('</span>');
  WriteS('</span>');
	WriteS(#13#10'</body>'#13#10'</html>'#13#10);
end;

procedure TScintilla.SetCodeFolding(const Value: Boolean);
  procedure DefineMarker(MarkNum, Marker, ForeCol, BackCol : integer);
  begin
    MarkerDefine(MarkNum, Marker);
    MarkerSetFore(MarkNum, ForeCol);
    MarkerSetBack(MarkNum, BackCol);
  end;

begin
  //if Value = fCodeFolding then exit;
  if Value then begin
    Gutter2.Width := 14;
    // Respond to mouse click
    SetMarginSensitiveN(2, True);
    // Tell the lexer that we want folidng info
    SetProperty('fold', '1');
    SetProperty('fold.compact', '0');  // Do not fold blank lines at block end
    SetProperty('fold.comment', '1');  // Fold multiline comments
    SetProperty('fold.preprocessor', '1');
    SetFoldFlags(16);
    // Set folding styles
    DefineMarker(SC_MARKNUM_FOLDEROPEN, SC_MARK_CIRCLEMINUS, RGB($FF, $FF, $FF), RGB($40, $40, $40));
    DefineMarker(SC_MARKNUM_FOLDER, SC_MARK_CIRCLEPLUS, RGB($FF, $FF, $FF), RGB($40, $40, $40));
    DefineMarker(SC_MARKNUM_FOLDERSUB, SC_MARK_VLINE, RGB($FF, $FF, $FF), RGB($40, $40, $40));
    DefineMarker(SC_MARKNUM_FOLDERTAIL, SC_MARK_LCORNERCURVE, RGB($FF, $FF, $FF), RGB($40, $40, $40));
    DefineMarker(SC_MARKNUM_FOLDEREND, SC_MARK_CIRCLEPLUSCONNECTED, RGB($FF, $FF, $FF), RGB($40, $40, $40));
    DefineMarker(SC_MARKNUM_FOLDEROPENMID, SC_MARK_CIRCLEMINUSCONNECTED, RGB($FF, $FF, $FF), RGB($40, $40, $40));
    DefineMarker(SC_MARKNUM_FOLDERMIDTAIL, SC_MARK_TCORNERCURVE, RGB($FF, $FF, $FF), RGB($40, $40, $40));
    SetMarginMaskN(2,Integer(SC_MASK_FOLDERS));
    //  The following is to handle SC_MOD_CHANGEFOLD in the Modified event handler
    SetModEventMask(GetModEventMask or SC_MOD_CHANGEFOLD);
  end else begin
    SetProperty('fold', '0');
    Gutter2.Width := 0;
  end;
  fCodeFolding := Value;
end;

procedure TScintilla.Expand(var line: integer; doExpand, force: Boolean;
  visLevels, level: integer);
Var
  lineMaxSubord : integer;
  LevelLine : integer;
begin
  lineMaxSubord :=  GetLastChild(line, level and SC_FOLDLEVELNUMBERMASK);
  Inc(Line);
  while (line <= lineMaxSubord) do begin
    if force then begin
      if visLevels > 0 then
        ShowLines(line, line)
      else
        HideLines(line, line)
    end else begin
      if doExpand then
        ShowLines(line, line)
    end;
    LevelLine := level;
    if LevelLine = -1 then
      LevelLine := GetFoldLevel(line);
    if (levelLine and SC_FOLDLEVELHEADERFLAG) <> 0 then begin
      if force then begin
        if visLevels > 1 then
          SetFoldExpanded(line, True)
        else
          SetFoldExpanded(line, False);
        Expand(line, doExpand, force, visLevels - 1);
      end else begin
        if doExpand then begin
          if not GetFoldExpanded(line) then
            SetFoldExpanded(line, True);
          Expand(line, true, force, visLevels - 1);
        end else
          Expand(line, false, force, visLevels - 1);
      end;
    end else
      Inc(Line);
  end;
end;

procedure TScintilla.FoldAll;
Var
  MaxLine : integer;
  LineSeek : integer;
  Line : integer;
  Level : integer;
  LineMaxSubord : Integer;
  Expanding : Boolean;
begin
  Colourise(0, -1);
  MaxLine := GetLineCount;
  Expanding := True;
  for LineSeek := 0 to MaxLine -1 do begin
    if (GetFoldLevel(LineSeek) and  SC_FOLDLEVELHEADERFLAG) > 0 then begin
      Expanding := not GetFoldExpanded(LineSeek);
      break;
    end;
  end;
  Line := 0;
  While Line < MaxLine do begin
    level := GetFoldLevel(line);
    if ((level and SC_FOLDLEVELHEADERFLAG) <> 0) and
		        (SC_FOLDLEVELBASE = (level and SC_FOLDLEVELNUMBERMASK)) then begin
      if expanding then begin
        SetFoldExpanded(line, True);
        Expand(line, true, false, 0, level);
        Dec(Line);
      end else begin
        LineMaxSubord := GetLastChild(line, -1);
        SetFoldExpanded(line, False);
        if LineMaxSubord > Line then
          HideLines(line+1, lineMaxSubord);
      end;
    end;
    Inc(Line);
  end;
end;

procedure TScintilla.EnsureRangeVisible(PosStart, PosEnd: integer);
Var
  LineStart, LineEnd, i : integer;
begin
  LineStart := LineFromPosition(PosStart);
  LineEnd := LineFromPosition(PosEnd);
  for i := Min(LineStart, LineEnd) to Max(LineStart, LineEnd) do
    EnsureVisible(i);
end;

(**
 * Find if there is a brace next to the caret, checking before caret first, then
 * after caret. If brace found also find its matching brace.
 * @return @c true if inside a bracket pair.
 *)

procedure TScintilla.FindMatchingBracePosition(var braceAtCaret : integer;
             var braceOpposite : integer; var IsInside : boolean; sloppy : boolean=true);
Var
  IsAfter : boolean;
  CaretPos : integer;
  CharBefore, CharAfter: Char;
  ColonMode : boolean;
  LineStart, LineMaxSubord :integer;
begin
  IsInside := False;
  CaretPos := GetCurrentPos;
  BraceAtCaret := -1;
  BraceOpposite := -1;
  CharBefore := #0;
  if CaretPos > 0 then
    CharBefore := Char(GetCharAt(CaretPos -1));
  // Priority goes to character before caret
	if (CharBefore <> #0) and  (Pos(CharBefore, '[](){}') > 0)  then
		BraceAtCaret := caretPos - 1;

  ColonMode := False;
  if (GetLexer = SCLEX_PYTHON) and (CharBefore = ':') then begin
		BraceAtCaret := caretPos - 1;
		ColonMode := true;
  end;

  IsAfter := True;
  If (Sloppy and (BraceAtCaret < 0)) then begin
    // No brace found so check other side
    CharAfter := Char(GetCharAt(CaretPos));
  	if (CharAfter <> #0) and  (Pos(CharAfter, '[](){}') > 0)  then begin
	  	BraceAtCaret := CaretPos;
      IsAfter := False;
    end;
    if (GetLexer = SCLEX_PYTHON) and (CharAfter = ':') then begin
      BraceAtCaret := caretPos;
      ColonMode := true;
    end;
  end;

  if BraceAtCaret >= 0 then begin
    if ColonMode then begin
      LineStart := LineFromPosition(BraceAtCaret);
      LineMaxSubord := GetLastChild(LineStart, -1);
      BraceOpposite := GetLineEndPosition(LineMaxSubord);
    end else
      BraceOpposite := BraceMatch(BraceAtCaret);

    if BraceOpposite > BraceAtCaret then
      IsInside := IsAfter
    else
      IsInside := not IsAfter;
  end;
end;

procedure TScintilla.GoMatchingBrace(Select: boolean; Sloppy : boolean);
Var
  BraceAtCaret : integer;
  BraceOpposite : integer;
  IsInside : Boolean;
begin
  FindMatchingBracePosition(braceAtCaret, braceOpposite, IsInside, Sloppy);
  // Convert the character positions into caret positions based on whether
	// the caret position was inside or outside the braces.
  if BraceOpposite >= 0 then begin
    if IsInside then begin
      if braceOpposite > braceAtCaret then
        Inc(braceAtCaret)
      else
        Inc(braceOpposite);
    end else begin
      if braceOpposite > braceAtCaret then
        Inc(braceOpposite)
      else
        Inc(braceAtCaret);
    end;

		EnsureRangeVisible(braceOpposite, braceOpposite);
		if Select then
			SetSel(braceAtCaret, braceOpposite)
		else
			SetSel(BraceOpposite, BraceOpposite);
  end;
end;


procedure TScintilla.ProcessBraces;
Var
  BraceAtCaret : integer;
  BraceOpposite : integer;
  IsInside : boolean;
  chBrace : char;
  ColumnAtCaret, ColumnOpposite : integer;
  lineStart, indentPos, indentSize : integer;
  indentPosNext, columnAtCaretNext : integer;
begin
  FindMatchingBracePosition(BraceAtCaret, BraceOpposite, IsInside, True);
	if ((BraceAtCaret <> -1) and (BraceOpposite = -1)) then begin
		BraceBadLight(braceAtCaret);
    Self.SetHighlightGuide(0);
	end else begin
		chBrace := Char(GetCharAt(BraceAtCaret));
    BraceHighlight(braceAtCaret, braceOpposite);
		columnAtCaret := GetColumn(BraceAtCaret);
    columnOpposite := GetColumn(BraceOpposite);
    if chBrace = ':' then begin
			lineStart := LineFromPosition(braceAtCaret);
			indentPos := GetLineIndentPosition(lineStart);
			indentPosNext := GetLineIndentPosition(lineStart + 1);
			columnAtCaret := GetColumn(indentPos);
			columnAtCaretNext := GetColumn(indentPosNext);
			indentSize := Self.GetIndent;
			if (columnAtCaretNext - indentSize > 1) then
				columnAtCaret := columnAtCaretNext - indentSize;
			if (columnOpposite = 0) then	// If the final line of the structure is empty
				columnOpposite := columnAtCaret;
    end;
    Self.SetHighlightGuide(Min(columnAtCaret, columnOpposite));
  end;
end;

procedure TScintilla.SetKeyCommands(const Value: TSciKeyCommandCollection);
begin
  fKeyCommands.Assign(Value);
end;

initialization
  scmod := LoadLibrary('SciLexer.DLL');

finalization
  if scmod > 0 then FreeLibrary(scmod);

end.